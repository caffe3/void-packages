From ac0938ca972dde7c7219ede3fd6cd8cb3e83ef8b Mon Sep 17 00:00:00 2001
From: Haniel Barbosa <hanielbbarbosa@gmail.com>
Date: Mon, 16 Sep 2024 17:01:13 -0300
Subject: [PATCH 052/312] [alethe] Have Alethe backend better indicate
 unsupported proofs  (#11178)

This also fixes the translation of resolution to account for potential
unsupported elements in the arguments.
---
 src/proof/alethe/alethe_node_converter.cpp | 196 ++++++++++++++++++++-
 src/proof/alethe/alethe_post_processor.cpp |  20 +--
 2 files changed, 203 insertions(+), 13 deletions(-)

diff --git a/src/proof/alethe/alethe_node_converter.cpp b/src/proof/alethe/alethe_node_converter.cpp
index 81acafa66..767fac30e 100644
--- a/src/proof/alethe/alethe_node_converter.cpp
+++ b/src/proof/alethe/alethe_node_converter.cpp
@@ -43,6 +43,8 @@ Node AletheNodeConverter::postConvert(Node n)
 {
   NodeManager* nm = NodeManager::currentNM();
   Kind k = n.getKind();
+  Trace("alethe-conv") << "AletheNodeConverter: convert " << n << ", kind " << k
+                       << "\n";
   switch (k)
   {
     case Kind::BITVECTOR_BIT:
@@ -193,8 +195,8 @@ Node AletheNodeConverter::postConvert(Node n)
         return witness;
       }
       std::stringstream ss;
-      ss << "Proof contains Skolem (kind " << sfi << ", term " << n
-         << ") is not supported by Alethe.";
+      ss << "\"Proof unsupported by Alethe: contains Skolem (kind " << sfi
+         << ", term " << n << "\"";
       d_error = ss.str();
       return Node::null();
     }
@@ -218,10 +220,198 @@ Node AletheNodeConverter::postConvert(Node n)
       Trace("alethe-conv") << ".. converted to choice: " << converted << "\n";
       return converted;
     }
-    default:
+    // other handled kinds but no-op in conversion. Everything else is
+    // unsupported
+    /* from builtin */
+    case Kind::SORT_TYPE:
+    case Kind::INSTANTIATED_SORT_TYPE:
+    case Kind::UNINTERPRETED_SORT_VALUE:
+    case Kind::BUILTIN:
+    case Kind::EQUAL:
+    case Kind::DISTINCT:
+    case Kind::VARIABLE:
+    case Kind::BOUND_VARIABLE:
+    case Kind::SEXPR:
+    case Kind::TYPE_CONSTANT:
+    case Kind::RAW_SYMBOL:
+    /* from booleans */
+    case Kind::CONST_BOOLEAN:
+    case Kind::NOT:
+    case Kind::AND:
+    case Kind::IMPLIES:
+    case Kind::OR:
+    case Kind::XOR:
+    case Kind::ITE:
+    /* from uf */
+    case Kind::APPLY_UF:
+    case Kind::FUNCTION_TYPE:
+    case Kind::LAMBDA:
+    case Kind::HO_APPLY:
+    case Kind::FUNCTION_ARRAY_CONST:
+    case Kind::BITVECTOR_TO_NAT:
+    case Kind::INT_TO_BITVECTOR_OP:
+    case Kind::INT_TO_BITVECTOR:
+    /* from arith */
+    case Kind::ADD:
+    case Kind::MULT:
+    case Kind::NONLINEAR_MULT:
+    case Kind::SUB:
+    case Kind::NEG:
+    case Kind::DIVISION:
+    case Kind::INTS_DIVISION:
+    case Kind::INTS_MODULUS:
+    case Kind::ABS:
+    case Kind::DIVISIBLE:
+    case Kind::DIVISIBLE_OP:
+    case Kind::CONST_RATIONAL:
+    case Kind::CONST_INTEGER:
+    case Kind::LT:
+    case Kind::LEQ:
+    case Kind::GT:
+    case Kind::GEQ:
+    case Kind::IS_INTEGER:
+    case Kind::TO_INTEGER:
+    case Kind::TO_REAL:
+    /* from BV */
+    case Kind::BITVECTOR_TYPE:
+    case Kind::CONST_BITVECTOR:
+    case Kind::BITVECTOR_SIZE:
+    case Kind::CONST_BITVECTOR_SYMBOLIC:
+    case Kind::BITVECTOR_CONCAT:
+    case Kind::BITVECTOR_AND:
+    case Kind::BITVECTOR_COMP:
+    case Kind::BITVECTOR_OR:
+    case Kind::BITVECTOR_XOR:
+    case Kind::BITVECTOR_NOT:
+    case Kind::BITVECTOR_NAND:
+    case Kind::BITVECTOR_NOR:
+    case Kind::BITVECTOR_XNOR:
+    case Kind::BITVECTOR_MULT:
+    case Kind::BITVECTOR_NEG:
+    case Kind::BITVECTOR_ADD:
+    case Kind::BITVECTOR_SUB:
+    case Kind::BITVECTOR_UDIV:
+    case Kind::BITVECTOR_UREM:
+    case Kind::BITVECTOR_SDIV:
+    case Kind::BITVECTOR_SMOD:
+    case Kind::BITVECTOR_SREM:
+    case Kind::BITVECTOR_ASHR:
+    case Kind::BITVECTOR_LSHR:
+    case Kind::BITVECTOR_SHL:
+    case Kind::BITVECTOR_ULE:
+    case Kind::BITVECTOR_ULT:
+    case Kind::BITVECTOR_UGE:
+    case Kind::BITVECTOR_UGT:
+    case Kind::BITVECTOR_SLE:
+    case Kind::BITVECTOR_SLT:
+    case Kind::BITVECTOR_SGE:
+    case Kind::BITVECTOR_SGT:
+    case Kind::BITVECTOR_ULTBV:
+    case Kind::BITVECTOR_SLTBV:
+    case Kind::BITVECTOR_ACKERMANNIZE_UDIV:
+    case Kind::BITVECTOR_ACKERMANNIZE_UREM:
+    case Kind::BITVECTOR_BIT_OP:
+    case Kind::BITVECTOR_EXTRACT_OP:
+    case Kind::BITVECTOR_EXTRACT:
+    case Kind::BITVECTOR_REPEAT_OP:
+    case Kind::BITVECTOR_REPEAT:
+    case Kind::BITVECTOR_ROTATE_LEFT_OP:
+    case Kind::BITVECTOR_ROTATE_LEFT:
+    case Kind::BITVECTOR_ROTATE_RIGHT_OP:
+    case Kind::BITVECTOR_ROTATE_RIGHT:
+    case Kind::BITVECTOR_SIGN_EXTEND_OP:
+    case Kind::BITVECTOR_SIGN_EXTEND:
+    case Kind::BITVECTOR_ZERO_EXTEND_OP:
+    case Kind::BITVECTOR_ZERO_EXTEND:
+    /* from arrays */
+    case Kind::ARRAY_TYPE:
+    case Kind::SELECT:
+    case Kind::STORE:
+    case Kind::STORE_ALL:
+    case Kind::ARRAY_LAMBDA:
+    /* from datatypes */
+    case Kind::CONSTRUCTOR_TYPE:
+    case Kind::SELECTOR_TYPE:
+    case Kind::TESTER_TYPE:
+    case Kind::APPLY_CONSTRUCTOR:
+    case Kind::APPLY_SELECTOR:
+    case Kind::APPLY_TESTER:
+    case Kind::DATATYPE_TYPE:
+    case Kind::PARAMETRIC_DATATYPE:
+    case Kind::TUPLE_TYPE:
+    case Kind::APPLY_TYPE_ASCRIPTION:
+    case Kind::ASCRIPTION_TYPE:
+    case Kind::DT_SIZE:
+    case Kind::DT_HEIGHT_BOUND:
+    case Kind::DT_SIZE_BOUND:
+    case Kind::MATCH:
+    case Kind::MATCH_CASE:
+    case Kind::MATCH_BIND_CASE:
+    /* from strings */
+    case Kind::STRING_CONCAT:
+    case Kind::STRING_IN_REGEXP:
+    case Kind::STRING_LENGTH:
+    case Kind::STRING_SUBSTR:
+    case Kind::STRING_CHARAT:
+    case Kind::STRING_CONTAINS:
+    case Kind::STRING_LT:
+    case Kind::STRING_LEQ:
+    case Kind::STRING_INDEXOF:
+    case Kind::STRING_REPLACE:
+    case Kind::STRING_REPLACE_ALL:
+    case Kind::STRING_REPLACE_RE:
+    case Kind::STRING_REPLACE_RE_ALL:
+    case Kind::STRING_PREFIX:
+    case Kind::STRING_SUFFIX:
+    case Kind::STRING_IS_DIGIT:
+    case Kind::STRING_ITOS:
+    case Kind::STRING_STOI:
+    case Kind::STRING_TO_CODE:
+    case Kind::STRING_FROM_CODE:
+    case Kind::STRING_UNIT:
+    case Kind::CONST_STRING:
+    case Kind::STRING_TO_REGEXP:
+    case Kind::REGEXP_CONCAT:
+    case Kind::REGEXP_UNION:
+    case Kind::REGEXP_INTER:
+    case Kind::REGEXP_DIFF:
+    case Kind::REGEXP_STAR:
+    case Kind::REGEXP_PLUS:
+    case Kind::REGEXP_OPT:
+    case Kind::REGEXP_RANGE:
+    case Kind::REGEXP_COMPLEMENT:
+    case Kind::REGEXP_NONE:
+    case Kind::REGEXP_ALL:
+    case Kind::REGEXP_ALLCHAR:
+    case Kind::REGEXP_REPEAT_OP:
+    case Kind::REGEXP_REPEAT:
+    case Kind::REGEXP_LOOP_OP:
+    case Kind::REGEXP_LOOP:
+    case Kind::REGEXP_RV:
+    /* from quantifiers */
+    case Kind::EXISTS:
+    case Kind::INST_CONSTANT:
+    case Kind::ORACLE:
+    case Kind::BOUND_VAR_LIST:
+    case Kind::INST_PATTERN:
+    case Kind::INST_NO_PATTERN:
+    case Kind::INST_ATTRIBUTE:
+    case Kind::INST_POOL:
+    case Kind::INST_ADD_TO_POOL:
+    case Kind::SKOLEM_ADD_TO_POOL:
+    case Kind::ORACLE_FORMULA_GEN:
+    case Kind::INST_PATTERN_LIST:
     {
       return n;
     }
+    default:
+    {
+      Trace("alethe-conv") << "AletheNodeConverter: ...unsupported kind\n";
+      std::stringstream ss;
+      ss << "\"Proof unsupported by Alethe: contains operator " << k << "\"";
+      d_error = ss.str();
+      return Node::null();
+    }
   }
   return n;
 }
diff --git a/src/proof/alethe/alethe_post_processor.cpp b/src/proof/alethe/alethe_post_processor.cpp
index e9e893dd6..7bd071530 100644
--- a/src/proof/alethe/alethe_post_processor.cpp
+++ b/src/proof/alethe/alethe_post_processor.cpp
@@ -581,11 +581,6 @@ bool AletheProofPostprocessCallback::update(Node res,
       {
         cargs = args;
       }
-      // The arguments for the actual step will include the id of the rule,
-      // original conclusion and the one to print and so on.
-      std::vector<Node> newArgs{nm->mkConstInt(Rational(static_cast<uint32_t>(
-                                    AletheRule::RESOLUTION_OR))),
-                                res};
       Node conclusion;
       if (!isSingletonClause(res, children, cargs))
       {
@@ -601,19 +596,17 @@ bool AletheProofPostprocessCallback::update(Node res,
       {
         conclusion = nm->mkNode(Kind::SEXPR, d_cl, res);
       }
-      newArgs.push_back(conclusion);
       // checker expects opposite order. We always keep the pivots because we
       // need them to compute in updatePost whether we will add OR steps. If
       // d_resPivots is off we will remove the pivots after that.
+      std::vector<Node> newArgs;
       for (size_t i = 0, size = cargs.size(); i < size; i = i + 2)
       {
         newArgs.push_back(cargs[i + 1]);
         newArgs.push_back(cargs[i]);
       }
-      Trace("alethe-proof")
-          << "... add alethe step " << res << " / " << d_anc.convert(conclusion)
-          << " " << id << " " << children << " / " << newArgs << std::endl;
-      return cdp->addStep(res, ProofRule::ALETHE_RULE, children, newArgs);
+      return addAletheStep(
+          AletheRule::RESOLUTION_OR, res, conclusion, children, newArgs, *cdp);
     }
     // ======== Factoring
     // See proof_rule.h for documentation on the FACTORING rule. This comment
@@ -2663,6 +2656,13 @@ const std::string& AletheProofPostprocess::getError()
 
 bool AletheProofPostprocess::process(std::shared_ptr<ProofNode> pf)
 {
+  if (logicInfo().isHigherOrder())
+  {
+    std::stringstream ss;
+    ss << "\"Proof unsupported by Alethe: contains higher-order elements\"";
+    d_reasonForConversionFailure = ss.str();
+    return false;
+  }
   // first two nodes are scopes for definitions and other assumptions. We
   // process only the internal proof node. And we merge these two scopes
   Assert(pf->getRule() == ProofRule::SCOPE
-- 
2.47.1

