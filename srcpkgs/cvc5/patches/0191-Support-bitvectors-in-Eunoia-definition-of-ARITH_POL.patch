From c645d256b82f3391d83e96a910f9cf0573016fca Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Wed, 20 Nov 2024 21:53:17 -0600
Subject: [PATCH 191/312] Support bitvectors in Eunoia definition of
 ARITH_POLY_NORM (#11347)

Also fixes the evaluator for `int.pow2`.

---------

Co-authored-by: Abdalrhman Mohamed <abdoo8080@outlook.com>
---
 proofs/eo/cpc/Cpc.eo               |   7 +-
 proofs/eo/cpc/programs/Arith.eo    |  40 ++++++++---
 proofs/eo/cpc/programs/PolyNorm.eo | 111 ++++++++++++++++++++++-------
 src/theory/evaluator.cpp           |   7 +-
 4 files changed, 126 insertions(+), 39 deletions(-)

diff --git a/proofs/eo/cpc/Cpc.eo b/proofs/eo/cpc/Cpc.eo
index 9b79ede60..7d39420d9 100644
--- a/proofs/eo/cpc/Cpc.eo
+++ b/proofs/eo/cpc/Cpc.eo
@@ -140,7 +140,8 @@
       (($run_evaluate (to_int x))          (eo::to_z ($run_evaluate x)))
       (($run_evaluate (is_int x))          (eo::is_eq (eo::to_q (eo::to_z x)) (eo::to_q x)))
       (($run_evaluate (int.log2 x))        ($arith_eval_int_log_2 ($run_evaluate x)))
-      (($run_evaluate (int.ispow2 x))      ($arith_eval_is_pow_2 ($run_evaluate x)))
+      (($run_evaluate (int.pow2 x))        ($arith_eval_int_pow_2 ($run_evaluate x)))
+      (($run_evaluate (int.ispow2 x))      ($arith_eval_int_is_pow_2 ($run_evaluate x)))
 
       ; strings
       (($run_evaluate (str.++ xs yss))     (eo::concat ($run_evaluate xs) ($run_evaluate yss)))
@@ -212,10 +213,6 @@
 ; requires: >
 ;   That the arithmetic/bitvector terms a and b are equal up polynomial
 ;   normalization.
-; note: >
-;   The current implementation of $is_poly_norm does not support bitvectors.
-;   Therefore, cvc5 will not output this rule for bitvector proofs; instead, it
-;   will output a trust rule.
 ; conclusion: The given equality.
 (declare-rule arith_poly_norm ((U Type) (a U) (b U))
   :args ((= a b))
diff --git a/proofs/eo/cpc/programs/Arith.eo b/proofs/eo/cpc/programs/Arith.eo
index e5ff184d2..af636e8e8 100644
--- a/proofs/eo/cpc/programs/Arith.eo
+++ b/proofs/eo/cpc/programs/Arith.eo
@@ -91,18 +91,42 @@
 (define $arith_eval_int_log_2 ((x Int))
   (eo::ite (eo::is_neg (eo::neg x)) ($arith_eval_int_log_2_rec x) (int.log2 x)))
 
-; program: $arith_eval_is_pow_2_rec
+; program: $arith_eval_int_pow_2_rec
+; args:
+; - x  Int: The term to compute 2 to the power of, assumed to be a positive numeral value.
+; return: 2 to the power of x.
+; note: Helper method for $arith_eval_int_pow_2 below.
+(program $arith_eval_int_pow_2_rec ((x Int))
+  (Int) Int
+  (
+  (($arith_eval_int_pow_2_rec 0) 1)
+  (($arith_eval_int_pow_2_rec x) (eo::mul 2 ($arith_eval_int_pow_2_rec (eo::add x -1))))
+  )
+)
+
+; define: $arith_eval_int_pow_2
+; args:
+; - x Int: The term to compute whether it is a power of two.
+; return: >
+;   two raised to the power of x. If x is not a numeral value, we return
+;   the term (int.pow2 x).
+(define $arith_eval_int_pow_2 ((x Int))
+  (eo::ite (eo::is_z x)
+    (eo::ite (eo::is_neg x) 0 ($arith_eval_int_pow_2_rec x))
+    (int.pow2 x)))
+
+; program: $arith_eval_int_is_pow_2_rec
 ; args:
 ; - x  Int: The term to compute whether it is a power of two, assumed to be a positive numeral value.
 ; return: true iff x is a power of two.
 ; note: Helper method for $arith_eval_is_pow_2 below.
-(program $arith_eval_is_pow_2_rec ((x Int))
+(program $arith_eval_int_is_pow_2_rec ((x Int))
   (Int) Bool
   (
-  (($arith_eval_is_pow_2_rec 1) true)
-  (($arith_eval_is_pow_2_rec x) (eo::ite (eo::is_eq (eo::zmod x 2) 0) 
-                                  ($arith_eval_is_pow_2_rec (eo::zdiv x 2))
-                                  false))
+  (($arith_eval_int_is_pow_2_rec 1) true)
+  (($arith_eval_int_is_pow_2_rec x) (eo::ite (eo::is_eq (eo::zmod x 2) 0)
+                                      ($arith_eval_int_is_pow_2_rec (eo::zdiv x 2))
+                                      false))
   )
 )
 
@@ -112,7 +136,7 @@
 ; return: >
 ;   true iff x is a power of two. If x is not a numeral value, we return
 ;   the term (int.ispow2 x).
-(define $arith_eval_is_pow_2 ((x Int))
+(define $arith_eval_int_is_pow_2 ((x Int))
   (eo::ite (eo::is_z x) 
-    (eo::ite (eo::is_neg x) false ($arith_eval_is_pow_2_rec x))
+    (eo::ite (eo::is_neg x) false ($arith_eval_int_is_pow_2_rec x))
     (int.ispow2 x)))
diff --git a/proofs/eo/cpc/programs/PolyNorm.eo b/proofs/eo/cpc/programs/PolyNorm.eo
index 58f91c84f..a4c0e693a 100644
--- a/proofs/eo/cpc/programs/PolyNorm.eo
+++ b/proofs/eo/cpc/programs/PolyNorm.eo
@@ -24,6 +24,22 @@
     (($poly_neg (@poly (@mon a c) p)) (eo::cons @poly (@mon a (eo::neg c)) ($poly_neg p)))
   )
 )
+; program: $poly_mod_coeffs
+; args:
+; - p @Polynomial: The polynomial to modify.
+; - w Int: The modulus to consider
+; return: the given polynomial where all coefficient are taken mod w.
+(program $poly_mod_coeffs ((T Type) (c Real) (a T) (p @Polynomial :list) (w Int))
+  (@Polynomial Int) @Polynomial
+  (
+    (($poly_mod_coeffs @poly.zero w)           @poly.zero)
+    (($poly_mod_coeffs (@poly (@mon a c) p) w) (eo::define ((newc (eo::zmod (eo::to_z c) w)))
+                                               (eo::ite (eo::is_eq newc 0)
+                                                 ; if it becomes zero, it cancels
+                                                 ($poly_mod_coeffs p w)
+                                                 (eo::cons @poly (@mon a (eo::to_q newc)) ($poly_mod_coeffs p w)))))
+  )
+)
 
 ; program: $poly_add
 ; args:
@@ -48,17 +64,25 @@
 ; program: $mvar_mul_mvar
 ; args:
 ; - a X: The first monomial variable to multiply.
-; - b Y: The second monomial variable to multiply.
+; - c Y: The second monomial variable to multiply.
 ; return: the multiplication of the given monomial variables.
-(program $mvar_mul_mvar ((T Type) (U Type) (V Type) (W Type) (X Type) (Y Type) (Z Type) (a1 T) (a2 U :list) (b1 V) (b2 W :list))
+(program $mvar_mul_mvar ((T Type) (U Type) (V Type) (W Type) (X Type) (Y Type) (Z Type) 
+                         (a1 T) (a2 U :list) (c1 V) (c2 W :list)
+                         (m Int)  (ba1 (BitVec m)) (ba2 (BitVec m) :list) (bc1 (BitVec m)) (bc2 (BitVec m) :list))
   (X Y) Z
   (
-    (($mvar_mul_mvar (* a1 a2) (* b1 b2))  (eo::ite ($compare_var a1 b1)
-                                            (eo::cons * a1 ($mvar_mul_mvar a2 (* b1 b2)))
-                                            (eo::cons * b1 ($mvar_mul_mvar (* a1 a2) b2))))
+    (($mvar_mul_mvar (* a1 a2) (* c1 c2))  (eo::ite ($compare_var a1 c1)
+                                             (eo::cons * a1 ($mvar_mul_mvar a2 (* c1 c2)))
+                                             (eo::cons * c1 ($mvar_mul_mvar (* a1 a2) c2))))
     (($mvar_mul_mvar (* a1 a2) 1)          (* a1 a2))
-    (($mvar_mul_mvar 1 (* b1 b2))          (* b1 b2))
-    (($mvar_mul_mvar 1 1)                  1)
+    (($mvar_mul_mvar 1 (* c1 c2))          (* c1 c2))
+    (($mvar_mul_mvar (bvmul ba1 ba2) (bvmul bc1 bc2))  (eo::ite ($compare_var ba1 bc1)
+                                                         (eo::cons bvmul ba1 ($mvar_mul_mvar ba2 (bvmul bc1 bc2)))
+                                                         (eo::cons bvmul bc1 ($mvar_mul_mvar (bvmul ba1 ba2) bc2))))
+    (($mvar_mul_mvar (bvmul ba1 ba2) bc1)              (eo::requires (eo::to_z bc1) 1 (bvmul ba1 ba2)))
+    (($mvar_mul_mvar ba1 (bvmul bc1 bc2))              (eo::requires (eo::to_z ba1) 1 (bvmul bc1 bc2)))
+    (($mvar_mul_mvar ba1 bc1)                          (eo::requires (eo::to_z ba1) 1
+                                                       (eo::requires (eo::to_z bc1) 1 ba1)))
   )
 )
 
@@ -105,32 +129,69 @@
 ; args:
 ; - a T: The arithmetic term to process of type Int or Real.
 ; return: the polynomial corresponding to the (normalized) form of a.
-(program $get_poly_norm ((T Type) (U Type) (V Type) (a T) (a1 U) (a2 V :list))
+(program $get_arith_poly_norm ((T Type) (U Type) (V Type) (a T) (a1 U) (a2 V :list))
   (T) @Polynomial
   (
-    (($get_poly_norm (- a1))       ($poly_neg ($get_poly_norm a1)))
-    (($get_poly_norm (+ a1 a2))    ($poly_add ($get_poly_norm a1) ($get_poly_norm a2)))
-    (($get_poly_norm (- a1 a2))    ($poly_add ($get_poly_norm a1) ($poly_neg ($get_poly_norm a2))))
-    (($get_poly_norm (* a1 a2))    ($poly_mul ($get_poly_norm a1) ($get_poly_norm a2)))
-    (($get_poly_norm (to_real a1)) ($get_poly_norm a1))
-    (($get_poly_norm a)            (eo::define ((aq (eo::to_q a)))
-                                  ; if it is a constant, which can be tested if to_q is idempotent after the first
-                                  (eo::ite (eo::is_eq aq (eo::to_q aq))
-                                    ; if it is zero, it cancels, otherwise it is 1 with itself as coefficient
-                                    (eo::ite (eo::is_eq aq 0/1)
-                                      @poly.zero
-                                      (@poly (@mon 1 aq)))
-                                  (@poly (@mon (* a) 1/1)))))    ; introduces list
+    (($get_arith_poly_norm (- a1))        ($poly_neg ($get_arith_poly_norm a1)))
+    (($get_arith_poly_norm (+ a1 a2))     ($poly_add ($get_arith_poly_norm a1) ($get_arith_poly_norm a2)))
+    (($get_arith_poly_norm (- a1 a2))     ($poly_add ($get_arith_poly_norm a1) ($poly_neg ($get_arith_poly_norm a2))))
+    (($get_arith_poly_norm (* a1 a2))     ($poly_mul ($get_arith_poly_norm a1) ($get_arith_poly_norm a2)))
+    (($get_arith_poly_norm (to_real a1))  ($get_arith_poly_norm a1))
+    (($get_arith_poly_norm a)             (eo::define ((aq (eo::to_q a)))
+                                          ; check if a is a constant (Int or Real)
+                                          (eo::ite (eo::is_q aq)
+                                            ; if it is zero, it cancels, otherwise it is 1 with itself as coefficient
+                                            (eo::ite (eo::is_eq aq 0/1)
+                                              @poly.zero
+                                              (@poly (@mon 1 aq)))
+                                          (@poly (@mon (* a) 1/1)))))    ; introduces list
   )
 )
 
+; program: $get_bv_poly_norm_rec
+; args:
+; - b (BitVec m): The bitvector term to process.
+; return: the polynomial corresponding to the (normalized) form of b, prior to taking mod of its coefficients.
+(program $get_bv_poly_norm_rec ((m Int) (b (BitVec m)) (b1 (BitVec m)) (b2 (BitVec m) :list))
+  ((BitVec m)) @Polynomial
+  (
+    (($get_bv_poly_norm_rec (bvneg b1))    ($poly_neg ($get_bv_poly_norm_rec b1)))
+    (($get_bv_poly_norm_rec (bvadd b1 b2)) ($poly_add ($get_bv_poly_norm_rec b1) ($get_bv_poly_norm_rec b2)))
+    (($get_bv_poly_norm_rec (bvsub b1 b2)) ($poly_add ($get_bv_poly_norm_rec b1) ($poly_neg ($get_bv_poly_norm_rec b2))))
+    (($get_bv_poly_norm_rec (bvmul b1 b2)) ($poly_mul ($get_bv_poly_norm_rec b1) ($get_bv_poly_norm_rec b2)))
+    (($get_bv_poly_norm_rec b)             (eo::define ((bt (eo::typeof b)))
+                                           (eo::define ((one (eo::to_bin ($bv_bitwidth bt) 1)))
+                                           (eo::ite (eo::is_bin b)
+                                             (eo::define ((bz (eo::to_z b)))
+                                             ; if it is zero, it cancels, otherwise it is 1 with itself as coefficient
+                                             (eo::ite (eo::is_eq bz 0)
+                                               @poly.zero
+                                               (@poly (@mon one (eo::to_q bz)))))
+                                           (@poly (@mon (bvmul b) 1/1))))))    ; introduces list
+  )
+)
+
+; program: $get_bv_poly_norm
+; args:
+; - w Int: two raised to the bitwidth of the second argument.
+; - b (BitVec m): The bitvector term to process.
+; return: the polynomial corresponding to the (normalized) form of b.
+(define $get_bv_poly_norm ((m Int :implicit) (w Int) (b (BitVec m)))
+  ($poly_mod_coeffs ($get_bv_poly_norm_rec b) w))
+
 ; define: $is_poly_norm
 ; args:
-; - a T: The first arithmetic term to process, of type Int or Real.
-; - b T: The second arithmetic term to process, of type Int or Real.
+; - a T: The first arithmetic term to process, of type Int, Real, or BitVec type.
+; - b T: The second arithmetic term to process, of type Int, Real, or BitVec type.
 ; return: true if a and b normalize to the same polynomial
 (define $is_poly_norm ((T Type :implicit) (a T) (b T))
-  (eo::is_eq ($get_poly_norm a) ($get_poly_norm b))
+  (eo::define ((at (eo::typeof a)))
+  (eo::ite (eo::is_eq ($is_arith_type at) true)
+    ; if arithmetic, use arith routine on a and b
+    (eo::is_eq ($get_arith_poly_norm a) ($get_arith_poly_norm b))
+    ; it bitvector, get two to the power of the bitwidth and use bv routine on a and b
+    (eo::define ((w ($arith_eval_int_pow_2 ($bv_bitwidth at))))
+      (eo::is_eq ($get_bv_poly_norm w a) ($get_bv_poly_norm w b)))))
 )
 
 ; program: $arith_poly_to_term_rec
@@ -153,7 +214,7 @@
 ;   a term corresponding to the polynomial obtained by converting t to a polynomial.
 ;   This can be used for normalizing terms according to arithmetic.
 (define $arith_poly_to_term ((T Type :implicit) (t T))
-  ($arith_poly_to_term_rec ($get_poly_norm t)))
+  ($arith_poly_to_term_rec ($get_arith_poly_norm t)))
 
 ; program: $is_poly_norm_rel_consts
 ; args:
diff --git a/src/theory/evaluator.cpp b/src/theory/evaluator.cpp
index 0bdae858f..36dbbfa94 100644
--- a/src/theory/evaluator.cpp
+++ b/src/theory/evaluator.cpp
@@ -605,7 +605,12 @@ EvalResult Evaluator::evalInternal(
         {
           const Rational& x = results[currNode[0]].d_rat;
           bool valid = false;
-          if (x.getNumerator().fitsUnsignedInt())
+          if (x.sgn() < 0)
+          {
+            results[currNode] = EvalResult(Rational(0));
+            valid = true;
+          }
+          else if (x.getNumerator().fitsUnsignedInt())
           {
             uint32_t value = x.getNumerator().toUnsignedInt();
             if (value <= 256)
-- 
2.47.1

