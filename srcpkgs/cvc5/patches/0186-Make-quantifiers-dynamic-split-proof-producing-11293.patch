From 35aaf57de88ef8c4f70958547ade0f0257e189f1 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Wed, 20 Nov 2024 11:24:06 -0600
Subject: [PATCH 186/312] Make quantifiers dynamic split proof producing
 (#11293)

Fills in 6 remaining proofs of lemmas in our regressions.

---------

Co-authored-by: Abdalrhman Mohamed <abdoo8080@outlook.com>
---
 include/cvc5/cvc5_proof_rule.h                |  14 ++
 src/api/cpp/cvc5_proof_rule_template.cpp      |   1 +
 src/theory/quantifiers/quant_split.cpp        | 218 +++++++++++++-----
 src/theory/quantifiers/quant_split.h          |  12 +-
 .../quantifiers/quantifiers_rewriter.cpp      |  13 ++
 5 files changed, 200 insertions(+), 58 deletions(-)

diff --git a/include/cvc5/cvc5_proof_rule.h b/include/cvc5/cvc5_proof_rule.h
index cec7c58ca..26630f4ee 100644
--- a/include/cvc5/cvc5_proof_rule.h
+++ b/include/cvc5/cvc5_proof_rule.h
@@ -2548,6 +2548,20 @@ enum ENUM(ProofRewriteRule)
    * \endverbatim
    */
   EVALUE(QUANT_MINISCOPE_FV),
+  /**
+   * \verbatim embed:rst:leading-asterisk
+   * **Quantifiers -- Datatypes Split**
+   *
+   * .. math::
+   *   (\forall x Y.\> F) = (\forall X_1 Y. F_1) \vee \cdots \vee (\forall X_n Y. F_n)
+   * 
+   * where :math:`x` is of a datatype type with constructors
+   * :math:`C_1, \ldots, C_n`, where for each :math:`i = 1, \ldots, n`,
+   * :math:`F_i` is :math:`F \{ x \mapsto C_i(X_i) \}`.
+   * 
+   * \endverbatim
+   */
+  EVALUE(QUANT_DT_SPLIT),
   /**
    * \verbatim embed:rst:leading-asterisk
    * **Quantifiers -- Macro connected free variable partitioning**
diff --git a/src/api/cpp/cvc5_proof_rule_template.cpp b/src/api/cpp/cvc5_proof_rule_template.cpp
index 359077bf1..e5cb35f21 100644
--- a/src/api/cpp/cvc5_proof_rule_template.cpp
+++ b/src/api/cpp/cvc5_proof_rule_template.cpp
@@ -244,6 +244,7 @@ const char* toString(cvc5::ProofRewriteRule rule)
     case ProofRewriteRule::QUANT_MERGE_PRENEX: return "quant-merge-prenex";
     case ProofRewriteRule::QUANT_MINISCOPE: return "quant-miniscope";
     case ProofRewriteRule::QUANT_MINISCOPE_FV: return "quant-miniscope-fv";
+    case ProofRewriteRule::QUANT_DT_SPLIT: return "quant-dt-split";
     case ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV:
       return "macro-quant-partition-connected-fv";
     case ProofRewriteRule::MACRO_QUANT_VAR_ELIM_EQ:
diff --git a/src/theory/quantifiers/quant_split.cpp b/src/theory/quantifiers/quant_split.cpp
index 053421ea5..2868fd41a 100644
--- a/src/theory/quantifiers/quant_split.cpp
+++ b/src/theory/quantifiers/quant_split.cpp
@@ -15,12 +15,17 @@
 
 #include "theory/quantifiers/quant_split.h"
 
+#include "expr/bound_var_manager.h"
 #include "expr/dtype.h"
 #include "expr/dtype_cons.h"
 #include "options/quantifiers_options.h"
+#include "options/smt_options.h"
+#include "proof/proof.h"
+#include "proof/proof_generator.h"
 #include "theory/datatypes/theory_datatypes_utils.h"
 #include "theory/quantifiers/first_order_model.h"
 #include "theory/quantifiers/term_database.h"
+#include "util/rational.h"
 
 using namespace cvc5::internal::kind;
 
@@ -28,6 +33,95 @@ namespace cvc5::internal {
 namespace theory {
 namespace quantifiers {
 
+/**
+ * A proof generator for quantifiers splitting inferences
+ */
+class QuantDSplitProofGenerator : protected EnvObj, public ProofGenerator
+{
+ public:
+  QuantDSplitProofGenerator(Env& env) : EnvObj(env), d_index(userContext()) {}
+  virtual ~QuantDSplitProofGenerator() {}
+  /**
+   * Get proof for fact. This expects facts of the form
+   *    q = QuantDSplit::split(nm, q, n)
+   * We prove this by:
+   *    ------ QUANT_VAR_REORDERING ---------------------------- QUANT_DT_SPLIT
+   *    q = q'                      q' = QuantDSplit::split(nm, q', 0)
+   *    --------------------------------------------------------------- TRANS
+   *    q = QuantDSplit::split(nm, q, n)
+   *
+   * where the variables in q' is reordered from q such that the variable to
+   * split comes first.
+   */
+  std::shared_ptr<ProofNode> getProofFor(Node fact) override
+  {
+    CDProof cdp(d_env);
+    // find the index of the variable that was split for this lemma
+    context::CDHashMap<Node, size_t>::iterator it = d_index.find(fact);
+    if (it == d_index.end())
+    {
+      Assert(false) << "QuantDSplitProofGenerator failed to get proof";
+      return nullptr;
+    }
+    Assert(fact.getKind() == Kind::EQUAL && fact[0].getKind() == Kind::FORALL);
+    Node q = fact[0];
+    std::vector<Node> transEq;
+    if (it->second != 0)
+    {
+      // must reorder variables
+      std::vector<Node> newVars;
+      newVars.push_back(q[0][it->second]);
+      for (size_t i = 0, nvars = q[0].getNumChildren(); i < nvars; i++)
+      {
+        if (i != it->second)
+        {
+          newVars.emplace_back(q[0][i]);
+        }
+      }
+      std::vector<Node> qc(q.begin(), q.end());
+      NodeManager* nm = nodeManager();
+      qc[0] = nm->mkNode(Kind::BOUND_VAR_LIST, newVars);
+      Node qn = nm->mkNode(Kind::FORALL, qc);
+      Node eqq = q.eqNode(qn);
+      cdp.addStep(eqq, ProofRule::QUANT_VAR_REORDERING, {}, {eqq});
+      transEq.emplace_back(eqq);
+      q = qn;
+    }
+    Node eqq2 = q.eqNode(fact[1]);
+    cdp.addTheoryRewriteStep(eqq2, ProofRewriteRule::QUANT_DT_SPLIT);
+    if (!transEq.empty())
+    {
+      transEq.emplace_back(eqq2);
+      cdp.addStep(fact, ProofRule::TRANS, transEq, {});
+    }
+    return cdp.getProofFor(fact);
+  }
+  /** identify */
+  std::string identify() const override { return "QuantDSplitProofGenerator"; }
+  /**
+   * Notify that the given lemma used the given variable index to split. We
+   * store this in d_index and use it to guide proof reconstruction above.
+   */
+  void notifyLemma(const Node& lem, size_t index) { d_index[lem] = index; }
+
+ private:
+  /** Mapping from lemmas to their notified index */
+  context::CDHashMap<Node, size_t> d_index;
+};
+
+/**
+ * Attributes used for constructing bound variables in a canonical way. These
+ * are attributes that map to bound variable, introduced for the following
+ * purpose:
+ * - QDSplitVarAttribute: cached on (q, v, i) where QuantDSplit::split is called
+ * to split the variable v of q. We introduce bound variables, where the i^th
+ * variable created in that method is cached based on i.
+ */
+struct QDSplitVarAttributeId
+{
+};
+using QDSplitVarAttribute = expr::Attribute<QDSplitVarAttributeId, Node>;
+
 QuantDSplit::QuantDSplit(Env& env,
                          QuantifiersState& qs,
                          QuantifiersInferenceManager& qim,
@@ -35,7 +129,9 @@ QuantDSplit::QuantDSplit(Env& env,
                          TermRegistry& tr)
     : QuantifiersModule(env, qs, qim, qr, tr),
       d_quant_to_reduce(userContext()),
-      d_added_split(userContext())
+      d_added_split(userContext()),
+      d_pfgen(options().smt.produceProofs ? new QuantDSplitProofGenerator(d_env)
+                                          : nullptr)
 {
 }
 
@@ -58,7 +154,8 @@ void QuantDSplit::checkOwnership(Node q)
   bool doSplit = false;
   QuantifiersBoundInference& qbi = d_qreg.getQuantifiersBoundInference();
   Trace("quant-dsplit-debug") << "Check split quantified formula : " << q << std::endl;
-  for( unsigned i=0; i<q[0].getNumChildren(); i++ ){
+  for (size_t i = 0, nvars = q[0].getNumChildren(); i < nvars; i++)
+  {
     TypeNode tn = q[0][i].getType();
     if( tn.isDatatype() ){
       bool isFinite = d_env.isFiniteType(tn);
@@ -143,9 +240,7 @@ void QuantDSplit::check(Theory::Effort e, QEffort quant_e)
     return;
   }
   Trace("quant-dsplit") << "QuantDSplit::check" << std::endl;
-  NodeManager* nm = nodeManager();
   FirstOrderModel* m = d_treg.getModel();
-  std::vector<Node> lemmas;
   for (NodeIntMap::iterator it = d_quant_to_reduce.begin();
        it != d_quant_to_reduce.end();
        ++it)
@@ -159,66 +254,75 @@ void QuantDSplit::check(Theory::Effort e, QEffort quant_e)
     if (m->isQuantifierAsserted(q) && m->isQuantifierActive(q))
     {
       d_added_split.insert(q);
-      std::vector<Node> bvs;
-      for (unsigned i = 0, nvars = q[0].getNumChildren(); i < nvars; i++)
+      Node qsplit = split(nodeManager(), q, it->second);
+      Node lem = q.eqNode(qsplit);
+      // must remember the variable index if proofs are enabled
+      if (d_pfgen != nullptr)
       {
-        if (static_cast<int>(i) != it->second)
-        {
-          bvs.push_back(q[0][i]);
-        }
+        d_pfgen->notifyLemma(lem, it->second);
       }
-      std::vector<Node> disj;
-      disj.push_back(q.negate());
-      TNode svar = q[0][it->second];
-      TypeNode tn = svar.getType();
-      Assert(tn.isDatatype());
-      std::vector<Node> cons;
-      const DType& dt = tn.getDType();
-      for (unsigned j = 0, ncons = dt.getNumConstructors(); j < ncons; j++)
-      {
-        std::vector<Node> vars;
-        TypeNode dtjtn = dt[j].getInstantiatedConstructorType(tn);
-        Assert(dtjtn.getNumChildren() == dt[j].getNumArgs() + 1);
-        for (unsigned k = 0, nargs = dt[j].getNumArgs(); k < nargs; k++)
-        {
-          TypeNode tns = dtjtn[k];
-          Node v = nm->mkBoundVar(tns);
-          vars.push_back(v);
-        }
-        std::vector<Node> bvs_cmb;
-        bvs_cmb.insert(bvs_cmb.end(), bvs.begin(), bvs.end());
-        bvs_cmb.insert(bvs_cmb.end(), vars.begin(), vars.end());
-        Node c = datatypes::utils::mkApplyCons(tn, dt, j, vars);
-        TNode ct = c;
-        Node body = q[1].substitute(svar, ct);
-        if (!bvs_cmb.empty())
-        {
-          Node bvl = nm->mkNode(Kind::BOUND_VAR_LIST, bvs_cmb);
-          std::vector<Node> children;
-          children.push_back(bvl);
-          children.push_back(body);
-          if (q.getNumChildren() == 3)
-          {
-            Node ipls = q[2].substitute(svar, ct);
-            children.push_back(ipls);
-          }
-          body = nm->mkNode(Kind::FORALL, children);
-        }
-        cons.push_back(body);
-      }
-      Node conc = cons.size() == 1 ? cons[0] : nm->mkNode(Kind::AND, cons);
-      disj.push_back(conc);
-      lemmas.push_back(disj.size() == 1 ? disj[0] : nm->mkNode(Kind::OR, disj));
+      Trace("quant-dsplit") << "QuantDSplit lemma : " << lem << std::endl;
+      d_qim.addPendingLemma(lem,
+                            InferenceId::QUANTIFIERS_DSPLIT,
+                            LemmaProperty::NONE,
+                            d_pfgen.get());
     }
   }
+  Trace("quant-dsplit") << "QuantDSplit::check finished" << std::endl;
+}
 
-  // add lemmas to quantifiers engine
-  for (const Node& lem : lemmas)
+Node QuantDSplit::split(NodeManager* nm, const Node& q, size_t index)
+{
+  std::vector<Node> bvs;
+  for (size_t i = 0, nvars = q[0].getNumChildren(); i < nvars; i++)
   {
-    Trace("quant-dsplit") << "QuantDSplit lemma : " << lem << std::endl;
-    d_qim.addPendingLemma(lem, InferenceId::QUANTIFIERS_DSPLIT);
+    if (i != index)
+    {
+      bvs.push_back(q[0][i]);
+    }
   }
-  Trace("quant-dsplit") << "QuantDSplit::check finished" << std::endl;
+  TNode svar = q[0][index];
+  TypeNode tn = svar.getType();
+  Assert(tn.isDatatype());
+  std::vector<Node> cons;
+  const DType& dt = tn.getDType();
+  BoundVarManager* bvm = nm->getBoundVarManager();
+  size_t varCount = 0;
+  for (size_t j = 0, ncons = dt.getNumConstructors(); j < ncons; j++)
+  {
+    std::vector<Node> vars;
+    TypeNode dtjtn = dt[j].getInstantiatedConstructorType(tn);
+    Assert(dtjtn.getNumChildren() == dt[j].getNumArgs() + 1);
+    for (size_t k = 0, nargs = dt[j].getNumArgs(); k < nargs; k++)
+    {
+      TypeNode tns = dtjtn[k];
+      Node cacheVal = bvm->getCacheValue(q[1], q[0][index], varCount);
+      varCount++;
+      Node v = bvm->mkBoundVar<QDSplitVarAttribute>(cacheVal, tns);
+      vars.push_back(v);
+    }
+    std::vector<Node> bvs_cmb;
+    bvs_cmb.insert(bvs_cmb.end(), bvs.begin(), bvs.end());
+    bvs_cmb.insert(bvs_cmb.end(), vars.begin(), vars.end());
+    Node c = datatypes::utils::mkApplyCons(tn, dt, j, vars);
+    TNode ct = c;
+    Node body = q[1].substitute(svar, ct);
+    if (!bvs_cmb.empty())
+    {
+      Node bvl = nm->mkNode(Kind::BOUND_VAR_LIST, bvs_cmb);
+      std::vector<Node> children;
+      children.push_back(bvl);
+      children.push_back(body);
+      if (q.getNumChildren() == 3)
+      {
+        Node ipls = q[2].substitute(svar, ct);
+        children.push_back(ipls);
+      }
+      body = nm->mkNode(Kind::FORALL, children);
+    }
+    cons.push_back(body);
+  }
+  return nm->mkAnd(cons);
 }
 
 }  // namespace quantifiers
diff --git a/src/theory/quantifiers/quant_split.h b/src/theory/quantifiers/quant_split.h
index 818a97e03..8137124b3 100644
--- a/src/theory/quantifiers/quant_split.h
+++ b/src/theory/quantifiers/quant_split.h
@@ -30,6 +30,8 @@ class QuantifiersEngine;
 
 namespace quantifiers {
 
+class QuantDSplitProofGenerator;
+
 /** Quantifiers dynamic splitting
  *
  * This module identifies quantified formulas that should be "split", e.g.
@@ -50,7 +52,7 @@ namespace quantifiers {
  */
 class QuantDSplit : public QuantifiersModule {
   using NodeSet = context::CDHashSet<Node>;
-  using NodeIntMap = context::CDHashMap<Node, int>;
+  using NodeIntMap = context::CDHashMap<Node, size_t>;
 
  public:
   QuantDSplit(Env& env,
@@ -68,12 +70,20 @@ class QuantDSplit : public QuantifiersModule {
   bool checkCompleteFor(Node q) override;
   /** Identify this module (for debugging, dynamic configuration, etc..) */
   std::string identify() const override { return "QuantDSplit"; }
+  /**
+   * Split the index^th variable of quantified formula q based on its possible
+   * constructors. This variable should have datatype type. This method is
+   * used for ProofRewriteRule::QUANT_DT_SPLIT.
+   */
+  static Node split(NodeManager* nm, const Node& q, size_t index);
 
  private:
   /** list of relevant quantifiers asserted in the current context */
   NodeIntMap d_quant_to_reduce;
   /** whether we have instantiated quantified formulas */
   NodeSet d_added_split;
+  /** Proof generator */
+  std::shared_ptr<QuantDSplitProofGenerator> d_pfgen;
 };
 
 }
diff --git a/src/theory/quantifiers/quantifiers_rewriter.cpp b/src/theory/quantifiers/quantifiers_rewriter.cpp
index 377511735..7bd7ca4e3 100644
--- a/src/theory/quantifiers/quantifiers_rewriter.cpp
+++ b/src/theory/quantifiers/quantifiers_rewriter.cpp
@@ -29,6 +29,7 @@
 #include "theory/quantifiers/bv_inverter.h"
 #include "theory/quantifiers/ematching/trigger.h"
 #include "theory/quantifiers/extended_rewrite.h"
+#include "theory/quantifiers/quant_split.h"
 #include "theory/quantifiers/quantifiers_attributes.h"
 #include "theory/quantifiers/skolemize.h"
 #include "theory/quantifiers/term_database.h"
@@ -108,6 +109,8 @@ QuantifiersRewriter::QuantifiersRewriter(NodeManager* nm,
                            TheoryRewriteCtx::PRE_DSL);
   registerProofRewriteRule(ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV,
                            TheoryRewriteCtx::PRE_DSL);
+  // note ProofRewriteRule::QUANT_DT_SPLIT is done by a module dynamically with
+  // manual proof generation thus not registered here.
   registerProofRewriteRule(ProofRewriteRule::MACRO_QUANT_VAR_ELIM_EQ,
                            TheoryRewriteCtx::PRE_DSL);
   registerProofRewriteRule(ProofRewriteRule::MACRO_QUANT_VAR_ELIM_INEQ,
@@ -260,6 +263,16 @@ Node QuantifiersRewriter::rewriteViaRule(ProofRewriteRule id, const Node& n)
       return ret;
     }
     break;
+    case ProofRewriteRule::QUANT_DT_SPLIT:
+    {
+      // always runs split utility on the first variable
+      if (n.getKind() != Kind::FORALL || !n[0][0].getType().isDatatype())
+      {
+        return Node::null();
+      }
+      return QuantDSplit::split(nodeManager(), n, 0);
+    }
+    break;
     case ProofRewriteRule::MACRO_QUANT_VAR_ELIM_EQ:
     case ProofRewriteRule::QUANT_VAR_ELIM_EQ:
     case ProofRewriteRule::MACRO_QUANT_VAR_ELIM_INEQ:
-- 
2.47.1

