From 9779842ac8d0164d8c38a3d0b9a811cedea7d66a Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Tue, 5 Nov 2024 13:40:27 -0600
Subject: [PATCH 157/312] Fixes and changes to BV overflow elimination rules
 (#11316)

Fixes `bv-uaddo-eliminate` which had an off by one error. Also refactors
`bv-ssubo-eliminate` and `bv-saddo-eliminate` to match the expected form
implemented by the rewriter.

Also makes a slight change to the preprocessing converter to RARE to
ensure ACI_NORM is only applied to STRING_CONCAT terms. Applying it to
AND/OR was making it difficult to apply `bv-ssubo-eliminate` and
`bv-saddo-eliminate` due to reordering AND/OR.
---
 proofs/eo/cpc/rules/Rewrites.eo          | 14 +++++++-------
 src/rewriter/rewrite_db_term_process.cpp | 13 ++++++++++---
 src/theory/bv/rewrites                   |  4 ++--
 src/theory/bv/rewrites-elimination       | 18 +++++++++---------
 4 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/proofs/eo/cpc/rules/Rewrites.eo b/proofs/eo/cpc/rules/Rewrites.eo
index f30a1a19b..063798f0c 100644
--- a/proofs/eo/cpc/rules/Rewrites.eo
+++ b/proofs/eo/cpc/rules/Rewrites.eo
@@ -541,7 +541,7 @@
 (declare-rule bv-ult-add-one ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (c1 (BitVec @n2)) (w1 Int))
   :premises ((= c1 (@bv 1 w1)) (= w1 (@bvsize y1)))
   :args (x1 y1 c1 w1)
-  :conclusion (= (bvult x1 (bvadd y1 c1)) (and (not (bvult y1 x1)) (not (= y1 (bvnot (@bv 0 w1))))))
+  :conclusion (= (bvult x1 (bvadd y1 c1)) (and (not (= y1 (bvnot (@bv 0 w1)))) (not (bvult y1 x1))))
 )
 (declare-rule bv-concat-to-mult ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (m1 Int) (n1 Int) (w1 Int))
   :premises ((= (+ 1 i1 m1) (@bvsize x1)) (= n1 0) (= w1 (@bvsize x1)))
@@ -757,15 +757,15 @@
   :args (x1 n1 wm1)
   :conclusion (= (sign_extend n1 x1) (concat (repeat n1 (extract wm1 wm1 x1)) x1))
 )
-(declare-rule bv-uaddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (wm1 Int))
-  :premises ((= wm1 (- (@bvsize x1) 1)))
-  :args (x1 y1 wm1)
-  :conclusion (= (bvuaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (= (extract wm1 wm1 (bvadd (concat _let_1 x1) (concat _let_1 y1))) (@bv 1 1))))
+(declare-rule bv-uaddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 y1 w1)
+  :conclusion (= (bvuaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (= (extract w1 w1 (bvadd (concat _let_1 x1) (concat _let_1 y1))) (@bv 1 1))))
 )
 (declare-rule bv-saddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (wm1 Int))
   :premises ((= wm1 (- (@bvsize x1) 1)))
   :args (x1 y1 wm1)
-  :conclusion (= (bvsaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (eo::define ((_let_2 (extract wm1 wm1 (bvadd x1 y1)))) (eo::define ((_let_3 (@bv 1 1))) (eo::define ((_let_4 (extract wm1 wm1 y1))) (eo::define ((_let_5 (extract wm1 wm1 x1))) (or (and (and (= _let_5 _let_1) (= _let_4 _let_1)) (= _let_2 _let_3)) (and (and (= _let_5 _let_3) (= _let_4 _let_3)) (= _let_2 _let_1)))))))))
+  :conclusion (= (bvsaddo x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (extract wm1 wm1 (bvadd x1 y1)))) (eo::define ((_let_3 (@bv 0 1))) (eo::define ((_let_4 (extract wm1 wm1 y1))) (eo::define ((_let_5 (extract wm1 wm1 x1))) (or (and (and (= _let_5 _let_1) (= _let_4 _let_1)) (= _let_2 _let_3)) (and (and (= _let_5 _let_3) (= _let_4 _let_3)) (= _let_2 _let_1)))))))))
 )
 (declare-rule bv-sdivo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (w1 Int) (wm1 Int))
   :premises ((= wm1 (- (@bvsize x1) 1)) (= w1 (@bvsize y1)))
@@ -800,7 +800,7 @@
 (declare-rule bv-ssubo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (nm1 Int))
   :premises ((= nm1 (- (@bvsize x1) 1)))
   :args (x1 y1 nm1)
-  :conclusion (= (bvssubo x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (= (extract nm1 nm1 (bvsub x1 y1)) _let_1))) (eo::define ((_let_3 (= (extract nm1 nm1 y1) _let_1))) (eo::define ((_let_4 (= (extract nm1 nm1 x1) _let_1))) (or (and _let_4 (not _let_3) (not _let_2)) (and (not _let_4) _let_3 _let_2)))))))
+  :conclusion (= (bvssubo x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (extract nm1 nm1 (bvsub x1 y1)))) (eo::define ((_let_3 (extract nm1 nm1 y1))) (eo::define ((_let_4 (@bv 0 1))) (eo::define ((_let_5 (extract nm1 nm1 x1))) (or (and (and (= _let_5 _let_1) (= _let_3 _let_4)) (= _let_2 _let_4)) (and (and (= _let_5 _let_4) (= _let_3 _let_1)) (= _let_2 _let_1)))))))))
 )
 (declare-rule bv-ite-equal-children ((@n0 Int) (c1 (_ BitVec 1)) (x1 (BitVec @n0)))
   :args (c1 x1)
diff --git a/src/rewriter/rewrite_db_term_process.cpp b/src/rewriter/rewrite_db_term_process.cpp
index 70ac9c97e..a1ea54eda 100644
--- a/src/rewriter/rewrite_db_term_process.cpp
+++ b/src/rewriter/rewrite_db_term_process.cpp
@@ -116,9 +116,16 @@ Node RewriteDbNodeConverter::postConvert(Node n)
     recordProofStep(n, ret, ProofRule::ENCODE_EQ_INTRO);
     return ret;
   }
-  Node nacc = expr::getACINormalForm(n);
-  recordProofStep(n, nacc, ProofRule::ACI_NORM);
-  return nacc;
+  // since string constants are converted to concatenation terms, we ensure
+  // these are flattened using ACI_NORM. This ensures (str.++ "AB" x) is
+  // handled as (str.++ "A" "B" x), not (str.++ (str.++ "A" "B") x).
+  if (k==Kind::STRING_CONCAT)
+  {
+    Node nacc = expr::getACINormalForm(n);
+    recordProofStep(n, nacc, ProofRule::ACI_NORM);
+    return nacc;
+  }
+  return n;
 }
 
 bool RewriteDbNodeConverter::shouldTraverse(Node n)
diff --git a/src/theory/bv/rewrites b/src/theory/bv/rewrites
index ccca3b9ee..bd8b8b6b9 100644
--- a/src/theory/bv/rewrites
+++ b/src/theory/bv/rewrites
@@ -179,8 +179,8 @@
   (and (= c1 (@bv 1 w)) (= w (@bvsize y)))
   (bvult x (bvadd y c1))
   (and
-    (not (bvult y x))
-    (not (= y (bvnot (@bv 0 w))))))
+    (not (= y (bvnot (@bv 0 w))))
+    (not (bvult y x))))
 (define-cond-rule bv-concat-to-mult
   ((x ?BitVec) (i Int) (m Int) (n0 Int) (w Int))
   (and (= (+ 1 i m) (@bvsize x)) (= n0 0) (= w (@bvsize x)))
diff --git a/src/theory/bv/rewrites-elimination b/src/theory/bv/rewrites-elimination
index acab4d543..f4cb82f49 100644
--- a/src/theory/bv/rewrites-elimination
+++ b/src/theory/bv/rewrites-elimination
@@ -132,10 +132,10 @@
   (concat (repeat n (extract wm1 wm1 x)) x))
 
 (define-cond-rule bv-uaddo-eliminate
-  ((x ?BitVec) (y ?BitVec) (wm1 Int))
-  (= wm1 (- (@bvsize x) 1))
+  ((x ?BitVec) (y ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvuaddo x y)
-  (= (extract wm1 wm1
+  (= (extract w w
       (bvadd (concat (@bv 0 1) x) (concat (@bv 0 1) y)))
     (@bv 1 1)
   ))
@@ -149,8 +149,8 @@
   (= wm1 (- (@bvsize x) 1))
   (bvsaddo x y)
   (or
-    (and (and (= xS (@bv 0 1)) (= yS (@bv 0 1))) (= aS (@bv 1 1)))
     (and (and (= xS (@bv 1 1)) (= yS (@bv 1 1))) (= aS (@bv 0 1)))
+    (and (and (= xS (@bv 0 1)) (= yS (@bv 0 1))) (= aS (@bv 1 1)))
   ))
 (define-cond-rule bv-sdivo-eliminate
   ((x ?BitVec) (y ?BitVec) (w Int) (wm1 Int))
@@ -241,13 +241,13 @@
   ((x ?BitVec) (y ?BitVec) (nm1 Int))
   (def
     (n (@bvsize x))
-    (xLt0 (= (extract nm1 nm1 x) (@bv 1 1)))
-    (yLt0 (= (extract nm1 nm1 y) (@bv 1 1)))
+    (xe (extract nm1 nm1 x))
+    (ye (extract nm1 nm1 y))
     (s (bvsub x y))
-    (sLt0 (= (extract nm1 nm1 s) (@bv 1 1)))
+    (se (extract nm1 nm1 s))
   )
   (= nm1 (- n 1))
   (bvssubo x y)
   (or
-    (and xLt0 (not yLt0) (not sLt0))
-    (and (not xLt0) yLt0 sLt0)))
+    (and (and (= xe (@bv 1 1)) (= ye (@bv 0 1))) (= se (@bv 0 1)))
+    (and (and (= xe (@bv 0 1)) (= ye (@bv 1 1))) (= se (@bv 1 1)))))
-- 
2.47.1

