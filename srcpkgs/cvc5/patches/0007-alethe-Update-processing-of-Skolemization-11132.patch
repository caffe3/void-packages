From 7b46e032bb094e11efe8ce8696a1b18dd202bb41 Mon Sep 17 00:00:00 2001
From: Haniel Barbosa <hanielbbarbosa@gmail.com>
Date: Fri, 9 Aug 2024 15:42:27 -0300
Subject: [PATCH 007/312] [alethe] Update processing of Skolemization (#11132)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Co-authored-by: Aina Niemetz <aina.niemetz@gmail.com>
Co-authored-by: Mathias Preiner <mathias.preiner@gmail.com>
Co-authored-by: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Co-authored-by: Alex Ozdemir <aozdemir@hmc.edu>
Co-authored-by: Daniel Larraz <daniel-larraz@users.noreply.github.com>
Co-authored-by: Hans-JÃ¶rg <hansjoergschurr@users.noreply.github.com>
---
 src/proof/alethe/alethe_post_processor.cpp | 198 +++++++++------------
 1 file changed, 82 insertions(+), 116 deletions(-)

diff --git a/src/proof/alethe/alethe_post_processor.cpp b/src/proof/alethe/alethe_post_processor.cpp
index aa18899a4..0f24ae344 100644
--- a/src/proof/alethe/alethe_post_processor.cpp
+++ b/src/proof/alethe/alethe_post_processor.cpp
@@ -1341,136 +1341,102 @@ bool AletheProofPostprocessCallback::update(Node res,
     // See proof_rule.h for documentation on the SKOLEMIZE rule. This
     // comment uses variable names as introduced there.
     //
-    // Either a positive existential or a negative forall is skolemized. First
-    // step is to build the Alethe skolemization step which introduces a valid
-    // equality:
-    //
-    //                      ---------------- REFL
-    //                       (= F F*sigma')
-    //  ----------------------------------------------- ANCHOR_SKO_EX, sigma_n
-    //          (= (exists ((xn Tn)) F) F*sigma')
-    // -----------------------------------------------
-    //                       ...
-    //  ----------------------------------------------- ANCHOR_SKO_EX, sigma_2
-    //   (= (exists ((x2 T1) ... (xn Tn)) F) F*sigma')
-    //  ----------------------------------------------- ANCHOR_SKO_EX, sigma_1
-    //   (= (exists ((x1 T1) ... (xn Tn)) F) F*sigma')
-    //
-    // where sigma' is the cumulative substitution built from sigma1...sigma_n,
-    // and each sigma_i replaces xi by the choice term (epsilon ((xi Ti))
-    // (exists ((xi+1 Ti+1) ... (xn+1 Tn+1)) F)).
-    //
-    // Then, we apply the equivalence elimination reasoning to obtain F*sigma
-    // from the premise:
-    //
-    //  ---------------- EQUIV_POS2
-    //     VP1              (= (exists (...) F) F*sigma')       (exists (...) F)
-    //  ------------------------------------------------------------- RESOLUTION
-    //                           F*sigma'
+    // In cvc5 this is applied solely to terms (not (forall (...)  F)),
+    // concluding (not F*sigma'), where sigma' is the cumulative substitution
+    // built from sigma1...sigma_n, and each sigma_i replaces xi by the choice
+    // term (epsilon ((xi Ti)) (forall ((xi+1 Ti+1) ... (xn+1 Tn+1)) (not
+    // F))). The resulting Alethe Skolemization step is:
+    //
+    //            ---------------- refl
+    //             (= F F*sigma')
+    //  ------------------------- anchor_sko_forall, sigma_1, ..., sigma_n
+    //  (= (forall ((x1 T1) ... (xn Tn)) F) F*sigma')
+    // ----------------------------------------------- cong
+    //  (= (not (forall ((x1 T1) ... (xn Tn)) F)) (not F*sigma'))
+    //
+    // Then, we eliminate the equality to obtain (not F*sigma) from the premise:
+    //
+    //  ---- equiv_pos2
+    //  VP1   (= (not (forall (...) F)) (not F*sigma'))   (not (forall (...) F))
+    //  ------------------------------------------------------------- resolution
+    //                           (not F*sigma')
     //
     // VP1 :
-    //  (cl (not (= (exists (...) F) F*sigma')) (not (exists (...) F)) F*sigma')
+    //  (cl
+    //    (not (= (not (forall (...) F)) (not F*sigma')))
+    //    (not (not (forall (...) F)))
+    //    (not F*sigma'))
     //
-    // Note that F*sigma' is equivalent to F*sigma once its skolem terms are
+    // Note that F*sigma' is equivalent to F*sigma once its Skolem terms are
     // lifted to choice terms by the node converter.
-    //
-    // The case for negative forall is analagous except the rules are
-    // ANCHOR_SKO_FORALL and the one concluding the desired equivalence is
-    // followed by a congruence step to wrap the equality terms under a
-    // negation, i.e., (not ...).
     case ProofRule::SKOLEMIZE:
     {
-      AletheRule skoRule;
-      bool isExists;
-      Node quant, skolemized;
-      Kind quantKind;
-      if (children[0].getKind() == Kind::EXISTS)
-      {
-        isExists = true;
-        skoRule = AletheRule::ANCHOR_SKO_EX;
-        quant = children[0];
-        skolemized = res;
-        quantKind = Kind::EXISTS;
-      }
-      else
-      {
-        isExists = false;
-        skoRule = AletheRule::ANCHOR_SKO_FORALL;
-        quant = children[0][0];
-        skolemized = res[0];
-        quantKind = Kind::FORALL;
-      }
+      bool success = true;
+      Node quant = children[0][0], skolemized = res[0];
+      Assert(children[0].getKind() == Kind::NOT
+             && children[0][0].getKind() == Kind::FORALL);
+      Node eq = quant[1].eqNode(skolemized);
       // add rfl step for final replacement
-      Node curPremise = nm->mkNode(
-          Kind::SEXPR, d_cl, d_anc.convert(quant[1].eqNode(skolemized)));
-      addAletheStep(AletheRule::REFL, curPremise, curPremise, {}, {}, *cdp);
+      Node premise = nm->mkNode(Kind::SEXPR, d_cl, eq);
+      success &=
+          addAletheStep(AletheRule::REFL, premise, premise, {}, {}, *cdp);
       std::vector<Node> bVars{quant[0].begin(), quant[0].end()};
-      for (size_t size = quant[0].getNumChildren(), i = size; i > 0; --i)
+      std::vector<Node> skoSubstitutions;
+      SkolemManager* sm = nm->getSkolemManager();
+      const std::map<Node, Node>& skolemDefs = d_anc.getSkolemDefinitions();
+      for (size_t i = 0, size = quant[0].getNumChildren(); i < size; ++i)
       {
-        // build i-th anchor step, whose argument will be the i-th variable
-        // mapped to a choice term for that variable over the quantifier over
-        // i+1-th to n-th variable over the quant body.
-        Node ithBVars = nm->mkNode(
-            Kind::BOUND_VAR_LIST,
-            std::vector<Node>{bVars.begin() + (size - i), bVars.end()});
-        // What we are currently skolemizing is the quantifier (i-1)-th
-        // variable. So we must take the suffix of variables from that one (note
-        // that when i == 1 the suffix is all the variables)
-        Node curSkolemizing =
-            i == 1 ? quant
-                   : nm->mkNode(quantKind,
-                                nm->mkNode(Kind::BOUND_VAR_LIST, ithBVars),
-                                quant[1]);
-        // The choice term is for the (i-1)-th variable defined as the
-        // quantifier with the suffix from the i-th variable. This is the same
-        // as the term we skolemized in the previous iteration. Note that for
-        // the last variable in the suffix this is what was used in the REFL
-        // step. In either case, this is always the lhs of the equality in
-        // curPremise (under the cl). Remember that when doing SKO_FORALL the
-        // body of the choice is negated.
-        Node ithChoice = nm->mkNode(
-            Kind::WITNESS,
-            nm->mkNode(Kind::BOUND_VAR_LIST, quant[0][i - 1]),
-            isExists ? curPremise[1][0] : curPremise[1][0].notNode());
-        Node conclusion =
-            nm->mkNode(Kind::SEXPR,
-                       d_cl,
-                       d_anc.convert(curSkolemizing.eqNode(skolemized)));
-        addAletheStep(skoRule,
-                      conclusion,
-                      conclusion,
-                      {curPremise},
-                      {d_anc.convert(quant[0][i - 1].eqNode(ithChoice))},
-                      *cdp);
-        // update premise
-        curPremise = conclusion;
+        // Make the Skolem corresponding to this variable and retrieve its
+        // conversion from the node converter
+        std::vector<Node> cacheVals{quant, nm->mkConstInt(Rational(i))};
+        Node sk =
+            sm->mkSkolemFunction(SkolemId::QUANTIFIERS_SKOLEMIZE, cacheVals);
+        Assert(!sk.isNull());
+        if (options().proof.proofAletheDefineSkolems)
+        {
+          skoSubstitutions.push_back(quant[0][i].eqNode(sk));
+          continue;
+        }
+        auto it = skolemDefs.find(sk);
+        Assert(it != skolemDefs.end()) << sk << " " << skolemDefs;
+        skoSubstitutions.push_back(quant[0][i].eqNode(it->second));
       }
+      Assert(!d_anc.convert(quant.eqNode(skolemized)).isNull());
+      Node conclusion = nm->mkNode(
+          Kind::SEXPR, d_cl, d_anc.convert(quant.eqNode(skolemized)));
+      // add the sko step
+      success &= addAletheStep(AletheRule::ANCHOR_SKO_FORALL,
+                               conclusion,
+                               conclusion,
+                               {premise},
+                               skoSubstitutions,
+                               *cdp);
       // add congruence step with NOT for the forall case
-      if (!isExists)
-      {
-        Node conclusion = nm->mkNode(
-            Kind::SEXPR,
-            d_cl,
-            (curPremise[1][0].notNode()).eqNode(curPremise[1][1].notNode()));
-        addAletheStep(
-            AletheRule::CONG, conclusion, conclusion, {curPremise}, {}, *cdp);
-        curPremise = conclusion;
-      }
+      Node newConclusion = nm->mkNode(
+          Kind::SEXPR, d_cl, (quant.notNode()).eqNode(skolemized.notNode()));
+      success &= addAletheStep(AletheRule::CONG,
+                               newConclusion,
+                               newConclusion,
+                               {conclusion},
+                               {},
+                               *cdp);
+      conclusion = newConclusion;
       // now equality resolution reasoning
       Node vp1 = nm->mkNode(
           Kind::SEXPR,
-          {d_cl, curPremise[1].notNode(), children[0].notNode(), res});
-      addAletheStep(AletheRule::EQUIV_POS2, vp1, vp1, {}, {}, *cdp);
-      addAletheStep(
-          AletheRule::RESOLUTION,
-          res,
-          nm->mkNode(Kind::SEXPR, d_cl, res),
-          {vp1, curPremise, children[0]},
-          d_resPivots
-              ? std::vector<Node>{curPremise[1], d_false, children[0], d_false}
-              : std::vector<Node>(),
-          *cdp);
-      return true;
+          {d_cl, conclusion[1].notNode(), children[0].notNode(), res});
+      success &= addAletheStep(AletheRule::EQUIV_POS2, vp1, vp1, {}, {}, *cdp);
+      return success
+             && addAletheStep(AletheRule::RESOLUTION,
+                              res,
+                              nm->mkNode(Kind::SEXPR, d_cl, res),
+                              {vp1, conclusion, children[0]},
+                              d_resPivots ? std::vector<Node>{conclusion[1],
+                                                              d_false,
+                                                              children[0],
+                                                              d_false}
+                                          : std::vector<Node>(),
+                              *cdp);
     }
     // ======== Bitvector
     //
-- 
2.47.1

