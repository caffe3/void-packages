From 81afa7687a01a3057f5a4a517e65009cfcad368a Mon Sep 17 00:00:00 2001
From: Daniel Larraz <daniel-larraz@users.noreply.github.com>
Date: Thu, 19 Sep 2024 15:07:47 -0500
Subject: [PATCH 063/312] theory arrays rewriter: Refactor to not use
 NodeManager::currentNM() (#11213)

---
 src/theory/arrays/theory_arrays_rewriter.cpp | 34 +++++++++++---------
 src/theory/arrays/theory_arrays_rewriter.h   | 12 +++----
 src/theory/arrays/type_enumerator.cpp        |  2 +-
 src/theory/uf/function_const.cpp             |  2 +-
 4 files changed, 27 insertions(+), 23 deletions(-)

diff --git a/src/theory/arrays/theory_arrays_rewriter.cpp b/src/theory/arrays/theory_arrays_rewriter.cpp
index d7f39a62c..92a70c714 100644
--- a/src/theory/arrays/theory_arrays_rewriter.cpp
+++ b/src/theory/arrays/theory_arrays_rewriter.cpp
@@ -45,17 +45,21 @@ using ArrayConstantMostFrequentValueCountAttr =
 using ArrayConstantMostFrequentValueAttr =
     expr::Attribute<attr::ArrayConstantMostFrequentValueTag, Node>;
 
-Node getMostFrequentValue(TNode store) {
+Node getMostFrequentValue(TNode store)
+{
   return store.getAttribute(ArrayConstantMostFrequentValueAttr());
 }
-uint64_t getMostFrequentValueCount(TNode store) {
+uint64_t getMostFrequentValueCount(TNode store)
+{
   return store.getAttribute(ArrayConstantMostFrequentValueCountAttr());
 }
 
-void setMostFrequentValue(TNode store, TNode value) {
+void setMostFrequentValue(TNode store, TNode value)
+{
   return store.setAttribute(ArrayConstantMostFrequentValueAttr(), value);
 }
-void setMostFrequentValueCount(TNode store, uint64_t count) {
+void setMostFrequentValueCount(TNode store, uint64_t count)
+{
   return store.setAttribute(ArrayConstantMostFrequentValueCountAttr(), count);
 }
 
@@ -76,16 +80,16 @@ Node TheoryArraysRewriter::rewriteViaRule(ProofRewriteRule id, const Node& n)
     {
       if (n.getKind() == Kind::EQ_RANGE)
       {
-        return expandEqRange(n);
+        return expandEqRange(d_nm, n);
       }
-    break;
+      break;
     }
     default: break;
   }
   return Node::null();
 }
 
-Node TheoryArraysRewriter::normalizeConstant(TNode node)
+Node TheoryArraysRewriter::normalizeConstant(NodeManager* nm, TNode node)
 {
   if (node.isConst())
   {
@@ -96,18 +100,20 @@ Node TheoryArraysRewriter::normalizeConstant(TNode node)
   CardinalityClass tcc = tn.getCardinalityClass();
   if (tcc == CardinalityClass::FINITE || tcc == CardinalityClass::ONE)
   {
-    ret = normalizeConstant(node, tn.getCardinality());
+    ret = normalizeConstant(nm, node, tn.getCardinality());
   }
   else
   {
-    ret = normalizeConstant(node, Cardinality::INTEGERS);
+    ret = normalizeConstant(nm, node, Cardinality::INTEGERS);
   }
   Assert(ret.isConst()) << "Non-constant after normalization: " << ret;
   return ret;
 }
 
 // this function is called by printers when using the option "--model-u-dt-enum"
-Node TheoryArraysRewriter::normalizeConstant(TNode node, Cardinality indexCard)
+Node TheoryArraysRewriter::normalizeConstant(NodeManager* nm,
+                                             TNode node,
+                                             Cardinality indexCard)
 {
   TNode store = node[0];
   TNode index = node[1];
@@ -160,7 +166,6 @@ Node TheoryArraysRewriter::normalizeConstant(TNode node, Cardinality indexCard)
   Assert(store.getKind() == Kind::STORE_ALL);
   ArrayStoreAll storeAll = store.getConst<ArrayStoreAll>();
   Node defaultValue = storeAll.getValue();
-  NodeManager* nm = NodeManager::currentNM();
 
   // Check if we are writing to default value - if so the store
   // to index can be ignored
@@ -324,11 +329,10 @@ Node TheoryArraysRewriter::normalizeConstant(TNode node, Cardinality indexCard)
   return n;
 }
 
-Node TheoryArraysRewriter::expandEqRange(TNode node)
+Node TheoryArraysRewriter::expandEqRange(NodeManager* nm, TNode node)
 {
   Assert(node.getKind() == Kind::EQ_RANGE);
 
-  NodeManager* nm = NodeManager::currentNM();
   TNode a = node[0];
   TNode b = node[1];
   TNode i = node[2];
@@ -442,7 +446,7 @@ RewriteResponse TheoryArraysRewriter::postRewrite(TNode node)
       if (store.isConst() && index.isConst() && value.isConst())
       {
         // normalize constant
-        Node n = normalizeConstant(node);
+        Node n = normalizeConstant(d_nm, node);
         Assert(n.isConst());
         Trace("arrays-postrewrite")
             << "Arrays::postRewrite returning " << n << std::endl;
@@ -708,7 +712,7 @@ TrustNode TheoryArraysRewriter::expandDefinition(Node node)
 
   if (kind == Kind::EQ_RANGE)
   {
-    Node expandedEqRange = expandEqRange(node);
+    Node expandedEqRange = expandEqRange(d_nm, node);
     if (d_epg)
     {
       return d_epg->mkTrustNodeRewrite(
diff --git a/src/theory/arrays/theory_arrays_rewriter.h b/src/theory/arrays/theory_arrays_rewriter.h
index 2a7414c2f..4a172d095 100644
--- a/src/theory/arrays/theory_arrays_rewriter.h
+++ b/src/theory/arrays/theory_arrays_rewriter.h
@@ -41,9 +41,7 @@ uint64_t getMostFrequentValueCount(TNode store);
 void setMostFrequentValue(TNode store, TNode value);
 void setMostFrequentValueCount(TNode store, uint64_t count);
 
-static inline Node mkEqNode(Node a, Node b) {
-  return a.eqNode(b);
-}
+static inline Node mkEqNode(Node a, Node b) { return a.eqNode(b); }
 
 class TheoryArraysRewriter : public TheoryRewriter
 {
@@ -51,13 +49,15 @@ class TheoryArraysRewriter : public TheoryRewriter
   TheoryArraysRewriter(NodeManager* nm, Rewriter* r, EagerProofGenerator* epg);
 
   /** Normalize a constant whose index type has cardinality indexCard */
-  static Node normalizeConstant(TNode node, Cardinality indexCard);
+  static Node normalizeConstant(NodeManager* nm,
+                                TNode node,
+                                Cardinality indexCard);
 
   /* Expands the eqrange predicate (eqrange a b i j) to the quantified formula
    * (forall ((x T))
    *  (=> (and (<= i x) (<= x j)) (= (select a x) (select b x)))).
    */
-  static Node expandEqRange(TNode node);
+  static Node expandEqRange(NodeManager* nm, TNode node);
 
   RewriteResponse postRewrite(TNode node) override;
 
@@ -81,7 +81,7 @@ class TheoryArraysRewriter : public TheoryRewriter
    * This method should only be called on STORE chains whose AST is built
    * from constant terms only.
    */
-  static Node normalizeConstant(TNode node);
+  static Node normalizeConstant(NodeManager* nm, TNode node);
 
  private:
   /**
diff --git a/src/theory/arrays/type_enumerator.cpp b/src/theory/arrays/type_enumerator.cpp
index ea9b45f8b..12668f916 100644
--- a/src/theory/arrays/type_enumerator.cpp
+++ b/src/theory/arrays/type_enumerator.cpp
@@ -91,7 +91,7 @@ Node ArrayEnumerator::operator*()
     // since this utility requires all children of n to be constant, which
     // implies the first argument to STORE on the next iteration must be
     // normalized.
-    n = TheoryArraysRewriter::normalizeConstant(n);
+    n = TheoryArraysRewriter::normalizeConstant(d_nm, n);
   }
   Trace("array-type-enum") << "operator * returning: " << n << std::endl;
   return n;
diff --git a/src/theory/uf/function_const.cpp b/src/theory/uf/function_const.cpp
index 78177c070..59d282fd7 100644
--- a/src/theory/uf/function_const.cpp
+++ b/src/theory/uf/function_const.cpp
@@ -433,7 +433,7 @@ Node FunctionConst::getArrayRepresentationForLambdaRec(TNode n,
       curr = nm->mkNode(Kind::STORE, curr, conds[ii], vals[ii]);
       // normalize it using the array rewriter utility, which must be done at
       // each iteration of this loop
-      curr = arrays::TheoryArraysRewriter::normalizeConstant(curr);
+      curr = arrays::TheoryArraysRewriter::normalizeConstant(nm, curr);
     }
     Trace("builtin-rewrite-debug")
         << "...got array " << curr << " for " << n << std::endl;
-- 
2.47.1

