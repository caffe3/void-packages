From 334d81a2d115714d6470761cc56f34dd1b30936a Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Mon, 28 Oct 2024 14:10:08 -0500
Subject: [PATCH 142/312] Update BV RARE rules to not use evaluatable terms in
 index positions (#10904)

Updates bv rules to not use symbolic terms for indices.

There were two rules `bv-zero-extend-ult-const-1` and
`bv-zero-extend-ult-const-2` where it was not clear how to do this
elimination since a symbolic index of an extract term was introduced in
a condition. Moreover, these rules are not covered by regressions.

I am deleting them for now until we are able to (1) rewrite them in a
way that avoids the issue (2) add regressions that cover them.
---
 include/cvc5/cvc5_proof_rule.h                |   4 -
 proofs/eo/cpc/rules/Rewrites.eo               | 565 +++++++++---------
 proofs/eo/cpc/theories/BitVectors.eo          |  38 +-
 src/rewriter/README.md                        |  56 +-
 src/theory/bv/rewrites                        | 123 ++--
 src/theory/bv/rewrites-elimination            | 160 ++---
 src/theory/bv/rewrites-simplification         | 287 ++++-----
 src/theory/uf/rewrites                        |   4 +-
 test/regress/cli/CMakeLists.txt               |   2 +
 test/regress/cli/regress0/bv/dd_fuzz21.smt2   |   4 +
 .../regress/cli/regress0/proofs/eval-rhs.smt2 |   5 +
 11 files changed, 634 insertions(+), 614 deletions(-)
 create mode 100644 test/regress/cli/regress0/bv/dd_fuzz21.smt2
 create mode 100644 test/regress/cli/regress0/proofs/eval-rhs.smt2

diff --git a/include/cvc5/cvc5_proof_rule.h b/include/cvc5/cvc5_proof_rule.h
index 22f21df8c..94019e136 100644
--- a/include/cvc5/cvc5_proof_rule.h
+++ b/include/cvc5/cvc5_proof_rule.h
@@ -3266,10 +3266,6 @@ enum ENUM(ProofRewriteRule)
   EVALUE(BV_ZERO_EXTEND_EQ_CONST_1),
   /** Auto-generated from RARE rule bv-zero-extend-eq-const-2 */
   EVALUE(BV_ZERO_EXTEND_EQ_CONST_2),
-  /** Auto-generated from RARE rule bv-zero-extend-ult-const-1 */
-  EVALUE(BV_ZERO_EXTEND_ULT_CONST_1),
-  /** Auto-generated from RARE rule bv-zero-extend-ult-const-2 */
-  EVALUE(BV_ZERO_EXTEND_ULT_CONST_2),
   /** Auto-generated from RARE rule bv-sign-extend-ult-const-1 */
   EVALUE(BV_SIGN_EXTEND_ULT_CONST_1),
   /** Auto-generated from RARE rule bv-sign-extend-ult-const-2 */
diff --git a/proofs/eo/cpc/rules/Rewrites.eo b/proofs/eo/cpc/rules/Rewrites.eo
index 5acdbc5d6..91d92f8c6 100644
--- a/proofs/eo/cpc/rules/Rewrites.eo
+++ b/proofs/eo/cpc/rules/Rewrites.eo
@@ -399,9 +399,10 @@
   :args (xs1 s1 ys1 i1 j1 j2 k1)
   :conclusion (= (concat xs1 (extract k1 j2 s1) (extract j1 i1 s1) ys1) ($singleton_elim (concat xs1 (extract k1 i1 s1) ys1)))
 )
-(declare-rule bv-extract-extract ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int) (k1 Int) (l1 Int))
-  :args (x1 i1 j1 k1 l1)
-  :conclusion (= (extract l1 k1 (extract j1 i1 x1)) (extract (+ i1 l1) (+ i1 k1) x1))
+(declare-rule bv-extract-extract ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int) (k1 Int) (l1 Int) (ll1 Int) (kk1 Int))
+  :premises ((= ll1 (+ i1 l1)) (= kk1 (+ i1 k1)))
+  :args (x1 i1 j1 k1 l1 ll1 kk1)
+  :conclusion (= (extract l1 k1 (extract j1 i1 x1)) (extract ll1 kk1 x1))
 )
 (declare-rule bv-extract-whole ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
   :premises ((= (>= n1 (- (@bvsize x1) 1)) true))
@@ -413,15 +414,15 @@
   :args (x1 xs1 y1 i1 j1)
   :conclusion (= (extract j1 i1 (concat xs1 y1 x1)) (extract j1 i1 x1))
 )
-(declare-rule bv-extract-concat-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (xs1 (BitVec @n1) :list) (y1 (BitVec @n2)) (i1 Int) (j1 Int))
-  :premises ((= (< i1 (@bvsize x1)) true) (= (>= j1 (@bvsize x1)) true))
-  :args (x1 xs1 y1 i1 j1)
-  :conclusion (= (extract j1 i1 (concat xs1 y1 x1)) (eo::define ((_let_1 (@bvsize x1))) (concat (extract (- j1 _let_1) 0 ($singleton_elim (concat xs1 y1))) (extract (- _let_1 1) i1 x1))))
+(declare-rule bv-extract-concat-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (xs1 (BitVec @n1) :list) (y1 (BitVec @n2)) (i1 Int) (j1 Int) (u1 Int) (u2 Int))
+  :premises ((= (< i1 (@bvsize x1)) true) (= (>= j1 (@bvsize x1)) true) (= u1 (- j1 (@bvsize x1))) (= u2 (- (@bvsize x1) 1)))
+  :args (x1 xs1 y1 i1 j1 u1 u2)
+  :conclusion (= (extract j1 i1 (concat xs1 y1 x1)) (concat (extract u1 0 ($singleton_elim (concat xs1 y1))) (extract u2 i1 x1)))
 )
-(declare-rule bv-extract-concat-3 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (xs1 (BitVec @n2) :list) (i1 Int) (j1 Int))
-  :premises ((= (>= i1 (@bvsize x1)) true))
-  :args (x1 y1 xs1 i1 j1)
-  :conclusion (= (extract j1 i1 (concat xs1 y1 x1)) (eo::define ((_let_1 (@bvsize x1))) (extract (- j1 _let_1) (- i1 _let_1) ($singleton_elim (concat xs1 y1)))))
+(declare-rule bv-extract-concat-3 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (xs1 (BitVec @n2) :list) (i1 Int) (j1 Int) (u1 Int) (l1 Int))
+  :premises ((= (>= i1 (@bvsize x1)) true) (= u1 (- j1 (@bvsize x1))) (= l1 (- i1 (@bvsize x1))))
+  :args (x1 y1 xs1 i1 j1 u1 l1)
+  :conclusion (= (extract j1 i1 (concat xs1 y1 x1)) (extract u1 l1 ($singleton_elim (concat xs1 y1))))
 )
 (declare-rule bv-extract-concat-4 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (xs1 (BitVec @n2) :list) (i1 Int) (j1 Int))
   :premises ((= (< j1 (- (@bvsize (concat x1 xs1 y1)) (@bvsize x1))) true))
@@ -449,15 +450,15 @@
   :args (x1 low1 high1 k1)
   :conclusion (= (extract high1 low1 (sign_extend k1 x1)) (extract high1 low1 x1))
 )
-(declare-rule bv-extract-sign-extend-2 ((@n0 Int) (x1 (BitVec @n0)) (low1 Int) (high1 Int) (k1 Int))
-  :premises ((= (< low1 (@bvsize x1)) true) (= (>= high1 (@bvsize x1)) true))
-  :args (x1 low1 high1 k1)
-  :conclusion (= (extract high1 low1 (sign_extend k1 x1)) (eo::define ((_let_1 (@bvsize x1))) (sign_extend (+ 1 (- high1 _let_1)) (extract (- _let_1 1) low1 x1))))
+(declare-rule bv-extract-sign-extend-2 ((@n0 Int) (x1 (BitVec @n0)) (low1 Int) (high1 Int) (k1 Int) (nm1 Int) (sn1 Int))
+  :premises ((= (< low1 (@bvsize x1)) true) (= (>= high1 (@bvsize x1)) true) (= nm1 (- (@bvsize x1) 1)) (= sn1 (+ 1 (- high1 (@bvsize x1)))))
+  :args (x1 low1 high1 k1 nm1 sn1)
+  :conclusion (= (extract high1 low1 (sign_extend k1 x1)) (sign_extend sn1 (extract nm1 low1 x1)))
 )
-(declare-rule bv-extract-sign-extend-3 ((@n0 Int) (x1 (BitVec @n0)) (low1 Int) (high1 Int) (k1 Int))
-  :premises ((= (>= low1 (@bvsize x1)) true))
-  :args (x1 low1 high1 k1)
-  :conclusion (= (extract high1 low1 (sign_extend k1 x1)) (eo::define ((_let_1 (- (@bvsize x1) 1))) (repeat (+ 1 (- high1 low1)) (extract _let_1 _let_1 x1))))
+(declare-rule bv-extract-sign-extend-3 ((@n0 Int) (x1 (BitVec @n0)) (low1 Int) (high1 Int) (k1 Int) (rn1 Int) (nm1 Int))
+  :premises ((= (>= low1 (@bvsize x1)) true) (= rn1 (+ 1 (- high1 low1))) (= nm1 (- (@bvsize x1) 1)))
+  :args (x1 low1 high1 k1 rn1 nm1)
+  :conclusion (= (extract high1 low1 (sign_extend k1 x1)) (repeat rn1 (extract nm1 nm1 x1)))
 )
 (declare-rule bv-neg-mult ((@n0 Int) (@n1 Int) (xs1 (BitVec @n0)) (ys1 (BitVec @n1)) (n1 Int) (m1 Int))
   :args (xs1 ys1 n1 m1)
@@ -495,17 +496,19 @@
   :args (xs1 ys1 zs1 x1)
   :conclusion (= (bvand xs1 x1 ys1 x1 zs1) ($singleton_elim (bvand xs1 x1 ys1 zs1)))
 )
-(declare-rule bv-and-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
-  :args (xs1 ys1 zs1 x1)
-  :conclusion (= (bvand xs1 x1 ys1 (bvnot x1) zs1) (@bv 0 (@bvsize x1)))
+(declare-rule bv-and-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (xs1 ys1 zs1 x1 w1)
+  :conclusion (= (bvand xs1 x1 ys1 (bvnot x1) zs1) (@bv 0 w1))
 )
 (declare-rule bv-or-simplify-1 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
   :args (xs1 ys1 zs1 x1)
   :conclusion (= (bvor xs1 x1 ys1 x1 zs1) ($singleton_elim (bvor xs1 x1 ys1 zs1)))
 )
-(declare-rule bv-or-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
-  :args (xs1 ys1 zs1 x1)
-  :conclusion (= (bvor xs1 x1 ys1 (bvnot x1) zs1) (bvnot (@bv 0 (@bvsize x1))))
+(declare-rule bv-or-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (xs1 ys1 zs1 x1 w1)
+  :conclusion (= (bvor xs1 x1 ys1 (bvnot x1) zs1) (bvnot (@bv 0 w1)))
 )
 (declare-rule bv-xor-simplify-1 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
   :args (xs1 ys1 zs1 x1)
@@ -519,23 +522,25 @@
   :args (xs1 ys1 zs1 x1)
   :conclusion (= (bvxor xs1 (bvnot x1) ys1 x1 zs1) (bvnot ($singleton_elim (bvxor xs1 ys1 zs1))))
 )
-(declare-rule bv-ult-add-one ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (c1 (BitVec @n2)))
-  :premises ((= c1 (@bv 1 (@bvsize c1))))
-  :args (x1 y1 c1)
-  :conclusion (= (bvult x1 (bvadd y1 c1)) (and (not (bvult y1 x1)) (not (= y1 (bvnot (@bv 0 (@bvsize y1)))))))
+(declare-rule bv-ult-add-one ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (c1 (BitVec @n2)) (w1 Int))
+  :premises ((= c1 (@bv 1 w1)) (= w1 (@bvsize y1)))
+  :args (x1 y1 c1 w1)
+  :conclusion (= (bvult x1 (bvadd y1 c1)) (and (not (bvult y1 x1)) (not (= y1 (bvnot (@bv 0 w1))))))
 )
-(declare-rule bv-concat-to-mult ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (m1 Int) (n1 Int))
-  :premises ((= (+ 1 i1 m1) (@bvsize x1)) (= n1 0))
-  :args (x1 i1 m1 n1)
-  :conclusion (= (concat (extract i1 n1 x1) (@bv n1 m1)) (eo::define ((_let_1 (@bvsize x1))) (bvmul x1 (bvshl (@bv 1 _let_1) (@bv m1 _let_1)))))
+(declare-rule bv-concat-to-mult ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (m1 Int) (n1 Int) (w1 Int))
+  :premises ((= (+ 1 i1 m1) (@bvsize x1)) (= n1 0) (= w1 (@bvsize x1)))
+  :args (x1 i1 m1 n1 w1)
+  :conclusion (= (concat (extract i1 n1 x1) (@bv n1 m1)) (bvmul x1 (bvshl (@bv 1 w1) (@bv m1 w1))))
 )
-(declare-rule bv-mult-slt-mult-1 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (t1 (BitVec @n1)) (a1 (BitVec @n2)) (n1 Int) (m1 Int))
-  :args (x1 t1 a1 n1 m1)
-  :conclusion (= (eo::define ((_let_1 (sign_extend m1 a1))) (bvslt (bvmul (sign_extend n1 (bvadd x1 t1)) _let_1) (bvmul (sign_extend n1 x1) _let_1))) (eo::define ((_let_1 (@bv 0 (@bvsize a1)))) (and (not (= t1 (@bv 0 (@bvsize t1)))) (not (= a1 _let_1)) (= (bvslt (bvadd x1 t1) x1) (bvsgt a1 _let_1)))))
+(declare-rule bv-mult-slt-mult-1 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (t1 (BitVec @n1)) (a1 (BitVec @n2)) (n1 Int) (m1 Int) (tn1 Int) (an1 Int))
+  :premises ((= tn1 (@bvsize t1)) (= an1 (@bvsize a1)))
+  :args (x1 t1 a1 n1 m1 tn1 an1)
+  :conclusion (= (eo::define ((_let_1 (sign_extend m1 a1))) (bvslt (bvmul (sign_extend n1 (bvadd x1 t1)) _let_1) (bvmul (sign_extend n1 x1) _let_1))) (eo::define ((_let_1 (@bv 0 an1))) (and (not (= t1 (@bv 0 tn1))) (not (= a1 _let_1)) (= (bvslt (bvadd x1 t1) x1) (bvsgt a1 _let_1)))))
 )
-(declare-rule bv-mult-slt-mult-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (t1 (BitVec @n1)) (a1 (BitVec @n2)) (n1 Int) (m1 Int))
-  :args (x1 t1 a1 n1 m1)
-  :conclusion (= (eo::define ((_let_1 (sign_extend m1 a1))) (bvslt (bvmul (zero_extend n1 (bvadd x1 t1)) _let_1) (bvmul (zero_extend n1 x1) _let_1))) (eo::define ((_let_1 (@bv 0 (@bvsize a1)))) (and (not (= t1 (@bv 0 (@bvsize t1)))) (not (= a1 _let_1)) (= (bvult (bvadd x1 t1) x1) (bvsgt a1 _let_1)))))
+(declare-rule bv-mult-slt-mult-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (t1 (BitVec @n1)) (a1 (BitVec @n2)) (n1 Int) (m1 Int) (tn1 Int) (an1 Int))
+  :premises ((= tn1 (@bvsize t1)) (= an1 (@bvsize a1)))
+  :args (x1 t1 a1 n1 m1 tn1 an1)
+  :conclusion (= (eo::define ((_let_1 (sign_extend m1 a1))) (bvslt (bvmul (zero_extend n1 (bvadd x1 t1)) _let_1) (bvmul (zero_extend n1 x1) _let_1))) (eo::define ((_let_1 (@bv 0 an1))) (and (not (= t1 (@bv 0 tn1))) (not (= a1 _let_1)) (= (bvult (bvadd x1 t1) x1) (bvsgt a1 _let_1)))))
 )
 (declare-rule bv-commutative-and ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
   :args (x1 y1)
@@ -557,24 +562,25 @@
   :args (x1 n1)
   :conclusion (= (bvor x1 (@bv 0 n1)) x1)
 )
-(declare-rule bv-mul-one ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (c1 (BitVec @n1)))
-  :premises ((= c1 (@bv 1 (@bvsize c1))))
-  :args (x1 c1)
-  :conclusion (= (bvmul x1 c1) x1)
+(declare-rule bv-mul-one ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvmul x1 (@bv 1 w1)) x1)
 )
-(declare-rule bv-mul-zero ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (c1 (BitVec @n1)))
-  :premises ((= c1 (@bv 0 (@bvsize c1))))
-  :args (x1 c1)
-  :conclusion (= (bvmul x1 c1) (@bv 0 (@bvsize x1)))
+(declare-rule bv-mul-zero ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvmul x1 (@bv 0 w1)) (@bv 0 w1))
 )
-(declare-rule bv-add-zero ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (c1 (BitVec @n1)))
-  :premises ((= c1 (@bv 0 (@bvsize c1))))
-  :args (x1 c1)
-  :conclusion (= (bvadd x1 c1) x1)
+(declare-rule bv-add-zero ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvadd x1 (@bv 0 w1)) x1)
 )
-(declare-rule bv-add-two ((@n0 Int) (x1 (BitVec @n0)))
-  :args (x1)
-  :conclusion (= (bvadd x1 x1) (bvmul x1 (@bv 2 (@bvsize x1))))
+(declare-rule bv-add-two ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvadd x1 x1) (bvmul x1 (@bv 2 w1)))
 )
 (declare-rule bv-zero-extend-eliminate-0 ((@n0 Int) (x1 (BitVec @n0)))
   :args (x1)
@@ -589,10 +595,10 @@
   :args (x1)
   :conclusion (= (= x1 (bvnot x1)) false)
 )
-(declare-rule bv-ult-ones ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
-  :args (x1 y1)
-  :conclusion (= (bvult x1 y1) (distinct x1 y1))
+(declare-rule bv-ult-ones ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (w1 Int))
+  :premises ((= n1 (- (int.pow2 w1) 1)))
+  :args (x1 n1 w1)
+  :conclusion (= (bvult x1 (@bv n1 w1)) (distinct x1 (@bv n1 w1)))
 )
 (declare-rule bv-or-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (s1 (BitVec @n1)) (ys1 (BitVec @n2) :list) (zs1 (BitVec @n3) :list))
   :args (xs1 s1 ys1 zs1)
@@ -610,9 +616,10 @@
   :args (xs1 s1 ys1 zs1)
   :conclusion (= ($singleton_elim (bvmul xs1 ($singleton_elim (bvmul s1 ys1)) zs1)) ($singleton_elim (bvmul xs1 s1 ys1 zs1)))
 )
-(declare-rule bv-concat-merge-const ((@n0 Int) (@n1 Int) (xs1 (BitVec @n0) :list) (n1 Int) (w1 Int) (n2 Int) (w2 Int) (zs1 (BitVec @n1) :list))
-  :args (xs1 n1 w1 n2 w2 zs1)
-  :conclusion (= (concat xs1 (@bv n1 w1) (@bv n2 w2) zs1) ($singleton_elim (concat xs1 (@bv (+ (* n1 (int.pow2 w2)) n2) (+ w1 w2)) zs1)))
+(declare-rule bv-concat-merge-const ((@n0 Int) (@n1 Int) (xs1 (BitVec @n0) :list) (n1 Int) (w1 Int) (n2 Int) (w2 Int) (ww1 Int) (zs1 (BitVec @n1) :list))
+  :premises ((= ww1 (+ w1 w2)))
+  :args (xs1 n1 w1 n2 w2 ww1 zs1)
+  :conclusion (= (concat xs1 (@bv n1 w1) (@bv n2 w2) zs1) ($singleton_elim (concat xs1 (@bv (+ (* n1 (int.pow2 w2)) n2) ww1) zs1)))
 )
 (declare-rule bv-commutative-add ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
   :args (x1 y1)
@@ -646,21 +653,24 @@
   :args (x1 y1)
   :conclusion (= (bvsge x1 y1) (bvsle y1 x1))
 )
-(declare-rule bv-slt-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvslt x1 y1) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (bvshl (@bv 1 _let_1) (@bv (- _let_1 1) _let_1)))) (bvult (bvadd x1 _let_2) (bvadd y1 _let_2)))))
+(declare-rule bv-slt-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 y1 w1)
+  :conclusion (= (bvslt x1 y1) (eo::define ((_let_1 (bvshl (@bv 1 w1) (@bv (- (@bvsize x1) 1) w1)))) (bvult (bvadd x1 _let_1) (bvadd y1 _let_1))))
 )
 (declare-rule bv-sle-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
   :args (x1 y1)
   :conclusion (= (bvsle x1 y1) (not (bvslt y1 x1)))
 )
-(declare-rule bv-redor-eliminate ((@n0 Int) (x1 (BitVec @n0)))
-  :args (x1)
-  :conclusion (= (bvredor x1) (bvnot (bvcomp x1 (@bv 0 (@bvsize x1)))))
+(declare-rule bv-redor-eliminate ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvredor x1) (bvnot (bvcomp x1 (@bv 0 w1))))
 )
-(declare-rule bv-redand-eliminate ((@n0 Int) (x1 (BitVec @n0)))
-  :args (x1)
-  :conclusion (= (bvredand x1) (bvcomp x1 (bvnot (@bv 0 (@bvsize x1)))))
+(declare-rule bv-redand-eliminate ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvredand x1) (bvcomp x1 (bvnot (@bv 0 w1))))
 )
 (declare-rule bv-ule-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
   :args (x1 y1)
@@ -670,30 +680,30 @@
   :args (x1 y1)
   :conclusion (= (bvcomp x1 y1) (ite (= x1 y1) (@bv 1 1) (@bv 0 1)))
 )
-(declare-rule bv-repeat-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
-  :premises ((= (> n1 1) true))
-  :args (x1 n1)
-  :conclusion (= (repeat n1 x1) (concat x1 (repeat (- n1 1) x1)))
+(declare-rule bv-repeat-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (nm1 Int))
+  :premises ((= (> n1 1) true) (= nm1 (- n1 1)))
+  :args (x1 n1 nm1)
+  :conclusion (= (repeat n1 x1) (concat x1 (repeat nm1 x1)))
 )
 (declare-rule bv-repeat-eliminate-2 ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
   :premises ((= n1 1))
   :args (x1 n1)
   :conclusion (= (repeat n1 x1) x1)
 )
-(declare-rule bv-rotate-left-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int))
-  :premises ((= (= (mod amount1 (@bvsize x1)) 0) false))
-  :args (x1 amount1)
-  :conclusion (= (rotate_left amount1 x1) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (mod amount1 _let_1))) (concat (extract (- _let_1 (+ 1 _let_2)) 0 x1) (extract (- _let_1 1) (- _let_1 _let_2) x1)))))
+(declare-rule bv-rotate-left-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (u1 Int) (u2 Int) (l1 Int))
+  :premises ((= (= (mod amount1 (@bvsize x1)) 0) false) (eo::define ((_let_1 (@bvsize x1))) (= u1 (- _let_1 (+ 1 (mod amount1 _let_1))))) (= u2 (- (@bvsize x1) 1)) (eo::define ((_let_1 (@bvsize x1))) (= l1 (- _let_1 (mod amount1 _let_1)))))
+  :args (x1 amount1 u1 u2 l1)
+  :conclusion (= (rotate_left amount1 x1) (concat (extract u1 0 x1) (extract u2 l1 x1)))
 )
 (declare-rule bv-rotate-left-eliminate-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int))
   :premises ((= (mod amount1 (@bvsize x1)) 0))
   :args (x1 amount1)
   :conclusion (= (rotate_left amount1 x1) x1)
 )
-(declare-rule bv-rotate-right-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int))
-  :premises ((= (= (mod amount1 (@bvsize x1)) 0) false))
-  :args (x1 amount1)
-  :conclusion (= (rotate_right amount1 x1) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (mod amount1 _let_1))) (concat (extract (- _let_2 1) 0 x1) (extract (- _let_1 1) _let_2 x1)))))
+(declare-rule bv-rotate-right-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (u1 Int) (u2 Int) (l1 Int))
+  :premises ((= (= (mod amount1 (@bvsize x1)) 0) false) (= u1 (- (mod amount1 (@bvsize x1)) 1)) (= u2 (- (@bvsize x1) 1)) (= l1 (mod amount1 (@bvsize x1))))
+  :args (x1 amount1 u1 u2 l1)
+  :conclusion (= (rotate_right amount1 x1) (concat (extract u1 0 x1) (extract u2 l1 x1)))
 )
 (declare-rule bv-rotate-right-eliminate-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int))
   :premises ((= (mod amount1 (@bvsize x1)) 0))
@@ -712,57 +722,69 @@
   :args (x1 y1)
   :conclusion (= (bvxnor x1 y1) (bvnot (bvxor x1 y1)))
 )
-(declare-rule bv-sdiv-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvsdiv x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (= (extract _let_2 _let_2 y1) _let_1))) (eo::define ((_let_4 (= (extract _let_2 _let_2 x1) _let_1))) (eo::define ((_let_5 (bvudiv (ite _let_4 (bvneg x1) x1) (ite _let_3 (bvneg y1) y1)))) (ite (xor _let_4 _let_3) (bvneg _let_5) _let_5)))))))
+(declare-rule bv-sdiv-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (nm1 Int))
+  :premises ((= nm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 nm1)
+  :conclusion (= (bvsdiv x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (= (extract nm1 nm1 y1) _let_1))) (eo::define ((_let_3 (= (extract nm1 nm1 x1) _let_1))) (eo::define ((_let_4 (bvudiv (ite _let_3 (bvneg x1) x1) (ite _let_2 (bvneg y1) y1)))) (ite (xor _let_3 _let_2) (bvneg _let_4) _let_4))))))
 )
-(declare-rule bv-sdiv-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvsdiv x1 y1) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 (- (@bvsize x1) 1))))) (eo::define ((_let_2 (bvuge y1 _let_1))) (eo::define ((_let_3 (bvuge x1 _let_1))) (eo::define ((_let_4 (bvudiv (ite _let_3 (bvneg x1) x1) (ite _let_2 (bvneg y1) y1)))) (ite (xor _let_3 _let_2) (bvneg _let_4) _let_4))))))
+(declare-rule bv-sdiv-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (nm1 Int))
+  :premises ((= nm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 nm1)
+  :conclusion (= (bvsdiv x1 y1) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 nm1)))) (eo::define ((_let_2 (bvuge y1 _let_1))) (eo::define ((_let_3 (bvuge x1 _let_1))) (eo::define ((_let_4 (bvudiv (ite _let_3 (bvneg x1) x1) (ite _let_2 (bvneg y1) y1)))) (ite (xor _let_3 _let_2) (bvneg _let_4) _let_4))))))
 )
 (declare-rule bv-zero-extend-eliminate ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
   :args (x1 n1)
   :conclusion (= (zero_extend n1 x1) (concat (@bv 0 n1) x1))
 )
-(declare-rule bv-sign-extend-eliminate ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
-  :args (x1 n1)
-  :conclusion (= (sign_extend n1 x1) (eo::define ((_let_1 (- (@bvsize x1) 1))) (concat (repeat n1 (extract _let_1 _let_1 x1)) x1)))
-)
-(declare-rule bv-uaddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvuaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (= (extract _let_2 _let_2 (bvadd (concat _let_1 x1) (concat _let_1 y1))) (@bv 1 1)))))
-)
-(declare-rule bv-saddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvsaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (extract _let_2 _let_2 (bvadd x1 y1)))) (eo::define ((_let_4 (@bv 1 1))) (eo::define ((_let_5 (extract _let_2 _let_2 y1))) (eo::define ((_let_6 (extract _let_2 _let_2 x1))) (or (and (and (= _let_6 _let_1) (= _let_5 _let_1)) (= _let_3 _let_4)) (and (and (= _let_6 _let_4) (= _let_5 _let_4)) (= _let_3 _let_1))))))))))
-)
-(declare-rule bv-sdivo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvsdivo x1 y1) (and (= x1 (concat (@bv 1 1) (@bv 0 (- (@bvsize x1) 1)))) (= y1 (bvnot (@bv 0 (@bvsize y1))))))
-)
-(declare-rule bv-smod-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvsmod x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (@bvsize x1))) (eo::define ((_let_3 (- _let_2 1))) (eo::define ((_let_4 (= (extract _let_3 _let_3 y1) _let_1))) (eo::define ((_let_5 (= (extract _let_3 _let_3 x1) _let_1))) (eo::define ((_let_6 (bvurem (ite _let_5 (bvneg x1) x1) (ite _let_4 (bvneg y1) y1)))) (eo::define ((_let_7 (bvneg _let_6))) (eo::define ((_let_8 (not _let_5))) (eo::define ((_let_9 (not _let_4))) (ite (= _let_6 (@bv 0 _let_2)) _let_6 (ite (and _let_8 _let_9) _let_6 (ite (and _let_5 _let_9) (bvadd _let_7 y1) (ite (and _let_8 _let_4) (bvadd _let_6 y1) _let_7))))))))))))))
-)
-(declare-rule bv-smod-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvsmod x1 y1) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (concat (@bv 1 1) (@bv 0 (- _let_1 1))))) (eo::define ((_let_3 (bvuge y1 _let_2))) (eo::define ((_let_4 (bvuge x1 _let_2))) (eo::define ((_let_5 (bvurem (ite _let_4 (bvneg x1) x1) (ite _let_3 (bvneg y1) y1)))) (eo::define ((_let_6 (bvneg _let_5))) (eo::define ((_let_7 (not _let_4))) (eo::define ((_let_8 (not _let_3))) (ite (= _let_5 (@bv 0 _let_1)) _let_5 (ite (and _let_7 _let_8) _let_5 (ite (and _let_4 _let_8) (bvadd _let_6 y1) (ite (and _let_7 _let_3) (bvadd _let_5 y1) _let_6)))))))))))))
-)
-(declare-rule bv-srem-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvsrem x1 y1) (eo::define ((_let_1 (- (@bvsize x1) 1))) (eo::define ((_let_2 (extract _let_1 _let_1 x1))) (eo::define ((_let_3 (bvurem (bvite _let_2 (bvneg x1) x1) (bvite (extract _let_1 _let_1 y1) (bvneg y1) y1)))) (bvite _let_2 (bvneg _let_3) _let_3)))))
-)
-(declare-rule bv-srem-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvsrem x1 y1) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 (- (@bvsize x1) 1))))) (eo::define ((_let_2 (bvuge x1 _let_1))) (eo::define ((_let_3 (bvurem (ite _let_2 (bvneg x1) x1) (ite (bvuge y1 _let_1) (bvneg y1) y1)))) (ite _let_2 (bvneg _let_3) _let_3)))))
-)
-(declare-rule bv-usubo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvusubo x1 y1) (eo::define ((_let_1 (@bvsize x1))) (= (extract _let_1 _let_1 (bvsub (zero_extend 1 x1) (zero_extend 1 y1))) (@bv 1 1))))
-)
-(declare-rule bv-ssubo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :args (x1 y1)
-  :conclusion (= (bvssubo x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (= (extract _let_2 _let_2 (bvsub x1 y1)) _let_1))) (eo::define ((_let_4 (= (extract _let_2 _let_2 y1) _let_1))) (eo::define ((_let_5 (= (extract _let_2 _let_2 x1) _let_1))) (or (and _let_5 (not _let_4) (not _let_3)) (and (not _let_5) _let_4 _let_3))))))))
+(declare-rule bv-sign-extend-eliminate ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (wm1 Int))
+  :premises ((= wm1 (- (@bvsize x1) 1)))
+  :args (x1 n1 wm1)
+  :conclusion (= (sign_extend n1 x1) (concat (repeat n1 (extract wm1 wm1 x1)) x1))
+)
+(declare-rule bv-uaddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (wm1 Int))
+  :premises ((= wm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 wm1)
+  :conclusion (= (bvuaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (= (extract wm1 wm1 (bvadd (concat _let_1 x1) (concat _let_1 y1))) (@bv 1 1))))
+)
+(declare-rule bv-saddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (wm1 Int))
+  :premises ((= wm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 wm1)
+  :conclusion (= (bvsaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (eo::define ((_let_2 (extract wm1 wm1 (bvadd x1 y1)))) (eo::define ((_let_3 (@bv 1 1))) (eo::define ((_let_4 (extract wm1 wm1 y1))) (eo::define ((_let_5 (extract wm1 wm1 x1))) (or (and (and (= _let_5 _let_1) (= _let_4 _let_1)) (= _let_2 _let_3)) (and (and (= _let_5 _let_3) (= _let_4 _let_3)) (= _let_2 _let_1)))))))))
+)
+(declare-rule bv-sdivo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (w1 Int) (wm1 Int))
+  :premises ((= wm1 (- (@bvsize x1) 1)) (= w1 (@bvsize y1)))
+  :args (x1 y1 w1 wm1)
+  :conclusion (= (bvsdivo x1 y1) (and (= x1 (concat (@bv 1 1) (@bv 0 wm1))) (= y1 (bvnot (@bv 0 w1)))))
+)
+(declare-rule bv-smod-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (w1 Int) (wm1 Int))
+  :premises ((= w1 (@bvsize x1)) (= wm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 w1 wm1)
+  :conclusion (= (bvsmod x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (= (extract wm1 wm1 y1) _let_1))) (eo::define ((_let_3 (= (extract wm1 wm1 x1) _let_1))) (eo::define ((_let_4 (bvurem (ite _let_3 (bvneg x1) x1) (ite _let_2 (bvneg y1) y1)))) (eo::define ((_let_5 (bvneg _let_4))) (eo::define ((_let_6 (not _let_3))) (eo::define ((_let_7 (not _let_2))) (ite (= _let_4 (@bv 0 w1)) _let_4 (ite (and _let_6 _let_7) _let_4 (ite (and _let_3 _let_7) (bvadd _let_5 y1) (ite (and _let_6 _let_2) (bvadd _let_4 y1) _let_5))))))))))))
+)
+(declare-rule bv-smod-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (w1 Int) (wm1 Int))
+  :premises ((= w1 (@bvsize x1)) (= wm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 w1 wm1)
+  :conclusion (= (bvsmod x1 y1) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 wm1)))) (eo::define ((_let_2 (bvuge y1 _let_1))) (eo::define ((_let_3 (bvuge x1 _let_1))) (eo::define ((_let_4 (bvurem (ite _let_3 (bvneg x1) x1) (ite _let_2 (bvneg y1) y1)))) (eo::define ((_let_5 (bvneg _let_4))) (eo::define ((_let_6 (not _let_3))) (eo::define ((_let_7 (not _let_2))) (ite (= _let_4 (@bv 0 w1)) _let_4 (ite (and _let_6 _let_7) _let_4 (ite (and _let_3 _let_7) (bvadd _let_5 y1) (ite (and _let_6 _let_2) (bvadd _let_4 y1) _let_5))))))))))))
+)
+(declare-rule bv-srem-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (nm1 Int))
+  :premises ((= nm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 nm1)
+  :conclusion (= (bvsrem x1 y1) (eo::define ((_let_1 (extract nm1 nm1 x1))) (eo::define ((_let_2 (bvurem (bvite _let_1 (bvneg x1) x1) (bvite (extract nm1 nm1 y1) (bvneg y1) y1)))) (bvite _let_1 (bvneg _let_2) _let_2))))
+)
+(declare-rule bv-srem-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (nm1 Int))
+  :premises ((= nm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 nm1)
+  :conclusion (= (bvsrem x1 y1) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 nm1)))) (eo::define ((_let_2 (bvuge x1 _let_1))) (eo::define ((_let_3 (bvurem (ite _let_2 (bvneg x1) x1) (ite (bvuge y1 _let_1) (bvneg y1) y1)))) (ite _let_2 (bvneg _let_3) _let_3)))))
+)
+(declare-rule bv-usubo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (n1 Int))
+  :premises ((= n1 (@bvsize x1)))
+  :args (x1 y1 n1)
+  :conclusion (= (bvusubo x1 y1) (= (extract n1 n1 (bvsub (zero_extend 1 x1) (zero_extend 1 y1))) (@bv 1 1)))
+)
+(declare-rule bv-ssubo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (nm1 Int))
+  :premises ((= nm1 (- (@bvsize x1) 1)))
+  :args (x1 y1 nm1)
+  :conclusion (= (bvssubo x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (= (extract nm1 nm1 (bvsub x1 y1)) _let_1))) (eo::define ((_let_3 (= (extract nm1 nm1 y1) _let_1))) (eo::define ((_let_4 (= (extract nm1 nm1 x1) _let_1))) (or (and _let_4 (not _let_3) (not _let_2)) (and (not _let_4) _let_3 _let_2)))))))
 )
 (declare-rule bv-ite-equal-children ((@n0 Int) (c1 (_ BitVec 1)) (x1 (BitVec @n0)))
   :args (c1 x1)
@@ -808,24 +830,24 @@
   :args (x1 sz1)
   :conclusion (= (bvshl x1 (@bv 0 sz1)) x1)
 )
-(declare-rule bv-shl-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
-  :premises ((= (< amount1 (@bvsize x1)) true))
-  :args (x1 amount1 sz1)
-  :conclusion (= (bvshl x1 (@bv amount1 sz1)) (concat (extract (- (@bvsize x1) (+ 1 amount1)) 0 x1) (@bv 0 amount1)))
+(declare-rule bv-shl-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int) (en1 Int))
+  :premises ((= (< amount1 (@bvsize x1)) true) (= en1 (- (@bvsize x1) (+ 1 amount1))))
+  :args (x1 amount1 sz1 en1)
+  :conclusion (= (bvshl x1 (@bv amount1 sz1)) (concat (extract en1 0 x1) (@bv 0 amount1)))
 )
-(declare-rule bv-shl-by-const-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
-  :premises ((= (>= amount1 (@bvsize x1)) true))
-  :args (x1 amount1 sz1)
-  :conclusion (= (bvshl x1 (@bv amount1 sz1)) (@bv 0 (@bvsize x1)))
+(declare-rule bv-shl-by-const-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int) (w1 Int))
+  :premises ((= (>= amount1 (@bvsize x1)) true) (= w1 (@bvsize x1)))
+  :args (x1 amount1 sz1 w1)
+  :conclusion (= (bvshl x1 (@bv amount1 sz1)) (@bv 0 w1))
 )
 (declare-rule bv-lshr-by-const-0 ((@n0 Int) (x1 (BitVec @n0)) (sz1 Int))
   :args (x1 sz1)
   :conclusion (= (bvlshr x1 (@bv 0 sz1)) x1)
 )
-(declare-rule bv-lshr-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
-  :premises ((= (< amount1 (@bvsize x1)) true))
-  :args (x1 amount1 sz1)
-  :conclusion (= (bvlshr x1 (@bv amount1 sz1)) (concat (@bv 0 amount1) (extract (- (@bvsize x1) 1) amount1 x1)))
+(declare-rule bv-lshr-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int) (nm1 Int))
+  :premises ((= (< amount1 (@bvsize x1)) true) (= nm1 (- (@bvsize x1) 1)))
+  :args (x1 amount1 sz1 nm1)
+  :conclusion (= (bvlshr x1 (@bv amount1 sz1)) (concat (@bv 0 amount1) (extract nm1 amount1 x1)))
 )
 (declare-rule bv-lshr-by-const-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
   :premises ((= (>= amount1 (@bvsize x1)) true))
@@ -836,27 +858,30 @@
   :args (x1 sz1)
   :conclusion (= (bvashr x1 (@bv 0 sz1)) x1)
 )
-(declare-rule bv-ashr-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
-  :premises ((= (< amount1 (@bvsize x1)) true))
-  :args (x1 amount1 sz1)
-  :conclusion (= (bvashr x1 (@bv amount1 sz1)) (eo::define ((_let_1 (- (@bvsize x1) 1))) (concat (repeat amount1 (extract _let_1 _let_1 x1)) (extract _let_1 amount1 x1))))
+(declare-rule bv-ashr-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int) (nm1 Int))
+  :premises ((= (< amount1 (@bvsize x1)) true) (= nm1 (- (@bvsize x1) 1)))
+  :args (x1 amount1 sz1 nm1)
+  :conclusion (= (bvashr x1 (@bv amount1 sz1)) (concat (repeat amount1 (extract nm1 nm1 x1)) (extract nm1 amount1 x1)))
 )
-(declare-rule bv-ashr-by-const-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
-  :premises ((= (>= amount1 (@bvsize x1)) true))
-  :args (x1 amount1 sz1)
-  :conclusion (= (bvashr x1 (@bv amount1 sz1)) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (- _let_1 1))) (repeat _let_1 (extract _let_2 _let_2 x1)))))
+(declare-rule bv-ashr-by-const-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int) (nm1 Int) (rn1 Int))
+  :premises ((= (>= amount1 (@bvsize x1)) true) (= nm1 (- (@bvsize x1) 1)) (= rn1 (@bvsize x1)))
+  :args (x1 amount1 sz1 nm1 rn1)
+  :conclusion (= (bvashr x1 (@bv amount1 sz1)) (repeat rn1 (extract nm1 nm1 x1)))
 )
-(declare-rule bv-and-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list))
-  :args (x1 y1 z1 ys1)
-  :conclusion (= (bvand x1 (concat ys1 z1 y1)) (eo::define ((_let_1 (@bvsize y1))) (concat (bvand (extract (- (@bvsize x1) 1) _let_1 x1) ($singleton_elim (concat ys1 z1))) (bvand (extract (- _let_1 1) 0 x1) y1))))
+(declare-rule bv-and-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list) (nxm1 Int) (ny1 Int) (nym1 Int))
+  :premises ((= ny1 (@bvsize y1)) (= nxm1 (- (@bvsize x1) 1)) (= nym1 (- (@bvsize y1) 1)))
+  :args (x1 y1 z1 ys1 nxm1 ny1 nym1)
+  :conclusion (= (bvand x1 (concat ys1 z1 y1)) (concat (bvand (extract nxm1 ny1 x1) ($singleton_elim (concat ys1 z1))) (bvand (extract nym1 0 x1) y1)))
 )
-(declare-rule bv-or-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list))
-  :args (x1 y1 z1 ys1)
-  :conclusion (= (bvor x1 (concat ys1 z1 y1)) (eo::define ((_let_1 (@bvsize y1))) (concat (bvor (extract (- (@bvsize x1) 1) _let_1 x1) ($singleton_elim (concat ys1 z1))) (bvor (extract (- _let_1 1) 0 x1) y1))))
+(declare-rule bv-or-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list) (nxm1 Int) (ny1 Int) (nym1 Int))
+  :premises ((= ny1 (@bvsize y1)) (= nxm1 (- (@bvsize x1) 1)) (= nym1 (- (@bvsize y1) 1)))
+  :args (x1 y1 z1 ys1 nxm1 ny1 nym1)
+  :conclusion (= (bvor x1 (concat ys1 z1 y1)) (concat (bvor (extract nxm1 ny1 x1) ($singleton_elim (concat ys1 z1))) (bvor (extract nym1 0 x1) y1)))
 )
-(declare-rule bv-xor-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list))
-  :args (x1 y1 z1 ys1)
-  :conclusion (= (bvxor x1 (concat ys1 z1 y1)) (eo::define ((_let_1 (@bvsize y1))) (concat (bvxor (extract (- (@bvsize x1) 1) _let_1 x1) ($singleton_elim (concat ys1 z1))) (bvxor (extract (- _let_1 1) 0 x1) y1))))
+(declare-rule bv-xor-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list) (nxm1 Int) (ny1 Int) (nym1 Int))
+  :premises ((= ny1 (@bvsize y1)) (= nxm1 (- (@bvsize x1) 1)) (= nym1 (- (@bvsize y1) 1)))
+  :args (x1 y1 z1 ys1 nxm1 ny1 nym1)
+  :conclusion (= (bvxor x1 (concat ys1 z1 y1)) (concat (bvxor (extract nxm1 ny1 x1) ($singleton_elim (concat ys1 z1))) (bvxor (extract nym1 0 x1) y1)))
 )
 (declare-rule bv-bitwise-idemp-1 ((@n0 Int) (x1 (BitVec @n0)))
   :args (x1)
@@ -870,36 +895,39 @@
   :args (x1 n1)
   :conclusion (= (bvand x1 (@bv 0 n1)) (@bv 0 n1))
 )
-(declare-rule bv-and-one ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
-  :args (x1 y1)
-  :conclusion (= (bvand x1 y1) x1)
+(declare-rule bv-and-one ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (w1 Int))
+  :premises ((= w1 (@bvsize x1)) (= n1 (- (int.pow2 (@bvsize x1)) 1)))
+  :args (x1 n1 w1)
+  :conclusion (= (bvand x1 (@bv n1 w1)) x1)
 )
-(declare-rule bv-or-one ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
-  :args (x1 y1)
-  :conclusion (= (bvor x1 y1) (bvnot (@bv 0 (@bvsize y1))))
+(declare-rule bv-or-one ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (w1 Int))
+  :premises ((= w1 (@bvsize x1)) (= n1 (- (int.pow2 (@bvsize x1)) 1)))
+  :args (x1 n1 w1)
+  :conclusion (= (bvor x1 (@bv n1 w1)) (bvnot (@bv 0 w1)))
 )
-(declare-rule bv-xor-duplicate ((@n0 Int) (x1 (BitVec @n0)))
-  :args (x1)
-  :conclusion (= (bvxor x1 x1) (@bv 0 (@bvsize x1)))
+(declare-rule bv-xor-duplicate ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvxor x1 x1) (@bv 0 w1))
 )
-(declare-rule bv-xor-ones ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
-  :args (x1 y1)
-  :conclusion (= (bvxor x1 y1) (bvnot x1))
+(declare-rule bv-xor-ones ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (w1 Int))
+  :premises ((= n1 (- (int.pow2 (@bvsize x1)) 1)))
+  :args (x1 n1 w1)
+  :conclusion (= (bvxor x1 (@bv n1 w1)) (bvnot x1))
 )
 (declare-rule bv-xor-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
   :args (x1 n1)
   :conclusion (= (bvxor x1 (@bv 0 n1)) x1)
 )
-(declare-rule bv-bitwise-not-and ((@n0 Int) (x1 (BitVec @n0)))
-  :args (x1)
-  :conclusion (= (bvand x1 (bvnot x1)) (@bv 0 (@bvsize x1)))
+(declare-rule bv-bitwise-not-and ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvand x1 (bvnot x1)) (@bv 0 w1))
 )
-(declare-rule bv-bitwise-not-or ((@n0 Int) (x1 (BitVec @n0)))
-  :args (x1)
-  :conclusion (= (bvor x1 (bvnot x1)) (bvnot (@bv 0 (@bvsize x1))))
+(declare-rule bv-bitwise-not-or ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvor x1 (bvnot x1)) (bvnot (@bv 0 w1)))
 )
 (declare-rule bv-xor-not ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
   :args (x1 y1)
@@ -941,10 +969,10 @@
   :args (x1)
   :conclusion (= (bvsle x1 x1) true)
 )
-(declare-rule bv-ule-max ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
-  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
-  :args (x1 y1)
-  :conclusion (= (bvule x1 y1) true)
+(declare-rule bv-ule-max ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (w1 Int))
+  :premises ((= w1 (@bvsize x1)) (= n1 (- (int.pow2 (@bvsize x1)) 1)))
+  :args (x1 n1 w1)
+  :conclusion (= (bvule x1 (@bv n1 w1)) true)
 )
 (declare-rule bv-not-ult ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
   :args (x1 y1)
@@ -958,30 +986,30 @@
   :args (x1 y1)
   :conclusion (= (not (bvsle x1 y1)) (bvslt y1 x1))
 )
-(declare-rule bv-mult-pow2-1 ((@n0 Int) (@n1 Int) (@n2 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (z1 (BitVec @n2)) (size1 Int) (n1 Int))
-  :premises ((= (int.ispow2 n1) true))
-  :args (xs1 ys1 z1 size1 n1)
-  :conclusion (= (bvmul xs1 z1 (@bv n1 size1) ys1) (eo::define ((_let_1 (int.log2 n1))) (concat (extract (- (- size1 _let_1) 1) 0 ($singleton_elim (bvmul xs1 z1 ys1))) (@bv 0 _let_1))))
+(declare-rule bv-mult-pow2-1 ((@n0 Int) (@n1 Int) (@n2 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (z1 (BitVec @n2)) (size1 Int) (n1 Int) (exponent1 Int) (u1 Int))
+  :premises ((= (int.ispow2 n1) true) (= exponent1 (int.log2 n1)) (= u1 (- (- size1 (int.log2 n1)) 1)))
+  :args (xs1 ys1 z1 size1 n1 exponent1 u1)
+  :conclusion (= (bvmul xs1 z1 (@bv n1 size1) ys1) (concat (extract u1 0 ($singleton_elim (bvmul xs1 z1 ys1))) (@bv 0 exponent1)))
 )
-(declare-rule bv-mult-pow2-2 ((@n0 Int) (@n1 Int) (@n2 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (z1 (BitVec @n2)) (size1 Int) (n1 Int))
-  :premises ((= (int.ispow2 (- n1)) true))
-  :args (xs1 ys1 z1 size1 n1)
-  :conclusion (= (bvmul xs1 z1 (@bv n1 size1) ys1) (eo::define ((_let_1 (int.log2 (- n1)))) (concat (extract (- (- size1 _let_1) 1) 0 (bvneg ($singleton_elim (bvmul xs1 z1 ys1)))) (@bv 0 _let_1))))
+(declare-rule bv-mult-pow2-2 ((@n0 Int) (@n1 Int) (@n2 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (z1 (BitVec @n2)) (size1 Int) (n1 Int) (exponent1 Int) (u1 Int))
+  :premises ((= (int.ispow2 (- n1)) true) (= exponent1 (int.log2 n1)) (= u1 (- (- size1 (int.log2 n1)) 1)))
+  :args (xs1 ys1 z1 size1 n1 exponent1 u1)
+  :conclusion (= (bvmul xs1 z1 (@bv n1 size1) ys1) (concat (extract u1 0 (bvneg ($singleton_elim (bvmul xs1 z1 ys1)))) (@bv 0 exponent1)))
 )
-(declare-rule bv-mult-pow2-2b ((@n0 Int) (z1 (BitVec @n0)) (size1 Int) (n1 Int))
-  :premises ((= (int.ispow2 (- n1)) true))
-  :args (z1 size1 n1)
-  :conclusion (= (bvmul z1 (@bv n1 size1)) (eo::define ((_let_1 (int.log2 (- n1)))) (concat (extract (- (- size1 _let_1) 1) 0 (bvneg z1)) (@bv 0 _let_1))))
+(declare-rule bv-mult-pow2-2b ((@n0 Int) (z1 (BitVec @n0)) (size1 Int) (n1 Int) (exponent1 Int) (u1 Int))
+  :premises ((= (int.ispow2 (- n1)) true) (= exponent1 (int.log2 n1)) (= u1 (- (- size1 (int.log2 n1)) 1)))
+  :args (z1 size1 n1 exponent1 u1)
+  :conclusion (= (bvmul z1 (@bv n1 size1)) (concat (extract u1 0 (bvneg z1)) (@bv 0 exponent1)))
 )
-(declare-rule bv-extract-mult-leading-bit ((@n0 Int) (@n1 Int) (high1 Int) (low1 Int) (x1i1 Int) (x1in1 Int) (x1 (BitVec @n0)) (y1i1 Int) (y1in1 Int) (y1 (BitVec @n1)))
-  :premises ((= (> (+ x1in1 (@bvsize x1)) 64) true) (= (<= (- (* 2 (+ x1in1 (@bvsize x1))) (+ (ite (= x1i1 0) x1in1 (- x1in1 (+ 1 (int.log2 x1i1)))) (ite (= y1i1 0) y1in1 (- y1in1 (+ 1 (int.log2 y1i1)))))) low1) true))
-  :args (high1 low1 x1i1 x1in1 x1 y1i1 y1in1 y1)
-  :conclusion (= (extract high1 low1 (bvmul (concat (@bv x1i1 x1in1) x1) (concat (@bv y1i1 y1in1) y1))) (@bv 0 (+ 1 (- high1 low1))))
+(declare-rule bv-extract-mult-leading-bit ((@n0 Int) (@n1 Int) (high1 Int) (low1 Int) (x1i1 Int) (x1in1 Int) (x1 (BitVec @n0)) (y1i1 Int) (y1in1 Int) (y1 (BitVec @n1)) (w1 Int))
+  :premises ((= (> (+ x1in1 (@bvsize x1)) 64) true) (= (<= (- (* 2 (+ x1in1 (@bvsize x1))) (+ (ite (= x1i1 0) x1in1 (- x1in1 (+ 1 (int.log2 x1i1)))) (ite (= y1i1 0) y1in1 (- y1in1 (+ 1 (int.log2 y1i1)))))) low1) true) (= w1 (+ 1 (- high1 low1))))
+  :args (high1 low1 x1i1 x1in1 x1 y1i1 y1in1 y1 w1)
+  :conclusion (= (extract high1 low1 (bvmul (concat (@bv x1i1 x1in1) x1) (concat (@bv y1i1 y1in1) y1))) (@bv 0 w1))
 )
-(declare-rule bv-udiv-pow2-not-one ((@n0 Int) (x1 (BitVec @n0)) (v1 Int) (n1 Int))
-  :premises ((= (int.ispow2 v1) true) (= (> v1 1) true))
-  :args (x1 v1 n1)
-  :conclusion (= (bvudiv x1 (@bv v1 n1)) (eo::define ((_let_1 (int.log2 v1))) (concat (@bv 0 _let_1) (extract (- n1 1) _let_1 x1))))
+(declare-rule bv-udiv-pow2-not-one ((@n0 Int) (x1 (BitVec @n0)) (v1 Int) (n1 Int) (power1 Int) (nm1 Int))
+  :premises ((= (int.ispow2 v1) true) (= (> v1 1) true) (= power1 (int.log2 v1)) (= nm1 (- n1 1)))
+  :args (x1 v1 n1 power1 nm1)
+  :conclusion (= (bvudiv x1 (@bv v1 n1)) (concat (@bv 0 power1) (extract nm1 power1 x1)))
 )
 (declare-rule bv-udiv-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
   :args (x1 n1)
@@ -991,18 +1019,19 @@
   :args (x1 n1)
   :conclusion (= (bvudiv x1 (@bv 1 n1)) x1)
 )
-(declare-rule bv-urem-pow2-not-one ((@n0 Int) (x1 (BitVec @n0)) (v1 Int) (n1 Int))
-  :premises ((= (int.ispow2 v1) true) (= (> v1 1) true))
-  :args (x1 v1 n1)
-  :conclusion (= (bvurem x1 (@bv v1 n1)) (eo::define ((_let_1 (int.log2 v1))) (concat (@bv 0 (- n1 _let_1)) (extract (- _let_1 1) 0 x1))))
+(declare-rule bv-urem-pow2-not-one ((@n0 Int) (x1 (BitVec @n0)) (v1 Int) (n1 Int) (nmp1 Int) (pm1 Int))
+  :premises ((= (int.ispow2 v1) true) (= (> v1 1) true) (= nmp1 (- n1 (int.log2 v1))) (= pm1 (- (int.log2 v1) 1)))
+  :args (x1 v1 n1 nmp1 pm1)
+  :conclusion (= (bvurem x1 (@bv v1 n1)) (concat (@bv 0 nmp1) (extract pm1 0 x1)))
 )
 (declare-rule bv-urem-one ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
   :args (x1 n1)
   :conclusion (= (bvurem x1 (@bv 1 n1)) (@bv 0 n1))
 )
-(declare-rule bv-urem-self ((@n0 Int) (x1 (BitVec @n0)))
-  :args (x1)
-  :conclusion (= (bvurem x1 x1) (@bv 0 (@bvsize x1)))
+(declare-rule bv-urem-self ((@n0 Int) (x1 (BitVec @n0)) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 w1)
+  :conclusion (= (bvurem x1 x1) (@bv 0 w1))
 )
 (declare-rule bv-shl-zero ((@n0 Int) (a1 (BitVec @n0)) (n1 Int))
   :args (a1 n1)
@@ -1016,77 +1045,74 @@
   :args (a1 n1)
   :conclusion (= (bvashr (@bv 0 n1) a1) (@bv 0 n1))
 )
-(declare-rule bv-ugt-urem ((@n0 Int) (@n1 Int) (y1 (BitVec @n0)) (x1 (BitVec @n1)))
-  :args (y1 x1)
-  :conclusion (= (bvugt (bvurem y1 x1) x1) (and (= x1 (@bv 0 (@bvsize x1))) (bvugt y1 (@bv 0 (@bvsize y1)))))
+(declare-rule bv-ugt-urem ((@n0 Int) (@n1 Int) (y1 (BitVec @n0)) (x1 (BitVec @n1)) (w1 Int))
+  :premises ((= w1 (@bvsize y1)))
+  :args (y1 x1 w1)
+  :conclusion (= (bvugt (bvurem y1 x1) x1) (eo::define ((_let_1 (@bv 0 w1))) (and (= x1 _let_1) (bvugt y1 _let_1))))
 )
 (declare-rule bv-ult-one ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
   :args (x1 n1)
   :conclusion (= (bvult x1 (@bv 1 n1)) (= x1 (@bv 0 n1)))
 )
-(declare-rule bv-slt-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
-  :args (x1 n1)
-  :conclusion (= (bvslt x1 (@bv 0 n1)) (eo::define ((_let_1 (- n1 1))) (= (extract _let_1 _let_1 x1) (@bv 1 1))))
+(declare-rule bv-slt-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (nm1 Int))
+  :premises ((= nm1 (- n1 1)))
+  :args (x1 n1 nm1)
+  :conclusion (= (bvslt x1 (@bv 0 n1)) (= (extract nm1 nm1 x1) (@bv 1 1)))
 )
-(declare-rule bv-merge-sign-extend-1 ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int))
-  :args (x1 i1 j1)
-  :conclusion (= (sign_extend i1 (sign_extend j1 x1)) (sign_extend (+ i1 j1) x1))
+(declare-rule bv-merge-sign-extend-1 ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int) (k1 Int))
+  :premises ((= k1 (+ i1 j1)))
+  :args (x1 i1 j1 k1)
+  :conclusion (= (sign_extend i1 (sign_extend j1 x1)) (sign_extend k1 x1))
 )
-(declare-rule bv-merge-sign-extend-2 ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int))
-  :premises ((= (> j1 1) true))
-  :args (x1 i1 j1)
-  :conclusion (= (sign_extend i1 (zero_extend j1 x1)) (zero_extend (+ i1 j1) x1))
+(declare-rule bv-merge-sign-extend-2 ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int) (k1 Int))
+  :premises ((= (> j1 1) true) (= k1 (+ i1 j1)))
+  :args (x1 i1 j1 k1)
+  :conclusion (= (sign_extend i1 (zero_extend j1 x1)) (zero_extend k1 x1))
 )
 (declare-rule bv-merge-sign-extend-3 ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (n1 Int))
   :premises ((= n1 0))
   :args (x1 i1 n1)
   :conclusion (= (sign_extend i1 (zero_extend n1 x1)) (sign_extend i1 x1))
 )
-(declare-rule bv-sign-extend-eq-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (= (sign_extend m1 x1) (@bv c1 nm1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (@bv 0 (+ m1 1)))) (eo::define ((_let_4 (extract (- nm1 1) _let_2 _let_1))) (and (or (= _let_4 _let_3) (= _let_4 (bvnot _let_3))) (= x1 (extract _let_2 0 _let_1))))))))
-)
-(declare-rule bv-sign-extend-eq-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (= (@bv c1 nm1) (sign_extend m1 x1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (@bv 0 (+ m1 1)))) (eo::define ((_let_4 (extract (- nm1 1) _let_2 _let_1))) (and (or (= _let_4 _let_3) (= _let_4 (bvnot _let_3))) (= x1 (extract _let_2 0 _let_1))))))))
-)
-(declare-rule bv-zero-extend-eq-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (= (zero_extend m1 x1) (@bv c1 nm1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (and (= (extract (- nm1 1) _let_2 _let_1) (@bv 0 m1)) (= x1 (extract _let_2 0 _let_1))))))
-)
-(declare-rule bv-zero-extend-eq-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (= (@bv c1 nm1) (zero_extend m1 x1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (and (= (extract (- nm1 1) _let_2 _let_1) (@bv 0 m1)) (= x1 (extract _let_2 0 _let_1))))))
-)
-(declare-rule bv-zero-extend-ult-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :premises ((= (extract (- nm1 1) (@bvsize x1) (@bv c1 nm1)) (@bv 0 m1)))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (bvult (zero_extend m1 x1) (@bv c1 nm1)) (bvult x1 (extract (- (@bvsize x1) 1) 0 (@bv c1 nm1))))
-)
-(declare-rule bv-zero-extend-ult-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :premises ((= (extract (- nm1 1) (@bvsize x1) (@bv c1 nm1)) (@bv 0 m1)))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (bvult (@bv c1 nm1) (zero_extend m1 x1)) (bvult (extract (- (@bvsize x1) 1) 0 (@bv c1 nm1)) x1))
-)
-(declare-rule bv-sign-extend-ult-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :premises ((eo::define ((_let_1 (@bv (- (@bvsize x1) 1) nm1))) (eo::define ((_let_2 (@bv c1 nm1))) (= (or (bvule _let_2 (bvshl (@bv 1 nm1) _let_1)) (bvuge _let_2 (bvshl (bvnot (@bv 0 nm1)) _let_1))) true))))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (bvult (sign_extend m1 x1) (@bv c1 nm1)) (bvult x1 (extract (- (@bvsize x1) 1) 0 (@bv c1 nm1))))
-)
-(declare-rule bv-sign-extend-ult-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :premises ((= (bvult (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)) (@bv c1 nm1)) true) (= (bvule (@bv c1 nm1) (bvshl (bvnot (@bv 0 nm1)) (@bv (- (@bvsize x1) 1) nm1))) true))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (bvult (sign_extend m1 x1) (@bv c1 nm1)) (eo::define ((_let_1 (- (@bvsize x1) 1))) (= (extract _let_1 _let_1 x1) (@bv 0 1))))
-)
-(declare-rule bv-sign-extend-ult-const-3 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :premises ((eo::define ((_let_1 (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)))) (eo::define ((_let_2 (@bv c1 nm1))) (= (or (bvult _let_2 _let_1) (bvuge _let_2 (bvnot _let_1))) true))))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (bvult (@bv c1 nm1) (sign_extend m1 x1)) (bvult (extract (- (@bvsize x1) 1) 0 (@bv c1 nm1)) x1))
-)
-(declare-rule bv-sign-extend-ult-const-4 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
-  :premises ((= (bvule (bvnot (bvshl (bvnot (@bv 0 nm1)) (@bv (- (@bvsize x1) 1) nm1))) (@bv c1 nm1)) true) (= (bvule (@bv c1 nm1) (bvnot (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)))) true))
-  :args (x1 m1 c1 nm1)
-  :conclusion (= (bvult (@bv c1 nm1) (sign_extend m1 x1)) (eo::define ((_let_1 (- (@bvsize x1) 1))) (= (extract _let_1 _let_1 x1) (@bv 1 1))))
+(declare-rule bv-sign-extend-eq-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int) (mp1 Int) (nm2 Int) (nmm1 Int))
+  :premises ((= mp1 (+ m1 1)) (= nm2 (- (@bvsize x1) 1)) (= nmm1 (- nm1 1)))
+  :args (x1 m1 c1 nm1 mp1 nm2 nmm1)
+  :conclusion (= (= (sign_extend m1 x1) (@bv c1 nm1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (@bv 0 mp1))) (eo::define ((_let_3 (extract nmm1 nm2 _let_1))) (and (or (= _let_3 _let_2) (= _let_3 (bvnot _let_2))) (= x1 (extract nm2 0 _let_1)))))))
+)
+(declare-rule bv-sign-extend-eq-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int) (mp1 Int) (nm2 Int) (nmm1 Int))
+  :premises ((= mp1 (+ m1 1)) (= nm2 (- (@bvsize x1) 1)) (= nmm1 (- nm1 1)))
+  :args (x1 m1 c1 nm1 mp1 nm2 nmm1)
+  :conclusion (= (= (@bv c1 nm1) (sign_extend m1 x1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (@bv 0 mp1))) (eo::define ((_let_3 (extract nmm1 nm2 _let_1))) (and (or (= _let_3 _let_2) (= _let_3 (bvnot _let_2))) (= x1 (extract nm2 0 _let_1)))))))
+)
+(declare-rule bv-zero-extend-eq-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int) (nm2 Int) (nmm1 Int))
+  :premises ((= nm2 (- (@bvsize x1) 1)) (= nmm1 (- nm1 1)))
+  :args (x1 m1 c1 nm1 nm2 nmm1)
+  :conclusion (= (= (zero_extend m1 x1) (@bv c1 nm1)) (eo::define ((_let_1 (@bv c1 nm1))) (and (= (extract nmm1 nm2 _let_1) (@bv 0 m1)) (= x1 (extract nm2 0 _let_1)))))
+)
+(declare-rule bv-zero-extend-eq-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int) (nm2 Int) (nmm1 Int))
+  :premises ((= nm2 (- (@bvsize x1) 1)) (= nmm1 (- nm1 1)))
+  :args (x1 m1 c1 nm1 nm2 nmm1)
+  :conclusion (= (= (@bv c1 nm1) (zero_extend m1 x1)) (eo::define ((_let_1 (@bv c1 nm1))) (and (= (extract nmm1 nm2 _let_1) (@bv 0 m1)) (= x1 (extract nm2 0 _let_1)))))
+)
+(declare-rule bv-sign-extend-ult-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int) (nm2 Int))
+  :premises ((eo::define ((_let_1 (@bv (- (@bvsize x1) 1) nm1))) (eo::define ((_let_2 (@bv c1 nm1))) (= (or (bvule _let_2 (bvshl (@bv 1 nm1) _let_1)) (bvuge _let_2 (bvshl (bvnot (@bv 0 nm1)) _let_1))) true))) (= nm2 (- (@bvsize x1) 1)))
+  :args (x1 m1 c1 nm1 nm2)
+  :conclusion (= (bvult (sign_extend m1 x1) (@bv c1 nm1)) (bvult x1 (extract nm2 0 (@bv c1 nm1))))
+)
+(declare-rule bv-sign-extend-ult-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int) (nm2 Int))
+  :premises ((= (bvult (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)) (@bv c1 nm1)) true) (= (bvule (@bv c1 nm1) (bvshl (bvnot (@bv 0 nm1)) (@bv (- (@bvsize x1) 1) nm1))) true) (= nm2 (- (@bvsize x1) 1)))
+  :args (x1 m1 c1 nm1 nm2)
+  :conclusion (= (bvult (sign_extend m1 x1) (@bv c1 nm1)) (= (extract nm2 nm2 x1) (@bv 0 1)))
+)
+(declare-rule bv-sign-extend-ult-const-3 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int) (nm2 Int))
+  :premises ((eo::define ((_let_1 (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)))) (eo::define ((_let_2 (@bv c1 nm1))) (= (or (bvult _let_2 _let_1) (bvuge _let_2 (bvnot _let_1))) true))) (= nm2 (- (@bvsize x1) 1)))
+  :args (x1 m1 c1 nm1 nm2)
+  :conclusion (= (bvult (@bv c1 nm1) (sign_extend m1 x1)) (bvult (extract nm2 0 (@bv c1 nm1)) x1))
+)
+(declare-rule bv-sign-extend-ult-const-4 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int) (nm2 Int))
+  :premises ((= (bvule (bvnot (bvshl (bvnot (@bv 0 nm1)) (@bv (- (@bvsize x1) 1) nm1))) (@bv c1 nm1)) true) (= (bvule (@bv c1 nm1) (bvnot (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)))) true) (= nm2 (- (@bvsize x1) 1)))
+  :args (x1 m1 c1 nm1 nm2)
+  :conclusion (= (bvult (@bv c1 nm1) (sign_extend m1 x1)) (= (extract nm2 nm2 x1) (@bv 1 1)))
 )
 (declare-rule sets-eq-singleton-emp ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 @T1))
   :premises ((= (set.is_empty x1) true))
@@ -1757,7 +1783,8 @@
   :args (t1 s1)
   :conclusion (= (distinct t1 s1) (not (= t1 s1)))
 )
-(declare-rule uf-bv2nat-geq-elim ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
-  :args (x1 n1)
-  :conclusion (= (>= (bv2nat x1) n1) (eo::define ((_let_1 (@bvsize x1))) (ite (>= n1 _let_1) false (ite (< n1 0) true (bvuge x1 (int2bv _let_1 n1))))))
+(declare-rule uf-bv2nat-geq-elim ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (w1 Int))
+  :premises ((= w1 (@bvsize x1)))
+  :args (x1 n1 w1)
+  :conclusion (= (>= (bv2nat x1) n1) (ite (>= n1 w1) false (ite (< n1 0) true (bvuge x1 (int2bv w1 n1)))))
 )
diff --git a/proofs/eo/cpc/theories/BitVectors.eo b/proofs/eo/cpc/theories/BitVectors.eo
index 434ad1c13..258365b13 100644
--- a/proofs/eo/cpc/theories/BitVectors.eo
+++ b/proofs/eo/cpc/theories/BitVectors.eo
@@ -16,19 +16,6 @@
 ; bvsize
 (declare-const @bvsize (-> (! Int :var m :implicit) (BitVec m) Int))
 
-; evaluator for terms that may impact the type of nodes
-(program $eval_bv_sym ((S Type) (T Type) (f (-> T S)) (x S) (ys S :list) (z S) (y T) (m Int) (xb (BitVec m)))
-    (S) S
-    (
-    (($eval_bv_sym (+ x ys))     ($arith_eval_add ($eval_bv_sym x) ($eval_bv_sym ys)))
-    (($eval_bv_sym (- x z))      ($arith_eval_sub ($eval_bv_sym x) ($eval_bv_sym z)))
-    (($eval_bv_sym (@bvsize xb)) ($bv_bitwidth (eo::typeof xb)))
-    (($eval_bv_sym (int.log2 x)) ($arith_eval_int_log_2 ($eval_bv_sym x)))
-    (($eval_bv_sym (mod x z))    (eo::zmod ($eval_bv_sym x) ($eval_bv_sym z)))
-    (($eval_bv_sym x)            x)
-    )
-)
-
 ; define: @bv_empty
 ; return: The empty bitvector.
 (define @bv_empty () (eo::to_bin 0 0))
@@ -41,25 +28,20 @@
   (BitVec (eo::add n m))) :right-assoc-nil @bv_empty
 )
 
-; disclaimer: >
-;   The type of this function currently permits evaluatable terms as
-;   indices to support RARE.
 (declare-const extract (->
   (! Int :var n :implicit)
   (! Int :var h)
   (! Int :var l)
   (BitVec n)
-  (BitVec (eo::add ($eval_bv_sym h) (eo::neg ($eval_bv_sym l)) 1)))
+  (BitVec (eo::add h (eo::neg l) 1))
+  )
 )
 
-; disclaimer: >
-;   The type of this function currently permits evaluatable terms as
-;   indices to support RARE.
 (declare-const repeat 
     (-> (! Int :var n :implicit)
         (! Int :var i)
         (BitVec n)
-        (BitVec (eo::mul ($eval_bv_sym i) n))
+        (BitVec (eo::mul i n))
     ) 
 )
 
@@ -219,13 +201,10 @@
     (BitVec m) (BitVec m) (BitVec m))
 )
 
-; disclaimer: >
-;   The type of this function currently permits evaluatable terms as
-;   indices to support RARE.
 (declare-const zero_extend
     (-> (! Int :var m :implicit)
         (! Int :var i)
-        (BitVec m) (BitVec (eo::add m ($eval_bv_sym i))))
+        (BitVec m) (BitVec (eo::add m i)))
 )
 
 ; disclaimer: >
@@ -234,7 +213,7 @@
 (declare-const sign_extend
     (-> (! Int :var m :implicit)
         (! Int :var i)
-        (BitVec m) (BitVec (eo::add m ($eval_bv_sym i))))
+        (BitVec m) (BitVec (eo::add m i)))
 )
 
 (declare-const rotate_left
@@ -353,7 +332,7 @@
 ;   indices to support RARE.
 (declare-const int2bv (->
   (! Int :var w)
-  Int (BitVec ($eval_bv_sym w)))
+  Int (BitVec w))
 )
 
 ; disclaimer: >
@@ -380,7 +359,4 @@
 )
 
 ; symbolic constant
-; disclaimer: >
-;   The type of this function currently permits evaluatable terms as
-;   indices to support RARE.
-(declare-const @bv (-> Int (! Int :var w) (BitVec ($eval_bv_sym w))))
+(declare-const @bv (-> Int (! Int :var w) (BitVec w)))
diff --git a/src/rewriter/README.md b/src/rewriter/README.md
index cd7456365..63ed7eee4 100644
--- a/src/rewriter/README.md
+++ b/src/rewriter/README.md
@@ -44,6 +44,24 @@ The match expression is purely syntactic and only syntactically identical terms
 can be matched.  For example `(= (str.++ x1 x2) x2)`matches `a ++ b = b` but not
 `a ++ b = c`.
 
+### Indexed operators
+
+In RARE, it is possible to define rewrites over indexed operators. For example:
+
+``` lisp
+(define-cond-rule bv-extract-whole
+  ((x ?BitVec) (n Int))
+  (>= n (- (@bvsize x) 1))
+  (extract n 0 x)
+  x)
+```
+
+Note that we use the syntax e.g. `(extract n m x)` to denote the result of
+extracting the bits `n` to `m` (inclusive) of `x`, whereas in SMT-LIB version
+2.6, this must be written `((_ extract n m) x)`.
+We require that terms that appear in index positions, e.g. the first and second
+argument positions of an extract must either be variables or values.
+
 ### Definition List
 
 An optional *definition list* may appear immediately after the parameter list to
@@ -56,19 +74,30 @@ expression which only exists in the outermost layer.
 
 All used variables in match and target must show up in the parameters list and
 `def` list, variables in the parameter list must be covered by the variables in
-match. Any unmatched variable will lead to an error.
+match. We also permit unmatched variables `x` to occur if they also occur in a
+condition of the form `(= x t)` where the free variables of `t` are each
+matched. For example:
 
 ``` lisp
-(define-rule bv-sign-extend-eliminate
-	((x ?BitVec) (n Int))
+(define-cond-rule bv-sign-extend-eliminate
+	((x ?BitVec) (n Int) (sn Int))
 	(def (s (bvsize x)))
+	(= sn (- s 1))
 	(sign_extend n x)
-	(concat (repeat n (extract (- s 1) (- s 1) x)) x))
+	(concat (repeat n (extract sn sn x)) x))
 ```
 
 In the above example, every instance of `s` will be replaced by `bvsize x` when
 the rewrite rule is compiled.
 
+Although `sn` does not occur on the left hand side of the rewrite rule, it
+does occur in the condition `(= sn (- s 1))`, which after compiling away `s`
+contains only the variable `x` on the right hand side, which is contained in
+the term to match.
+
+Otherwise, any unmatched variable not appearing in a condition of this form
+ will lead to an error.
+
 ### Conditional Rules
 
 In `define-cond-rule`, an additional expression immediately after the parameter
@@ -77,10 +106,10 @@ evaluable at the time of rule application.
 
 ``` lisp
 (define-cond-rule bv-repeat-eliminate-1
-	((x ?BitVec) (n Int))
-	(> n 1)
+	((x ?BitVec) (n Int) (nm1 Int))
+	(and (> n 1) (= nm1 (- n 1)))
 	(repeat n x)
-	(concat x (repeat (- n 1) x)))
+	(concat x (repeat nm1 x)))
 ```
 
 This rule is applied on `(repeat 3 ...)` but not `(repeat 1 ...)`.
@@ -95,10 +124,11 @@ The type checker will automatically ensure the expressions entering the
 reconstruction algorithms have sound types.
 
 ``` lisp
-(define-rule bv-extract-extract
-  ((x ?BitVec) (i Int) (j Int) (k Int) (l Int))
+(define-cond-rule bv-extract-extract
+  ((x ?BitVec) (i Int) (j Int) (k Int) (l Int) (il Int) (ik Int))
+  (and (= il (+ i l)) (= ik (+ i k)))
   (extract l k (extract j i x))
-  (extract (+ i l) (+ i k) x))
+  (extract il ik x))
 ```
 
 ### List Modifier
@@ -190,11 +220,11 @@ shared across the condition, match, and target terms.
 
 ``` lisp
 (define-cond-rule bv-udiv-pow2-1p
-  ((x ?BitVec) (v Int) (n Int))
+  ((x ?BitVec) (v Int) (n Int) (nm1 Int))
   (def (power (int.log2 v)))
-  (and (int.ispow2 v) (> v 1))
+  (and (int.ispow2 v) (> v 1) (= nm1 (- n 1)))
   (bvudiv x (bv v n))
-  (concat (bv 0 power) (extract (- n 1) power x)))
+  (concat (bv 0 power) (extract nm1 power x)))
 ```
 
 ### Gradual Types
diff --git a/src/theory/bv/rewrites b/src/theory/bv/rewrites
index bc6dbc7ad..ccca3b9ee 100644
--- a/src/theory/bv/rewrites
+++ b/src/theory/bv/rewrites
@@ -18,10 +18,12 @@
   (concat xs (extract k i s) ys))
 
 ; x[i..j][k..l] = x[i+k..i+l]
-(define-rule* bv-extract-extract
-  ((x ?BitVec) (i Int) (j Int) (k Int) (l Int))
+; note: could be fixed-point but we don't permit conditional fixed point
+(define-cond-rule bv-extract-extract
+  ((x ?BitVec) (i Int) (j Int) (k Int) (l Int) (ll Int) (kk Int))
+  (and (= ll (+ i l)) (= kk (+ i k)))
   (extract l k (extract j i x))
-  (extract (+ i l) (+ i k) x))
+  (extract ll kk x))
 (define-cond-rule bv-extract-whole
   ((x ?BitVec) (n Int))
   (>= n (- (@bvsize x) 1))
@@ -35,21 +37,20 @@
   (extract j i (concat xs y x)) ; (concat ...) needs at least 2 children
   (extract j i x))
 ; Case 2: (< i n) but (>= j n), the extract crosses the boundary into the next one.
-; Note that we do not know the size of the element after x, so we leave it in (extract (concat ...)) form
+; Note that we do not know the size of the element after x, so we leave it in (extract ... (concat ...)) form
 (define-cond-rule bv-extract-concat-2
-  ((x ?BitVec) (xs ?BitVec :list) (y ?BitVec)
-  (i Int) (j Int))
-  (and (< i (@bvsize x)) (>= j (@bvsize x)))
+  ((x ?BitVec) (xs ?BitVec :list) (y ?BitVec) (i Int) (j Int) (u1 Int) (u2 Int))
+  (and (< i (@bvsize x)) (>= j (@bvsize x)) (= u1 (- j (@bvsize x))) (= u2 (- (@bvsize x) 1)))
   (extract j i (concat xs y x))
   (concat
-    (extract (- j (@bvsize x)) 0 (concat xs y))
-    (extract (- (@bvsize x) 1) i x)))
+    (extract u1 0 (concat xs y))
+    (extract u2 i x)))
 ; Case 3: (>= i n) and (>= j n), extract elides x
 (define-cond-rule bv-extract-concat-3
-  ((x ?BitVec) (y ?BitVec) (xs ?BitVec :list) (i Int) (j Int))
-  (>= i (@bvsize x))
+  ((x ?BitVec) (y ?BitVec) (xs ?BitVec :list) (i Int) (j Int) (u2 Int) (l2 Int))
+  (and (>= i (@bvsize x)) (= u2 (- j (@bvsize x))) (= l2 (- i (@bvsize x))))
   (extract j i (concat xs y x))
-  (extract (- j (@bvsize x)) (- i (@bvsize x)) (concat xs y)))
+  (extract u2 l2 (concat xs y)))
 ; Case 4: Elision from the higher portion
 (define-cond-rule bv-extract-concat-4
   ((x ?BitVec) (y ?BitVec) (xs ?BitVec :list) (i Int) (j Int))
@@ -81,19 +82,19 @@
   (extract high low (sign_extend k x))
   (extract high low x))
 (define-cond-rule bv-extract-sign-extend-2
-  ((x ?BitVec) (low Int) (high Int) (k Int))
+  ((x ?BitVec) (low Int) (high Int) (k Int) (nm1 Int) (sn Int))
   (def (n (@bvsize x)))
-  (and (< low n) (>= high n))
+  (and (< low n) (>= high n) (= nm1 (- n 1)) (= sn (+ 1 (- high n))))
   (extract high low (sign_extend k x))
   (sign_extend
-    (+ 1 (- high n))
-    (extract (- n 1) low x)))
+    sn
+    (extract nm1 low x)))
 (define-cond-rule bv-extract-sign-extend-3
-  ((x ?BitVec) (low Int) (high Int) (k Int))
+  ((x ?BitVec) (low Int) (high Int) (k Int) (rn Int) (nm1 Int))
   (def (n (@bvsize x)))
-  (>= low n)
+  (and (>= low n) (= rn (+ 1 (- high low))) (= nm1 (- n 1)))
   (extract high low (sign_extend k x))
-  (repeat (+ 1 (- high low)) (extract (- n 1) (- n 1) x)))
+  (repeat rn (extract nm1 nm1 x)))
 
 (define-rule bv-neg-mult
   ((xs ?BitVec) (ys ?BitVec) (n Int) (m Int))
@@ -141,19 +142,21 @@
   ((xs ?BitVec :list) (ys ?BitVec :list) (zs ?BitVec :list) (x ?BitVec))
   (bvand xs x ys x zs)
   (bvand xs x ys zs))
-(define-rule bv-and-simplify-2
-  ((xs ?BitVec :list) (ys ?BitVec :list) (zs ?BitVec :list) (x ?BitVec))
+(define-cond-rule bv-and-simplify-2
+  ((xs ?BitVec :list) (ys ?BitVec :list) (zs ?BitVec :list) (x ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvand xs x ys (bvnot x) zs)
-  (@bv 0 (@bvsize x)))
+  (@bv 0 w))
 
 (define-rule* bv-or-simplify-1
   ((xs ?BitVec :list) (ys ?BitVec :list) (zs ?BitVec :list) (x ?BitVec))
   (bvor xs x ys x zs)
   (bvor xs x ys zs))
-(define-rule bv-or-simplify-2
-  ((xs ?BitVec :list) (ys ?BitVec :list) (zs ?BitVec :list) (x ?BitVec))
+(define-cond-rule bv-or-simplify-2
+  ((xs ?BitVec :list) (ys ?BitVec :list) (zs ?BitVec :list) (x ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvor xs x ys (bvnot x) zs)
-  (bvnot (@bv 0 (@bvsize x))))
+  (bvnot (@bv 0 w)))
 
 (define-rule* bv-xor-simplify-1
   ((xs ?BitVec :list) (ys ?BitVec :list) (zs ?BitVec :list) (x ?BitVec))
@@ -172,24 +175,21 @@
 
 ; x < y + 1 <=> (not y < x) and y != 1...1
 (define-cond-rule bv-ult-add-one
-  ((x ?BitVec) (y ?BitVec) (c1 ?BitVec))
-  (= c1 (@bv 1 (@bvsize c1)))
+  ((x ?BitVec) (y ?BitVec) (c1 ?BitVec) (w Int))
+  (and (= c1 (@bv 1 w)) (= w (@bvsize y)))
   (bvult x (bvadd y c1))
   (and
     (not (bvult y x))
-    (not (= y (bvnot (@bv 0 (@bvsize y)))))))
+    (not (= y (bvnot (@bv 0 w))))))
 (define-cond-rule bv-concat-to-mult
-  ((x ?BitVec) (i Int) (m Int) (n0 Int))
-  (and (= (+ 1 i m) (@bvsize x)) (= n0 0))
+  ((x ?BitVec) (i Int) (m Int) (n0 Int) (w Int))
+  (and (= (+ 1 i m) (@bvsize x)) (= n0 0) (= w (@bvsize x)))
   (concat (extract i n0 x) (@bv n0 m))
-  (bvmul x (bvshl (@bv 1 (@bvsize x)) (@bv m (@bvsize x)))))
+  (bvmul x (bvshl (@bv 1 w) (@bv m w))))
 
-(define-rule bv-mult-slt-mult-1
-  ((x ?BitVec) (t ?BitVec) (a ?BitVec) (n Int) (m Int))
-  (def
-    (tn (@bvsize t))
-    (an (@bvsize a))
-  )
+(define-cond-rule bv-mult-slt-mult-1
+  ((x ?BitVec) (t ?BitVec) (a ?BitVec) (n Int) (m Int) (tn Int) (an Int))
+  (and (= tn (@bvsize t)) (= an (@bvsize a)))
   (bvslt
     (bvmul (sign_extend n (bvadd x t)) (sign_extend m a))
     (bvmul (sign_extend n x) (sign_extend m a))
@@ -198,12 +198,9 @@
     (not (= t (@bv 0 tn)))
     (not (= a (@bv 0 an)))
     (= (bvslt (bvadd x t) x) (bvsgt a (@bv 0 an)))))
-(define-rule bv-mult-slt-mult-2
-  ((x ?BitVec) (t ?BitVec) (a ?BitVec) (n Int) (m Int))
-  (def
-    (tn (@bvsize t))
-    (an (@bvsize a))
-  )
+(define-cond-rule bv-mult-slt-mult-2
+  ((x ?BitVec) (t ?BitVec) (a ?BitVec) (n Int) (m Int) (tn Int) (an Int))
+  (and (= tn (@bvsize t)) (= an (@bvsize a)))
   (bvslt
     (bvmul (zero_extend n (bvadd x t)) (sign_extend m a))
     (bvmul (zero_extend n x) (sign_extend m a))
@@ -229,21 +226,22 @@
 (define-rule bv-or-zero ((x ?BitVec) (n Int))
   (bvor x (@bv 0 n))
   x)
-(define-cond-rule bv-mul-one ((x ?BitVec) (c1 ?BitVec))
-  (= c1 (@bv 1 (@bvsize c1)))
-  (bvmul x c1)
+(define-cond-rule bv-mul-one ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
+  (bvmul x (@bv 1 w))
   x)
-(define-cond-rule bv-mul-zero ((x ?BitVec) (c0 ?BitVec))
-  (= c0 (@bv 0 (@bvsize c0)))
-  (bvmul x c0)
-  (@bv 0 (@bvsize x)))
-(define-cond-rule bv-add-zero ((x ?BitVec) (c0 ?BitVec))
-  (= c0 (@bv 0 (@bvsize c0)))
-  (bvadd x c0)
+(define-cond-rule bv-mul-zero ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
+  (bvmul x (@bv 0 w))
+  (@bv 0 w))
+(define-cond-rule bv-add-zero ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
+  (bvadd x (@bv 0 w))
   x)
-(define-rule bv-add-two ((x ?BitVec))
+(define-cond-rule bv-add-two ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvadd x x)
-  (bvmul x (@bv 2 (@bvsize x))))
+  (bvmul x (@bv 2 w)))
 
 
 (define-rule bv-zero-extend-eliminate-0
@@ -259,10 +257,10 @@
   (= x (bvnot x))
   false)
 
-(define-cond-rule bv-ult-ones ((x ?BitVec) (y ?BitVec))
-  (= y (bvnot (@bv 0 (@bvsize y))))
-  (bvult x y)
-  (distinct x y))
+(define-cond-rule bv-ult-ones ((x ?BitVec) (n Int) (w Int))
+  (= n (- (int.pow2 w) 1))
+  (bvult x (@bv n w))
+  (distinct x (@bv n w)))
 
 ; Collapse rules
 
@@ -295,12 +293,13 @@
   (bvmul xs (bvmul s ys) zs)
   (bvmul xs s ys zs))
 
-(define-rule* bv-concat-merge-const
+(define-cond-rule bv-concat-merge-const
   ((xs ?BitVec :list)
-   (n1 Int) (w1 Int) (n2 Int) (w2 Int)
+   (n1 Int) (w1 Int) (n2 Int) (w2 Int) (ww Int)
    (zs ?BitVec :list))
+  (= ww (+ w1 w2))
   (concat xs (@bv n1 w1) (@bv n2 w2) zs)
-  (concat xs (@bv (+ (* n1 (int.pow2 w2)) n2) (+ w1 w2)) zs))
+  (concat xs (@bv (+ (* n1 (int.pow2 w2)) n2) ww) zs))
 
 ; These rules should be subsumed by ARITH_POLY_NORM, but removing them increases the number of holes
 (define-rule bv-commutative-add ((x ?BitVec) (y ?BitVec))
diff --git a/src/theory/bv/rewrites-elimination b/src/theory/bv/rewrites-elimination
index 79fb0fed5..acab4d543 100644
--- a/src/theory/bv/rewrites-elimination
+++ b/src/theory/bv/rewrites-elimination
@@ -16,9 +16,10 @@
   ((x ?BitVec) (y ?BitVec))
   (bvsge x y)
   (bvsle y x))
-(define-rule bv-slt-eliminate
-  ((x ?BitVec) (y ?BitVec))
-  (def (pad (bvshl (@bv 1 (@bvsize x)) (@bv (- (@bvsize x) 1) (@bvsize x)))))
+(define-cond-rule bv-slt-eliminate
+  ((x ?BitVec) (y ?BitVec) (w Int))
+  (def (pad (bvshl (@bv 1 w) (@bv (- (@bvsize x) 1) w))))
+  (= w (@bvsize x))
   (bvslt x y)
   (bvult
     (bvadd x pad)
@@ -29,14 +30,16 @@
   (bvsle x y)
   (not (bvslt y x)))
 
-(define-rule bv-redor-eliminate
-  ((x ?BitVec))
+(define-cond-rule bv-redor-eliminate
+  ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvredor x)
-  (bvnot (bvcomp x (@bv 0 (@bvsize x)))))
-(define-rule bv-redand-eliminate
-  ((x ?BitVec))
+  (bvnot (bvcomp x (@bv 0 w))))
+(define-cond-rule bv-redand-eliminate
+  ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvredand x)
-  (bvcomp x (bvnot (@bv 0 (@bvsize x)))))
+  (bvcomp x (bvnot (@bv 0 w))))
 
 (define-rule bv-ule-eliminate
   ((x ?BitVec) (y ?BitVec))
@@ -47,10 +50,10 @@
   (bvcomp x y)
   (ite (= x y) (@bv 1 1) (@bv 0 1)))
 (define-cond-rule bv-repeat-eliminate-1
-  ((x ?BitVec) (n Int))
-  (> n 1)
+  ((x ?BitVec) (n Int) (nm1 Int))
+  (and (> n 1) (= nm1 (- n 1)))
   (repeat n x)
-  (concat x (repeat (- n 1) x)))
+  (concat x (repeat nm1 x)))
 (define-cond-rule bv-repeat-eliminate-2
   ((x ?BitVec) (n Int))
   (= n 1)
@@ -58,26 +61,26 @@
   x)
 
 (define-cond-rule bv-rotate-left-eliminate-1
-  ((x ?BitVec) (amount Int))
+  ((x ?BitVec) (amount Int) (u1 Int) (u2 Int) (l2 Int))
   (def (n (@bvsize x)) (a (mod amount n)))
-  (not (= a 0))
+  (and (not (= a 0)) (= u1 (- n (+ 1 a))) (= u2 (- n 1)) (= l2 (- n a)))
   (rotate_left amount x)
   (concat
-    (extract (- n (+ 1 a)) 0 x)
-    (extract (- n 1) (- n a) x)))
+    (extract u1 0 x)
+    (extract u2 l2 x)))
 (define-cond-rule bv-rotate-left-eliminate-2
   ((x ?BitVec) (amount Int))
   (= (mod amount (@bvsize x)) 0)
   (rotate_left amount x)
   x)
 (define-cond-rule bv-rotate-right-eliminate-1
-  ((x ?BitVec) (amount Int))
+  ((x ?BitVec) (amount Int) (u1 Int) (u2 Int) (l2 Int))
   (def (n (@bvsize x)) (a (mod amount n)))
-  (not (= a 0))
+  (and (not (= a 0)) (= u1 (- a 1)) (= u2 (- n 1)) (= l2 a))
   (rotate_right amount x)
   (concat
-    (extract (- a 1) 0 x)
-    (extract (- n 1) a x)))
+    (extract u1 0 x)
+    (extract u2 l2 x)))
 (define-cond-rule bv-rotate-right-eliminate-2
   ((x ?BitVec) (amount Int))
   (= (mod amount (@bvsize x)) 0)
@@ -97,24 +100,24 @@
   (bvxnor x y)
   (bvnot (bvxor x y)))
 
-(define-rule bv-sdiv-eliminate
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-sdiv-eliminate
+  ((x ?BitVec) (y ?BitVec) (nm1 Int))
   (def
-    (n (@bvsize x))
-    (xLt0 (= (extract (- n 1) (- n 1) x) (@bv 1 1)))
-    (yLt0 (= (extract (- n 1) (- n 1) y) (@bv 1 1)))
+    (xLt0 (= (extract nm1 nm1 x) (@bv 1 1)))
+    (yLt0 (= (extract nm1 nm1 y) (@bv 1 1)))
     (rUdiv (bvudiv (ite xLt0 (bvneg x) x) (ite yLt0 (bvneg y) y)))
   )
+  (= nm1 (- (@bvsize x) 1))
   (bvsdiv x y)
   (ite (xor xLt0 yLt0) (bvneg rUdiv) rUdiv))
-(define-rule bv-sdiv-eliminate-fewer-bitwise-ops
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-sdiv-eliminate-fewer-bitwise-ops
+  ((x ?BitVec) (y ?BitVec) (nm1 Int))
   (def
-    (n (@bvsize x))
-    (xLt0 (bvuge x (concat (@bv 1 1) (@bv 0 (- n 1)))))
-    (yLt0 (bvuge y (concat (@bv 1 1) (@bv 0 (- n 1)))))
+    (xLt0 (bvuge x (concat (@bv 1 1) (@bv 0 nm1))))
+    (yLt0 (bvuge y (concat (@bv 1 1) (@bv 0 nm1))))
     (rUdiv (bvudiv (ite xLt0 (bvneg x) x) (ite yLt0 (bvneg y) y)))
   )
+  (= nm1 (- (@bvsize x) 1))
   (bvsdiv x y)
   (ite (xor xLt0 yLt0) (bvneg rUdiv) rUdiv))
 
@@ -122,51 +125,53 @@
   ((x ?BitVec) (n Int))
   (zero_extend n x)
   (concat (@bv 0 n) x))
-(define-rule bv-sign-extend-eliminate
-  ((x ?BitVec) (n Int))
-  (def (s (@bvsize x)))
+(define-cond-rule bv-sign-extend-eliminate
+  ((x ?BitVec) (n Int) (wm1 Int))
+  (= wm1 (- (@bvsize x) 1))
   (sign_extend n x)
-  (concat (repeat n (extract (- s 1) (- s 1) x)) x))
+  (concat (repeat n (extract wm1 wm1 x)) x))
 
-(define-rule bv-uaddo-eliminate
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-uaddo-eliminate
+  ((x ?BitVec) (y ?BitVec) (wm1 Int))
+  (= wm1 (- (@bvsize x) 1))
   (bvuaddo x y)
-  (= (extract (- (@bvsize x) 1) (- (@bvsize x) 1)
+  (= (extract wm1 wm1
       (bvadd (concat (@bv 0 1) x) (concat (@bv 0 1) y)))
     (@bv 1 1)
   ))
-(define-rule bv-saddo-eliminate
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-saddo-eliminate
+  ((x ?BitVec) (y ?BitVec) (wm1 Int))
   (def
-    (n (@bvsize x))
-    (xS (extract (- n 1) (- n 1) x))
-    (yS (extract (- n 1) (- n 1) y))
-    (aS (extract (- n 1) (- n 1) (bvadd x y)))
+    (xS (extract wm1 wm1 x))
+    (yS (extract wm1 wm1 y))
+    (aS (extract wm1 wm1 (bvadd x y)))
   )
+  (= wm1 (- (@bvsize x) 1))
   (bvsaddo x y)
   (or
     (and (and (= xS (@bv 0 1)) (= yS (@bv 0 1))) (= aS (@bv 1 1)))
     (and (and (= xS (@bv 1 1)) (= yS (@bv 1 1))) (= aS (@bv 0 1)))
   ))
-(define-rule bv-sdivo-eliminate
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-sdivo-eliminate
+  ((x ?BitVec) (y ?BitVec) (w Int) (wm1 Int))
+  (and (= wm1 (- (@bvsize x) 1)) (= w (@bvsize y)))
   (bvsdivo x y)
   (and
-    (= x (concat (@bv 1 1) (@bv 0 (- (@bvsize x) 1))))
-    (= y (bvnot (@bv 0 (@bvsize y))))
+    (= x (concat (@bv 1 1) (@bv 0 wm1)))
+    (= y (bvnot (@bv 0 w)))
   ))
-(define-rule bv-smod-eliminate
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-smod-eliminate
+  ((x ?BitVec) (y ?BitVec) (w Int) (wm1 Int))
   (def
-    (n (@bvsize x))
-    (xLt0 (= (extract (- n 1) (- n 1) x) (@bv 1 1)))
-    (yLt0 (= (extract (- n 1) (- n 1) y) (@bv 1 1)))
+    (xLt0 (= (extract wm1 wm1 x) (@bv 1 1)))
+    (yLt0 (= (extract wm1 wm1 y) (@bv 1 1)))
     (xAbs (ite xLt0 (bvneg x) x))
     (yAbs (ite yLt0 (bvneg y) y))
     (u (bvurem xAbs yAbs))
   )
+  (and (= w (@bvsize x)) (= wm1 (- (@bvsize x) 1)))
   (bvsmod x y)
-  (ite (= u (@bv 0 n))
+  (ite (= u (@bv 0 w))
     u
     (ite (and (not xLt0) (not yLt0))
       u
@@ -175,18 +180,18 @@
         (ite (and (not xLt0) yLt0)
           (bvadd u y)
           (bvneg u))))))
-(define-rule bv-smod-eliminate-fewer-bitwise-ops
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-smod-eliminate-fewer-bitwise-ops
+  ((x ?BitVec) (y ?BitVec) (w Int) (wm1 Int))
   (def
-    (n (@bvsize x))
-    (xLt0 (bvuge x (concat (@bv 1 1) (@bv 0 (- n 1)))))
-    (yLt0 (bvuge y (concat (@bv 1 1) (@bv 0 (- n 1)))))
+    (xLt0 (bvuge x (concat (@bv 1 1) (@bv 0 wm1))))
+    (yLt0 (bvuge y (concat (@bv 1 1) (@bv 0 wm1))))
     (xAbs (ite xLt0 (bvneg x) x))
     (yAbs (ite yLt0 (bvneg y) y))
     (u (bvurem xAbs yAbs))
   )
+  (and (= w (@bvsize x)) (= wm1 (- (@bvsize x) 1)))
   (bvsmod x y)
-  (ite (= u (@bv 0 n))
+  (ite (= u (@bv 0 w))
     u
     (ite (and (not xLt0) (not yLt0))
       u
@@ -196,51 +201,52 @@
           (bvadd u y)
           (bvneg u))))))
 
-(define-rule bv-srem-eliminate
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-srem-eliminate
+  ((x ?BitVec) (y ?BitVec) (nm1 Int))
   (def
-    (n (@bvsize x))
-    (xLt0 (extract (- n 1) (- n 1) x))
-    (yLt0 (extract (- n 1) (- n 1) y))
+    (xLt0 (extract nm1 nm1 x))
+    (yLt0 (extract nm1 nm1 y))
     (xAbs (bvite xLt0 (bvneg x) x))
     (yAbs (bvite yLt0 (bvneg y) y))
     (u (bvurem xAbs yAbs))
   )
+  (= nm1 (- (@bvsize x) 1))
   (bvsrem x y)
   (bvite xLt0 (bvneg u) u))
-(define-rule bv-srem-eliminate-fewer-bitwise-ops
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-srem-eliminate-fewer-bitwise-ops
+  ((x ?BitVec) (y ?BitVec) (nm1 Int))
   (def
-    (n (@bvsize x))
-    (xLt0 (bvuge x (concat (@bv 1 1) (@bv 0 (- n 1)))))
-    (yLt0 (bvuge y (concat (@bv 1 1) (@bv 0 (- n 1)))))
+    (xLt0 (bvuge x (concat (@bv 1 1) (@bv 0 nm1))))
+    (yLt0 (bvuge y (concat (@bv 1 1) (@bv 0 nm1))))
     (xAbs (ite xLt0 (bvneg x) x))
     (yAbs (ite yLt0 (bvneg y) y))
     (u (bvurem xAbs yAbs))
   )
+  (= nm1 (- (@bvsize x) 1))
   (bvsrem x y)
   (ite xLt0 (bvneg u) u))
 
-(define-rule bv-usubo-eliminate
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-usubo-eliminate
+  ((x ?BitVec) (y ?BitVec) (n Int))
   (def
-    (n (@bvsize x))
     (s (bvsub (zero_extend 1 x) (zero_extend 1 y)))
   )
+  (= n (@bvsize x))
   (bvusubo x y)
   (= (extract n n s) (@bv 1 1)))
 ; Overflow occurs when
 ; 1. (N - P) = P
 ; 2. (P - N) = N
-(define-rule bv-ssubo-eliminate
-  ((x ?BitVec) (y ?BitVec))
+(define-cond-rule bv-ssubo-eliminate
+  ((x ?BitVec) (y ?BitVec) (nm1 Int))
   (def
     (n (@bvsize x))
-    (xLt0 (= (extract (- n 1) (- n 1) x) (@bv 1 1)))
-    (yLt0 (= (extract (- n 1) (- n 1) y) (@bv 1 1)))
+    (xLt0 (= (extract nm1 nm1 x) (@bv 1 1)))
+    (yLt0 (= (extract nm1 nm1 y) (@bv 1 1)))
     (s (bvsub x y))
-    (sLt0 (= (extract (- n 1) (- n 1) s) (@bv 1 1)))
+    (sLt0 (= (extract nm1 nm1 s) (@bv 1 1)))
   )
+  (= nm1 (- n 1))
   (bvssubo x y)
   (or
     (and xLt0 (not yLt0) (not sLt0))
diff --git a/src/theory/bv/rewrites-simplification b/src/theory/bv/rewrites-simplification
index 0d67e1a60..a0c7b1281 100644
--- a/src/theory/bv/rewrites-simplification
+++ b/src/theory/bv/rewrites-simplification
@@ -75,26 +75,26 @@
   (bvshl x (@bv 0 sz))
   x)
 (define-cond-rule bv-shl-by-const-1
-  ((x ?BitVec) (amount Int) (sz Int))
+  ((x ?BitVec) (amount Int) (sz Int) (en Int))
   (def (n (@bvsize x)))
-  (< amount n)
+  (and (< amount n) (= en (- n (+ 1 amount))))
   (bvshl x (@bv amount sz))
-  (concat (extract (- n (+ 1 amount)) 0 x) (@bv 0 amount)))
+  (concat (extract en 0 x) (@bv 0 amount)))
 (define-cond-rule bv-shl-by-const-2
-  ((x ?BitVec) (amount Int) (sz Int))
-  (>= amount (@bvsize x))
+  ((x ?BitVec) (amount Int) (sz Int) (w Int))
+  (and (>= amount (@bvsize x)) (= w (@bvsize x)))
   (bvshl x (@bv amount sz))
-  (@bv 0 (@bvsize x)))
+  (@bv 0 w))
 (define-rule bv-lshr-by-const-0
   ((x ?BitVec) (sz Int))
   (bvlshr x (@bv 0 sz))
   x)
 (define-cond-rule bv-lshr-by-const-1
-  ((x ?BitVec) (amount Int) (sz Int))
+  ((x ?BitVec) (amount Int) (sz Int) (nm1 Int))
   (def (n (@bvsize x)))
-  (< amount n)
+  (and (< amount n) (= nm1 (- n 1)))
   (bvlshr x (@bv amount sz))
-  (concat (@bv 0 amount) (extract (- n 1) amount x)))
+  (concat (@bv 0 amount) (extract nm1 amount x)))
 (define-cond-rule bv-lshr-by-const-2
   ((x ?BitVec) (amount Int) (sz Int))
   (>= amount (@bvsize x))
@@ -105,56 +105,57 @@
   (bvashr x (@bv 0 sz))
   x)
 (define-cond-rule bv-ashr-by-const-1
-  ((x ?BitVec) (amount Int) (sz Int))
+  ((x ?BitVec) (amount Int) (sz Int) (nm1 Int))
   (def (n (@bvsize x)))
-  (< amount n)
+  (and (< amount n) (= nm1 (- n 1)))
   (bvashr x (@bv amount sz))
   (concat
-    (repeat amount (extract (- n 1) (- n 1) x))
-    (extract (- n 1) amount x)
+    (repeat amount (extract nm1 nm1 x))
+    (extract nm1 amount x)
   ))
 (define-cond-rule bv-ashr-by-const-2
-  ((x ?BitVec) (amount Int) (sz Int))
-  (def (n (@bvsize x)))
-  (>= amount (@bvsize x))
+  ((x ?BitVec) (amount Int) (sz Int) (nm1 Int) (rn Int))
+  (and (>= amount (@bvsize x)) (= nm1 (- (@bvsize x) 1)) (= rn (@bvsize x)))
   (bvashr x (@bv amount sz))
-  (repeat n (extract (- n 1) (- n 1) x)))
+  (repeat rn (extract nm1 nm1 x)))
 
 ; AndOrXorConcatPullUp
-(define-rule* bv-and-concat-pullup
+(define-cond-rule bv-and-concat-pullup
   ((x ?BitVec) (y ?BitVec)
-   (z ?BitVec) (ys ?BitVec :list))
+   (z ?BitVec) (ys ?BitVec :list)
+   (nxm1 Int) (ny Int) (nym1 Int))
   (def
     (nx (@bvsize x))
-    (ny (@bvsize y))
   )
+  (and (= ny (@bvsize y)) (= nxm1 (- nx 1)) (= nym1 (- (@bvsize y) 1)))
   (bvand x (concat ys z y))
   (concat
-    (bvand (extract (- nx 1) ny x) (concat ys z)) ; Recur on this
-    (bvand (extract (- ny 1) 0 x) y)
+    (bvand (extract nxm1 ny x) (concat ys z)) ; Recur on this
+    (bvand (extract nym1 0 x) y)
   ))
-(define-rule* bv-or-concat-pullup
+(define-cond-rule bv-or-concat-pullup
   ((x ?BitVec) (y ?BitVec)
-   (z ?BitVec) (ys ?BitVec :list))
+   (z ?BitVec) (ys ?BitVec :list)
+   (nxm1 Int) (ny Int) (nym1 Int))
   (def
     (nx (@bvsize x))
-    (ny (@bvsize y))
   )
+  (and (= ny (@bvsize y)) (= nxm1 (- nx 1)) (= nym1 (- (@bvsize y) 1)))
   (bvor x (concat ys z y))
   (concat
-    (bvor (extract (- nx 1) ny x) (concat ys z)) ; Recur on this
-    (bvor (extract (- ny 1) 0 x) y)
+    (bvor (extract nxm1 ny x) (concat ys z)) ; Recur on this
+    (bvor (extract nym1 0 x) y)
   ))
-(define-rule* bv-xor-concat-pullup
-  ((x ?BitVec) (y ?BitVec) (z ?BitVec) (ys ?BitVec :list))
+(define-cond-rule bv-xor-concat-pullup
+  ((x ?BitVec) (y ?BitVec) (z ?BitVec) (ys ?BitVec :list) (nxm1 Int) (ny Int) (nym1 Int))
   (def
     (nx (@bvsize x))
-    (ny (@bvsize y))
   )
+  (and (= ny (@bvsize y)) (= nxm1 (- nx 1)) (= nym1 (- (@bvsize y) 1)))
   (bvxor x (concat ys z y))
   (concat
-    (bvxor (extract (- nx 1) ny x) (concat ys z)) ; Recur on this
-    (bvxor (extract (- ny 1) 0 x) y)
+    (bvxor (extract nxm1 ny x) (concat ys z)) ; Recur on this
+    (bvxor (extract nym1 0 x) y)
   ))
 
 
@@ -164,31 +165,36 @@
 (define-rule bv-and-zero ((x ?BitVec) (n Int))
   (bvand x (@bv 0 n))
   (@bv 0 n))
-(define-cond-rule bv-and-one ((x ?BitVec) (y ?BitVec))
-  (= y (bvnot (@bv 0 (@bvsize y))))
-  (bvand x y)
+(define-cond-rule bv-and-one ((x ?BitVec) (n Int) (w Int))
+  (and (= w (@bvsize x)) (= n (- (int.pow2 (@bvsize x)) 1)))
+  (bvand x (@bv n w))
   x)
-(define-cond-rule bv-or-one ((x ?BitVec) (y ?BitVec))
-  (= y (bvnot (@bv 0 (@bvsize y))))
-  (bvor x y)
-  (bvnot (@bv 0 (@bvsize y))))
+(define-cond-rule bv-or-one ((x ?BitVec) (n Int) (w Int))
+  (and (= w (@bvsize x)) (= n (- (int.pow2 (@bvsize x)) 1)))
+  (bvor x (@bv n w))
+  (bvnot (@bv 0 w)))
 
-(define-rule bv-xor-duplicate ((x ?BitVec)) (bvxor x x) (@bv 0 (@bvsize x)))
+(define-cond-rule bv-xor-duplicate ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
+  (bvxor x x) 
+  (@bv 0 w))
 
-(define-cond-rule bv-xor-ones ((x ?BitVec) (y ?BitVec))
-  (= y (bvnot (@bv 0 (@bvsize y))))
-  (bvxor x y)
+(define-cond-rule bv-xor-ones ((x ?BitVec) (n Int) (w Int))
+  (= n (- (int.pow2 (@bvsize x)) 1))
+  (bvxor x (@bv n w))
   (bvnot x))
 (define-rule bv-xor-zero ((x ?BitVec) (n Int))
   (bvxor x (@bv 0 n))
   x)
 
-(define-rule bv-bitwise-not-and ((x ?BitVec))
+(define-cond-rule bv-bitwise-not-and ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvand x (bvnot x))
-  (@bv 0 (@bvsize x)))
-(define-rule bv-bitwise-not-or ((x ?BitVec))
+  (@bv 0 w))
+(define-cond-rule bv-bitwise-not-or ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvor x (bvnot x))
-  (bvnot (@bv 0 (@bvsize x))))
+  (bvnot (@bv 0 w)))
 (define-rule bv-xor-not ((x ?BitVec) (y ?BitVec))
   (bvxor (bvnot x) (bvnot y)) (bvxor x y))
 (define-rule bv-not-idemp ((x ?BitVec))
@@ -215,9 +221,9 @@
   true)
 (define-rule bv-sle-self ((x ?BitVec)) (bvsle x x) true)
 
-(define-cond-rule bv-ule-max ((x ?BitVec) (y ?BitVec))
-  (= y (bvnot (@bv 0 (@bvsize y))))
-  (bvule x y) true)
+(define-cond-rule bv-ule-max ((x ?BitVec) (n Int) (w Int))
+  (and (= w (@bvsize x)) (= n (- (int.pow2 (@bvsize x)) 1)))
+  (bvule x (@bv n w)) true)
 (define-rule bv-not-ult ((x ?BitVec) (y ?BitVec))
   (not (bvult x y))
   (bvule y x))
@@ -229,47 +235,30 @@
   (bvslt y x))
 
 (define-cond-rule bv-mult-pow2-1
-  ((xs ?BitVec :list) (ys ?BitVec :list) (z ?BitVec) (size Int) (n Int))
-  (def (exponent (int.log2 n)))
-  (int.ispow2 n)
+  ((xs ?BitVec :list) (ys ?BitVec :list) (z ?BitVec) (size Int) (n Int) (exponent Int) (u Int))
+  (def (e (int.log2 n)))
+  (and (int.ispow2 n) (= exponent e) (= u (- (- size e) 1)))
   (bvmul xs z (@bv n size) ys)
   (concat
-    (extract (- (- size exponent) 1) 0 (bvmul xs z ys))
+    (extract u 0 (bvmul xs z ys))
     (@bv 0 exponent)))
 (define-cond-rule bv-mult-pow2-2
-  ((xs ?BitVec :list) (ys ?BitVec :list) (z ?BitVec) (size Int) (n Int))
-  (def (exponent (int.log2 (- n))))
-  (int.ispow2 (- n))
+  ((xs ?BitVec :list) (ys ?BitVec :list) (z ?BitVec) (size Int) (n Int) (exponent Int) (u Int))
+  (def (e (int.log2 n)))
+  (and (int.ispow2 (- n)) (= exponent e) (= u (- (- size e) 1)))
   (bvmul xs z (@bv n size) ys)
   (concat
-    (extract (- (- size exponent) 1) 0 (bvneg (bvmul xs z ys)))
+    (extract u 0 (bvneg (bvmul xs z ys)))
     (@bv 0 exponent)))
 (define-cond-rule bv-mult-pow2-2b
-  ((z ?BitVec) (size Int) (n Int))
-  (def (exponent (int.log2 (- n))))
-  (int.ispow2 (- n))
+  ((z ?BitVec) (size Int) (n Int) (exponent Int) (u Int))
+  (def (e (int.log2 n)))
+  (and (int.ispow2 (- n)) (= exponent e) (= u (- (- size e) 1)))
   (bvmul z (@bv n size))
   (concat
-    (extract (- (- size exponent) 1) 0 (bvneg z))
+    (extract u 0 (bvneg z))
     (@bv 0 exponent)))
 
-;(define-rule bv-mult-slice
-;  ((x ?BitVec) (y ?BitVec))
-;  (def
-;    (n (@bvsize x))
-;    (xBot (extract (- (div n 2) 1) 0 x))
-;    (yBot (extract (- (div n 2) 1) 0 y))
-;    (xTop (extract (- n 1) (div n 2) x))
-;    (yTop (extract (- n 1) (div n 2) y))
-;    (z (@bv 0 (div n 2)))
-;  )
-;  (bvmul x y)
-;  (bvadd
-;    (bvmul (concat z xBot) (concat z yBot))
-;    (concat (bvmul yTop xBot) z)
-;    (concat (bvmul xTop yBot) z)
-;  ))
-
 ; If the bit-vectors multiplied have enough leading zeros,
 ; we can determine that the top bits of the multiplication
 ; are zero and not compute them. Only apply for large bitwidths
@@ -280,6 +269,7 @@
     (high Int) (low Int)
     (x1i Int) (x1in Int) (x2 ?BitVec)
     (y1i Int) (y1in Int) (y2 ?BitVec)
+    (w Int)
   )
   (def
     (n (+ x1in (@bvsize x2)))
@@ -287,19 +277,18 @@
     (x0n (ite (= x1i 0) x1in (- x1in (+ 1 (int.log2 x1i)))))
     (y0n (ite (= y1i 0) y1in (- y1in (+ 1 (int.log2 y1i)))))
   )
-  (and (> n 64) (<= (- (* 2 n) (+ x0n y0n)) low))
+  (and (> n 64) (<= (- (* 2 n) (+ x0n y0n)) low) (= w (+ 1 (- high low))))
   (extract high low (bvmul
     (concat (@bv x1i x1in) x2)
     (concat (@bv y1i y1in) y2)))
-  (@bv 0 (+ 1 (- high low))))
+  (@bv 0 w))
 
 ; (a udiv 2^k) ==> 0_k a[n-1: k]
 (define-cond-rule bv-udiv-pow2-not-one
-  ((x ?BitVec) (v Int) (n Int))
-  (def (power (int.log2 v)))
-  (and (int.ispow2 v) (> v 1))
+  ((x ?BitVec) (v Int) (n Int) (power Int) (nm1 Int))
+  (and (int.ispow2 v) (> v 1) (= power (int.log2 v)) (= nm1 (- n 1)))
   (bvudiv x (@bv v n))
-  (concat (@bv 0 power) (extract (- n 1) power x)))
+  (concat (@bv 0 power) (extract nm1 power x)))
 
 (define-rule bv-udiv-zero
   ((x ?BitVec) (n Int))
@@ -311,20 +300,21 @@
   x)
 ; (x urem 2^k) = 0_(n-k) x[k-1:0]
 (define-cond-rule bv-urem-pow2-not-one
-  ((x ?BitVec) (v Int) (n Int))
+  ((x ?BitVec) (v Int) (n Int) (nmp Int) (pm1 Int))
   (def (power (int.log2 v)))
-  (and (int.ispow2 v) (> v 1))
+  (and (int.ispow2 v) (> v 1) (= nmp (- n power)) (= pm1 (- power 1)))
   (bvurem x (@bv v n))
-  (concat (@bv 0 (- n power)) (extract (- power 1) 0 x)))
+  (concat (@bv 0 nmp) (extract pm1 0 x)))
 
 (define-rule bv-urem-one
   ((x ?BitVec) (n Int))
   (bvurem x (@bv 1 n))
   (@bv 0 n))
-(define-rule bv-urem-self
-  ((x ?BitVec))
+(define-cond-rule bv-urem-self
+  ((x ?BitVec) (w Int))
+  (= w (@bvsize x))
   (bvurem x x)
-  (@bv 0 (@bvsize x)))
+  (@bv 0 w))
 ; ShiftZero rule
 ; (0_k >> a) = 0_k
 (define-rule bv-shl-zero
@@ -346,33 +336,36 @@
 ;   ==>  (and (=> (= x 0_k) (bvugt T x)) (= x 0_k))
 ;   ==>  (and (bvugt T x) (= x 0_k))
 ;   ==>  (and (bvugt T 0_k) (= x 0_k))
-(define-rule bv-ugt-urem
-  ((y ?BitVec) (x ?BitVec))
+(define-cond-rule bv-ugt-urem
+  ((y ?BitVec) (x ?BitVec) (w Int))
+  (= w (@bvsize y))
   (bvugt (bvurem y x) x)
   (and
-    (= x (@bv 0 (@bvsize x)))
-    (bvugt y (@bv 0 (@bvsize y)))
+    (= x (@bv 0 w))
+    (bvugt y (@bv 0 w))
   ))
 
 (define-rule bv-ult-one
   ((x ?BitVec) (n Int))
   (bvult x (@bv 1 n))
   (= x (@bv 0 n)))
-(define-rule bv-slt-zero
-  ((x ?BitVec) (n Int))
+(define-cond-rule bv-slt-zero
+  ((x ?BitVec) (n Int) (nm1 Int))
+  (= nm1 (- n 1))
   (bvslt x (@bv 0 n))
-  (= (extract (- n 1) (- n 1) x) (@bv 1 1)))
+  (= (extract nm1 nm1 x) (@bv 1 1)))
 
-(define-rule bv-merge-sign-extend-1
-  ((x ?BitVec) (i Int) (j Int))
+(define-cond-rule bv-merge-sign-extend-1
+  ((x ?BitVec) (i Int) (j Int) (k Int))
+  (= k (+ i j))
   (sign_extend i (sign_extend j x))
-  (sign_extend (+ i j) x)
+  (sign_extend k x)
   )
 (define-cond-rule bv-merge-sign-extend-2
-  ((x ?BitVec) (i Int) (j Int))
-  (> j 1)
+  ((x ?BitVec) (i Int) (j Int) (k Int))
+  (and (> j 1) (= k (+ i j)))
   (sign_extend i (zero_extend j x))
-  (zero_extend (+ i j) x)
+  (zero_extend k x)
   )
 (define-cond-rule bv-merge-sign-extend-3
   ((x ?BitVec) (i Int) (n0 Int))
@@ -380,114 +373,96 @@
   (sign_extend i (zero_extend n0 x))
   (sign_extend i x)
   )
-(define-rule bv-sign-extend-eq-const-1
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
+(define-cond-rule bv-sign-extend-eq-const-1
+  ((x ?BitVec) (m Int) (c Int) (nm Int) (mp1 Int) (nm1 Int) (nmm1 Int))
   (def
     (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
+    (clo (extract nm1 0 (@bv c nm)))
     ; Combines the sign bit c[n-1] and the high part
-    (chi (extract (- nm 1) (- n 1) (@bv c nm)))
+    (chi (extract nmm1 nm1 (@bv c nm)))
   )
+  (and (= mp1 (+ m 1)) (= nm1 (- n 1)) (= nmm1 (- nm 1)))
   (= (sign_extend m x) (@bv c nm))
   (and
-    (or (= chi (@bv 0 (+ m 1))) (= chi (bvnot (@bv 0 (+ m 1)))))
+    (or (= chi (@bv 0 mp1)) (= chi (bvnot (@bv 0 mp1))))
     (= x clo)))
-(define-rule bv-sign-extend-eq-const-2
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
+(define-cond-rule bv-sign-extend-eq-const-2
+  ((x ?BitVec) (m Int) (c Int) (nm Int) (mp1 Int) (nm1 Int) (nmm1 Int))
   (def
     (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
+    (clo (extract nm1 0 (@bv c nm)))
     ; Combines the sign bit c[n-1] and the high part
-    (chi (extract (- nm 1) (- n 1) (@bv c nm)))
+    (chi (extract nmm1 nm1 (@bv c nm)))
   )
+  (and (= mp1 (+ m 1)) (= nm1 (- n 1)) (= nmm1 (- nm 1)))
   (= (@bv c nm) (sign_extend m x))
   (and
-    (or (= chi (@bv 0 (+ m 1))) (= chi (bvnot (@bv 0 (+ m 1)))))
+    (or (= chi (@bv 0 mp1)) (= chi (bvnot (@bv 0 mp1))))
     (= x clo)))
-(define-rule bv-zero-extend-eq-const-1
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
+(define-cond-rule bv-zero-extend-eq-const-1
+  ((x ?BitVec) (m Int) (c Int) (nm Int) (nm1 Int) (nmm1 Int))
   (def
     (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
-    (chi (extract (- nm 1) (- n 1) (@bv c nm)))
+    (clo (extract nm1 0 (@bv c nm)))
+    (chi (extract nmm1 nm1 (@bv c nm)))
   )
+  (and (= nm1 (- n 1)) (= nmm1 (- nm 1)))
   (= (zero_extend m x) (@bv c nm))
   (and
     (= chi (@bv 0 m))
     (= x clo)))
-(define-rule bv-zero-extend-eq-const-2
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
+(define-cond-rule bv-zero-extend-eq-const-2
+  ((x ?BitVec) (m Int) (c Int) (nm Int) (nm1 Int) (nmm1 Int))
   (def
     (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
-    (chi (extract (- nm 1) (- n 1) (@bv c nm)))
+    (clo (extract nm1 0 (@bv c nm)))
+    (chi (extract nmm1 nm1 (@bv c nm)))
   )
+  (and (= nm1 (- n 1)) (= nmm1 (- nm 1)))
   (= (@bv c nm) (zero_extend m x))
   (and
     (= chi (@bv 0 m))
     (= x clo)))
-(define-cond-rule bv-zero-extend-ult-const-1
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
-  (def
-    (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
-    (chi (extract (- nm 1) n (@bv c nm)))
-  )
-  (= chi (@bv 0 m))
-  (bvult (zero_extend m x) (@bv c nm))
-  (bvult x clo))
-(define-cond-rule bv-zero-extend-ult-const-2
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
-  (def
-    (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
-    (chi (extract (- nm 1) n (@bv c nm)))
-  )
-  (= chi (@bv 0 m))
-  (bvult (@bv c nm) (zero_extend m x))
-  (bvult clo x))
 (define-cond-rule bv-sign-extend-ult-const-1
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
+  ((x ?BitVec) (m Int) (c Int) (nm Int) (nm1 Int))
   (def
     (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
+    (clo (extract nm1 0 (@bv c nm)))
     (a (bvshl (@bv 1 nm) (@bv (- n 1) nm))) ; 1 << (n-1)
     (b (bvshl (bvnot (@bv 0 nm)) (@bv (- n 1) nm))) ; ~0 << (n-1)
   )
-  (or (bvule (@bv c nm) a) (bvuge (@bv c nm) b))
+  (and (or (bvule (@bv c nm) a) (bvuge (@bv c nm) b)) (= nm1 (- n 1)))
   (bvult (sign_extend m x) (@bv c nm))
   (bvult x clo))
 (define-cond-rule bv-sign-extend-ult-const-2
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
+  ((x ?BitVec) (m Int) (c Int) (nm Int) (nm1 Int))
   (def
     (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
     (a (bvshl (@bv 1 nm) (@bv (- n 1) nm))) ; 1 << (n-1)
     (b (bvshl (bvnot (@bv 0 nm)) (@bv (- n 1) nm))) ; ~0 << (n-1)
   )
-  (and (bvult a (@bv c nm)) (bvule (@bv c nm) b))
+  (and (bvult a (@bv c nm)) (bvule (@bv c nm) b) (= nm1 (- n 1)))
   (bvult (sign_extend m x) (@bv c nm))
-  (= (extract (- n 1) (- n 1) x) (@bv 0 1)))
+  (= (extract nm1 nm1 x) (@bv 0 1)))
 (define-cond-rule bv-sign-extend-ult-const-3
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
+  ((x ?BitVec) (m Int) (c Int) (nm Int) (nm1 Int))
   (def
     (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
+    (clo (extract nm1 0 (@bv c nm)))
     (a (bvshl (@bv 1 nm) (@bv (- n 1) nm))) ; 1 << (n-1)
     (b (bvshl (bvnot (@bv 0 nm)) (@bv (- n 1) nm))) ; ~0 << (n-1)
   )
-  (or (bvult (@bv c nm) a) (bvuge (@bv c nm) (bvnot a)))
+  (and (or (bvult (@bv c nm) a) (bvuge (@bv c nm) (bvnot a))) (= nm1 (- n 1)))
   (bvult (@bv c nm) (sign_extend m x))
   (bvult clo x))
 
 (define-cond-rule bv-sign-extend-ult-const-4
-  ((x ?BitVec) (m Int) (c Int) (nm Int))
+  ((x ?BitVec) (m Int) (c Int) (nm Int) (nm1 Int))
   (def
     (n (@bvsize x))
-    (clo (extract (- n 1) 0 (@bv c nm)))
     (a (bvshl (@bv 1 nm) (@bv (- n 1) nm))) ; 1 << (n-1)
     (b (bvshl (bvnot (@bv 0 nm)) (@bv (- n 1) nm))) ; ~0 << (n-1)
   )
-  (and (bvule (bvnot b) (@bv c nm)) (bvule (@bv c nm) (bvnot a)))
+  (and (bvule (bvnot b) (@bv c nm)) (bvule (@bv c nm) (bvnot a)) (= nm1 (- n 1)))
   (bvult (@bv c nm) (sign_extend m x))
-  (= (extract (- n 1) (- n 1) x) (@bv 1 1)))
+  (= (extract nm1 nm1 x) (@bv 1 1)))
diff --git a/src/theory/uf/rewrites b/src/theory/uf/rewrites
index 312876db4..0491f448c 100644
--- a/src/theory/uf/rewrites
+++ b/src/theory/uf/rewrites
@@ -17,7 +17,7 @@
 ;  (mod t (^ 2 w)))
 
 
-(define-rule uf-bv2nat-geq-elim ((x ?BitVec) (n Int))
-  (def (w (@bvsize x)))
+(define-cond-rule uf-bv2nat-geq-elim ((x ?BitVec) (n Int) (w Int))
+  (= w (@bvsize x))
   (>= (bv2nat x) n)
   (ite (>= n w) false (ite (< n 0) true (bvuge x (int2bv w n)))))
diff --git a/test/regress/cli/CMakeLists.txt b/test/regress/cli/CMakeLists.txt
index 3a0356d02..d4c8b13b2 100644
--- a/test/regress/cli/CMakeLists.txt
+++ b/test/regress/cli/CMakeLists.txt
@@ -396,6 +396,7 @@ set(regress_0_tests
   regress0/bv/core/slice-18.smtv1.smt2
   regress0/bv/core/slice-19.smtv1.smt2
   regress0/bv/core/slice-20.smtv1.smt2
+  regress0/bv/dd_fuzz21.smt2
   regress0/bv/div_mod.cvc.smt2
   regress0/bv/divtest_2_5.smt2
   regress0/bv/divtest_2_6.smt2
@@ -1317,6 +1318,7 @@ set(regress_0_tests
   regress0/proofs/dsl-no-eval.smt2
   regress0/proofs/dsl-rule-comp-types.smt2
   regress0/proofs/equal-eval-rw_340.smt2
+  regress0/proofs/eval-rhs.smt2
   regress0/proofs/fixed-point-rew.smt2
   regress0/proofs/fixed-point-rew-conc.smt2
   regress0/proofs/indexof-eval-rw_155.smt2
diff --git a/test/regress/cli/regress0/bv/dd_fuzz21.smt2 b/test/regress/cli/regress0/bv/dd_fuzz21.smt2
new file mode 100644
index 000000000..87f6f6a24
--- /dev/null
+++ b/test/regress/cli/regress0/bv/dd_fuzz21.smt2
@@ -0,0 +1,4 @@
+; EXPECT: unsat
+(set-logic ALL)
+(declare-const x (_ BitVec 1))
+(check-sat-assuming ((bvult (_ bv1 3) (bvmul ((_ sign_extend 2) x) ((_ repeat 3) (_ bv1 1))))))
diff --git a/test/regress/cli/regress0/proofs/eval-rhs.smt2 b/test/regress/cli/regress0/proofs/eval-rhs.smt2
new file mode 100644
index 000000000..2cc0c87f6
--- /dev/null
+++ b/test/regress/cli/regress0/proofs/eval-rhs.smt2
@@ -0,0 +1,5 @@
+; EXPECT: unsat
+(set-logic ALL)
+(declare-fun x () (_ BitVec 32))
+(assert (not (= ((_ extract 3 1) ((_ extract 7 1) x)) ((_ extract 4 2) x))))
+(check-sat)
-- 
2.47.1

