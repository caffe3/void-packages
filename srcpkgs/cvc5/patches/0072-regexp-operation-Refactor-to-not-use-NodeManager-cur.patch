From 7b7a940ca22ed4829efeb136960a66fe8961d69d Mon Sep 17 00:00:00 2001
From: Daniel Larraz <daniel-larraz@users.noreply.github.com>
Date: Tue, 24 Sep 2024 19:16:49 -0500
Subject: [PATCH 072/312] regexp operation: Refactor to not use
 NodeManager::currentNM() (#11219)

---
 src/theory/strings/proof_checker.cpp    |   8 +-
 src/theory/strings/regexp_operation.cpp | 182 ++++++++++++------------
 src/theory/strings/regexp_operation.h   |  10 +-
 3 files changed, 104 insertions(+), 96 deletions(-)

diff --git a/src/theory/strings/proof_checker.cpp b/src/theory/strings/proof_checker.cpp
index 06dd84b11..c671cfda4 100644
--- a/src/theory/strings/proof_checker.cpp
+++ b/src/theory/strings/proof_checker.cpp
@@ -443,12 +443,13 @@ Node StringProofRuleChecker::checkInternal(ProofRule id,
       Assert(args.empty());
       std::vector<Node> newSkolems;
       SkolemCache skc(nullptr);
-      conc = RegExpOpr::reduceRegExpPos(skChild, &skc, newSkolems);
+      conc =
+          RegExpOpr::reduceRegExpPos(nodeManager(), skChild, &skc, newSkolems);
     }
     else if (id == ProofRule::RE_UNFOLD_NEG)
     {
       Assert(args.empty());
-      conc = RegExpOpr::reduceRegExpNeg(skChild);
+      conc = RegExpOpr::reduceRegExpNeg(nodeManager(), skChild);
     }
     else if (id == ProofRule::RE_UNFOLD_NEG_CONCAT_FIXED)
     {
@@ -471,7 +472,8 @@ Node StringProofRuleChecker::checkInternal(ProofRule id,
         Trace("strings-pfcheck") << "...fail, non-fixed lengths" << std::endl;
         return Node::null();
       }
-      conc = RegExpOpr::reduceRegExpNegConcatFixed(skChild, reLen, isRev);
+      conc = RegExpOpr::reduceRegExpNegConcatFixed(
+          nodeManager(), skChild, reLen, isRev);
     }
     return conc;
   }
diff --git a/src/theory/strings/regexp_operation.cpp b/src/theory/strings/regexp_operation.cpp
index 586bea316..cb1a01d7c 100644
--- a/src/theory/strings/regexp_operation.cpp
+++ b/src/theory/strings/regexp_operation.cpp
@@ -33,22 +33,20 @@ namespace strings {
 
 RegExpOpr::RegExpOpr(Env& env, SkolemCache* sc)
     : EnvObj(env),
-      d_true(NodeManager::currentNM()->mkConst(true)),
-      d_false(NodeManager::currentNM()->mkConst(false)),
-      d_emptyRegexp(NodeManager::currentNM()->mkNode(Kind::REGEXP_NONE,
-                                                     std::vector<Node>{})),
-      d_zero(NodeManager::currentNM()->mkConstInt(Rational(0))),
-      d_one(NodeManager::currentNM()->mkConstInt(Rational(1))),
-      d_sigma(NodeManager::currentNM()->mkNode(Kind::REGEXP_ALLCHAR,
-                                               std::vector<Node>{})),
-      d_sigma_star(
-          NodeManager::currentNM()->mkNode(Kind::REGEXP_STAR, d_sigma)),
+      d_true(nodeManager()->mkConst(true)),
+      d_false(nodeManager()->mkConst(false)),
+      d_emptyRegexp(
+          nodeManager()->mkNode(Kind::REGEXP_NONE, std::vector<Node>{})),
+      d_zero(nodeManager()->mkConstInt(Rational(0))),
+      d_one(nodeManager()->mkConstInt(Rational(1))),
+      d_sigma(nodeManager()->mkNode(Kind::REGEXP_ALLCHAR, std::vector<Node>{})),
+      d_sigma_star(nodeManager()->mkNode(Kind::REGEXP_STAR, d_sigma)),
       d_sc(sc)
 {
-  d_emptyString = Word::mkEmptyWord(NodeManager::currentNM()->stringType());
+  d_emptyString = Word::mkEmptyWord(nodeManager()->stringType());
 
   d_emptySingleton =
-      NodeManager::currentNM()->mkNode(Kind::STRING_TO_REGEXP, d_emptyString);
+      nodeManager()->mkNode(Kind::STRING_TO_REGEXP, d_emptyString);
   d_lastchar = options().strings.stringsAlphaCard - 1;
 }
 
@@ -134,7 +132,7 @@ int RegExpOpr::delta( Node r, Node &exp ) {
   }
   Trace("regexp-delta") << "RegExpOpr::delta: " << r << std::endl;
   int ret = 0;
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   Kind k = r.getKind();
   switch (k)
   {
@@ -276,7 +274,7 @@ int RegExpOpr::derivativeS(Node r, cvc5::internal::String c, Node& retNode)
 
   int ret = 1;
   retNode = d_emptyRegexp;
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   SkolemManager* sm = nm->getSkolemManager();
 
   PairNodeStr dv = std::make_pair( r, c );
@@ -289,8 +287,7 @@ int RegExpOpr::derivativeS(Node r, cvc5::internal::String c, Node& retNode)
     Node expNode;
     ret = delta( r, expNode );
     if(ret == 0) {
-      retNode = NodeManager::currentNM()->mkNode(
-          Kind::ITE, expNode, r, d_emptyRegexp);
+      retNode = nodeManager()->mkNode(Kind::ITE, expNode, r, d_emptyRegexp);
     } else if(ret == 1) {
       retNode = r;
     }
@@ -401,11 +398,12 @@ int RegExpOpr::derivativeS(Node r, cvc5::internal::String c, Node& retNode)
                 vec_nodes2.push_back( r[j] );
               }
             }
-            Node tmp = vec_nodes2.size() == 0 ? d_emptySingleton
-                       : vec_nodes2.size() == 1
-                           ? vec_nodes2[0]
-                           : NodeManager::currentNM()->mkNode(
-                               Kind::REGEXP_CONCAT, vec_nodes2);
+            Node tmp = vec_nodes2.size() == 0
+                           ? d_emptySingleton
+                           : vec_nodes2.size() == 1
+                                 ? vec_nodes2[0]
+                                 : nodeManager()->mkNode(Kind::REGEXP_CONCAT,
+                                                         vec_nodes2);
             if(dnode != d_true) {
               tmp = rewrite(nm->mkNode(Kind::ITE, dnode, tmp, d_emptyRegexp));
               ret = 0;
@@ -425,9 +423,9 @@ int RegExpOpr::derivativeS(Node r, cvc5::internal::String c, Node& retNode)
         retNode =
             vec_nodes.size() == 0
                 ? d_emptyRegexp
-                : (vec_nodes.size() == 1 ? vec_nodes[0]
-                                         : NodeManager::currentNM()->mkNode(
-                                             Kind::REGEXP_UNION, vec_nodes));
+                : (vec_nodes.size() == 1
+                       ? vec_nodes[0]
+                       : nodeManager()->mkNode(Kind::REGEXP_UNION, vec_nodes));
         if(retNode == d_emptyRegexp) {
           ret = 2;
         }
@@ -452,9 +450,9 @@ int RegExpOpr::derivativeS(Node r, cvc5::internal::String c, Node& retNode)
         retNode =
             vec_nodes.size() == 0
                 ? d_emptyRegexp
-                : (vec_nodes.size() == 1 ? vec_nodes[0]
-                                         : NodeManager::currentNM()->mkNode(
-                                             Kind::REGEXP_UNION, vec_nodes));
+                : (vec_nodes.size() == 1
+                       ? vec_nodes[0]
+                       : nodeManager()->mkNode(Kind::REGEXP_UNION, vec_nodes));
         if(retNode == d_emptyRegexp) {
           ret = 2;
         }
@@ -490,8 +488,8 @@ int RegExpOpr::derivativeS(Node r, cvc5::internal::String c, Node& retNode)
                           ? d_emptyRegexp
                           : (vec_nodes.size() == 1
                                  ? vec_nodes[0]
-                                 : NodeManager::currentNM()->mkNode(
-                                     Kind::REGEXP_INTER, vec_nodes));
+                                 : nodeManager()->mkNode(Kind::REGEXP_INTER,
+                                                         vec_nodes));
             if(retNode == d_emptyRegexp) {
               ret = 2;
             }
@@ -506,11 +504,12 @@ int RegExpOpr::derivativeS(Node r, cvc5::internal::String c, Node& retNode)
       {
         Node dc;
         ret = derivativeS(r[0], c, dc);
-        retNode = dc == d_emptyRegexp ? dc
-                                      : (dc == d_emptySingleton
-                                             ? r
-                                             : NodeManager::currentNM()->mkNode(
-                                                 Kind::REGEXP_CONCAT, dc, r));
+        retNode =
+            dc == d_emptyRegexp
+                ? dc
+                : (dc == d_emptySingleton
+                       ? r
+                       : nodeManager()->mkNode(Kind::REGEXP_CONCAT, dc, r));
         break;
       }
       case Kind::REGEXP_LOOP:
@@ -527,9 +526,9 @@ int RegExpOpr::derivativeS(Node r, cvc5::internal::String c, Node& retNode)
           if(dc==d_emptyRegexp) {
             Node lop = nm->mkConst(RegExpLoop(l == 0 ? 0 : (l - 1), u - 1));
             Node r2 = nm->mkNode(Kind::REGEXP_LOOP, lop, r[0]);
-            retNode = dc == d_emptySingleton ? r2
-                                             : NodeManager::currentNM()->mkNode(
-                                                 Kind::REGEXP_CONCAT, dc, r2);
+            retNode = dc == d_emptySingleton
+                          ? r2
+                          : nodeManager()->mkNode(Kind::REGEXP_CONCAT, dc, r2);
           } else {
             retNode = d_emptyRegexp;
           }
@@ -565,7 +564,7 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
   Trace("regexp-derive") << "RegExp-derive starts with /" << mkString( r ) << "/, c=" << c << std::endl;
   Node retNode = d_emptyRegexp;
   PairNodeStr dv = std::make_pair( r, c );
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   if( d_dv_cache.find( dv ) != d_dv_cache.end() ) {
     retNode = d_dv_cache[dv];
   }
@@ -591,8 +590,7 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
       }
       case Kind::REGEXP_ALLCHAR:
       {
-        retNode = NodeManager::currentNM()->mkNode(Kind::STRING_TO_REGEXP,
-                                                   d_emptyString);
+        retNode = nodeManager()->mkNode(Kind::STRING_TO_REGEXP, d_emptyString);
         break;
       }
       case Kind::REGEXP_RANGE:
@@ -626,8 +624,8 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
       }
       case Kind::REGEXP_CONCAT:
       {
-        Node rees = NodeManager::currentNM()->mkNode(Kind::STRING_TO_REGEXP,
-                                                     d_emptyString);
+        Node rees =
+            nodeManager()->mkNode(Kind::STRING_TO_REGEXP, d_emptyString);
         std::vector< Node > vec_nodes;
         for(unsigned i=0; i<r.getNumChildren(); ++i) {
           Node dc = derivativeSingle(r[i], c);
@@ -641,11 +639,12 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
                 vec_nodes2.push_back( r[j] );
               }
             }
-            Node tmp = vec_nodes2.size() == 0 ? rees
-                       : vec_nodes2.size() == 1
-                           ? vec_nodes2[0]
-                           : NodeManager::currentNM()->mkNode(
-                               Kind::REGEXP_CONCAT, vec_nodes2);
+            Node tmp = vec_nodes2.size() == 0
+                           ? rees
+                           : vec_nodes2.size() == 1
+                                 ? vec_nodes2[0]
+                                 : nodeManager()->mkNode(Kind::REGEXP_CONCAT,
+                                                         vec_nodes2);
             if(std::find(vec_nodes.begin(), vec_nodes.end(), tmp) == vec_nodes.end()) {
               vec_nodes.push_back( tmp );
             }
@@ -658,9 +657,9 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
         retNode =
             vec_nodes.size() == 0
                 ? d_emptyRegexp
-                : (vec_nodes.size() == 1 ? vec_nodes[0]
-                                         : NodeManager::currentNM()->mkNode(
-                                             Kind::REGEXP_UNION, vec_nodes));
+                : (vec_nodes.size() == 1
+                       ? vec_nodes[0]
+                       : nodeManager()->mkNode(Kind::REGEXP_UNION, vec_nodes));
         break;
       }
       case Kind::REGEXP_UNION:
@@ -678,9 +677,9 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
         retNode =
             vec_nodes.size() == 0
                 ? d_emptyRegexp
-                : (vec_nodes.size() == 1 ? vec_nodes[0]
-                                         : NodeManager::currentNM()->mkNode(
-                                             Kind::REGEXP_UNION, vec_nodes));
+                : (vec_nodes.size() == 1
+                       ? vec_nodes[0]
+                       : nodeManager()->mkNode(Kind::REGEXP_UNION, vec_nodes));
         break;
       }
       case Kind::REGEXP_INTER:
@@ -711,8 +710,8 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
                           ? d_emptyRegexp
                           : (vec_nodes.size() == 1
                                  ? vec_nodes[0]
-                                 : NodeManager::currentNM()->mkNode(
-                                     Kind::REGEXP_INTER, vec_nodes));
+                                 : nodeManager()->mkNode(Kind::REGEXP_INTER,
+                                                         vec_nodes));
           }
         } else {
           retNode = d_emptyRegexp;
@@ -723,9 +722,9 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
       {
         Node dc = derivativeSingle(r[0], c);
         if(dc != d_emptyRegexp) {
-          retNode = dc == d_emptySingleton ? r
-                                           : NodeManager::currentNM()->mkNode(
-                                               Kind::REGEXP_CONCAT, dc, r);
+          retNode = dc == d_emptySingleton
+                        ? r
+                        : nodeManager()->mkNode(Kind::REGEXP_CONCAT, dc, r);
         } else {
           retNode = d_emptyRegexp;
         }
@@ -743,9 +742,9 @@ Node RegExpOpr::derivativeSingle(Node r, cvc5::internal::String c)
           if(dc != d_emptyRegexp) {
             Node lop = nm->mkConst(RegExpLoop(l == 0 ? 0 : (l - 1), u - 1));
             Node r2 = nm->mkNode(Kind::REGEXP_LOOP, lop, r[0]);
-            retNode = dc == d_emptySingleton ? r2
-                                             : NodeManager::currentNM()->mkNode(
-                                                 Kind::REGEXP_CONCAT, dc, r2);
+            retNode = dc == d_emptySingleton
+                          ? r2
+                          : nodeManager()->mkNode(Kind::REGEXP_CONCAT, dc, r2);
           } else {
             retNode = d_emptyRegexp;
           }
@@ -918,7 +917,7 @@ Node RegExpOpr::simplify(Node t, bool polarity)
   if (polarity)
   {
     std::vector<Node> newSkolems;
-    conc = reduceRegExpPos(tlit, d_sc, newSkolems);
+    conc = reduceRegExpPos(nodeManager(), tlit, d_sc, newSkolems);
   }
   else
   {
@@ -935,12 +934,12 @@ Node RegExpOpr::simplify(Node t, bool polarity)
       Node reLen = getRegExpConcatFixed(r, isRev);
       if (!reLen.isNull())
       {
-        conc = reduceRegExpNegConcatFixed(tlit, reLen, isRev);
+        conc = reduceRegExpNegConcatFixed(nodeManager(), tlit, reLen, isRev);
       }
     }
     if (conc.isNull())
     {
-      conc = reduceRegExpNeg(tlit);
+      conc = reduceRegExpNeg(nodeManager(), tlit);
     }
   }
   d_simpCache[tlit] = conc;
@@ -969,13 +968,12 @@ Node RegExpOpr::getRegExpConcatFixed(Node r, bool& isRev)
   return Node::null();
 }
 
-Node RegExpOpr::reduceRegExpNeg(Node mem)
+Node RegExpOpr::reduceRegExpNeg(NodeManager* nm, Node mem)
 {
   Assert(mem.getKind() == Kind::NOT
          && mem[0].getKind() == Kind::STRING_IN_REGEXP);
   Node s = mem[0][0];
   Node r = mem[0][1];
-  NodeManager* nm = NodeManager::currentNM();
   Kind k = r.getKind();
   Node zero = nm->mkConstInt(Rational(0));
   Node conc;
@@ -983,7 +981,7 @@ Node RegExpOpr::reduceRegExpNeg(Node mem)
   {
     // do not use length entailment, call regular expression concat
     Node reLen;
-    conc = reduceRegExpNegConcatFixed(mem, reLen, false);
+    conc = reduceRegExpNegConcatFixed(nm, mem, reLen, false);
   }
   else if (k == Kind::REGEXP_STAR)
   {
@@ -1012,13 +1010,15 @@ Node RegExpOpr::reduceRegExpNeg(Node mem)
   return conc;
 }
 
-Node RegExpOpr::reduceRegExpNegConcatFixed(Node mem, Node reLen, bool isRev)
+Node RegExpOpr::reduceRegExpNegConcatFixed(NodeManager* nm,
+                                           Node mem,
+                                           Node reLen,
+                                           bool isRev)
 {
   Assert(mem.getKind() == Kind::NOT
          && mem[0].getKind() == Kind::STRING_IN_REGEXP);
   Node s = mem[0][0];
   Node r = mem[0][1];
-  NodeManager* nm = NodeManager::currentNM();
   Assert(r.getKind() == Kind::REGEXP_CONCAT);
   Node zero = nm->mkConstInt(Rational(0));
   // The following simplification states that
@@ -1082,14 +1082,14 @@ Node RegExpOpr::reduceRegExpNegConcatFixed(Node mem, Node reLen, bool isRev)
   return conc;
 }
 
-Node RegExpOpr::reduceRegExpPos(Node mem,
+Node RegExpOpr::reduceRegExpPos(NodeManager* nm,
+                                Node mem,
                                 SkolemCache* sc,
                                 std::vector<Node>& newSkolems)
 {
   Assert(mem.getKind() == Kind::STRING_IN_REGEXP);
   Node s = mem[0];
   Node r = mem[1];
-  NodeManager* nm = NodeManager::currentNM();
   Kind k = r.getKind();
   Node conc;
   if (k == Kind::REGEXP_CONCAT)
@@ -1140,7 +1140,7 @@ Node RegExpOpr::reduceRegExpPos(Node mem,
     // We also immediately unfold the last disjunct for re.*. The advantage
     // of doing this is that we use the same scheme for skolems above.
     std::vector<Node> newSkolemsC;
-    sinRExp = reduceRegExpPos(sinRExp, sc, newSkolemsC);
+    sinRExp = reduceRegExpPos(nm, sinRExp, sc, newSkolemsC);
     Assert(newSkolemsC.size() == 3);
     // make the return lemma
     // can also assume the component match the first and last R are non-empty.
@@ -1213,12 +1213,12 @@ Node RegExpOpr::convert1(unsigned cnt, Node n) {
   Node r1, r2;
   convert2(cnt, n, r1, r2);
   Trace("regexp-debug") << "... getting r1=" << r1 << ", and r2=" << r2 << std::endl;
-  Node ret = r1 == d_emptySingleton
-                 ? r2
-                 : NodeManager::currentNM()->mkNode(
-                     Kind::REGEXP_CONCAT,
-                     NodeManager::currentNM()->mkNode(Kind::REGEXP_STAR, r1),
-                     r2);
+  Node ret =
+      r1 == d_emptySingleton
+          ? r2
+          : nodeManager()->mkNode(Kind::REGEXP_CONCAT,
+                                  nodeManager()->mkNode(Kind::REGEXP_STAR, r1),
+                                  r2);
   ret = rewrite(ret);
   Trace("regexp-debug") << "... done convert at " << cnt << ", with return " << ret << std::endl;
   return ret;
@@ -1254,18 +1254,20 @@ void RegExpOpr::convert2(unsigned cnt, Node n, Node &r1, Node &r2) {
         Node t1, t2;
         convert2(cnt, n[i], t1, t2);
         vr1.push_back(t1);
-        r1 = vr1.size() == 0 ? d_emptyRegexp
-             : vr1.size() == 1
-                 ? vr1[0]
-                 : NodeManager::currentNM()->mkNode(Kind::REGEXP_CONCAT, vr1);
+        r1 = vr1.size() == 0
+                 ? d_emptyRegexp
+                 : vr1.size() == 1
+                       ? vr1[0]
+                       : nodeManager()->mkNode(Kind::REGEXP_CONCAT, vr1);
         vr2.push_back(t2);
         for( unsigned j=i+1; j<n.getNumChildren(); j++ ) {
           vr2.push_back(n[j]);
         }
-        r2 = vr2.size() == 0 ? d_emptyRegexp
-             : vr2.size() == 1
-                 ? vr2[0]
-                 : NodeManager::currentNM()->mkNode(Kind::REGEXP_CONCAT, vr2);
+        r2 = vr2.size() == 0
+                 ? d_emptyRegexp
+                 : vr2.size() == 1
+                       ? vr2[0]
+                       : nodeManager()->mkNode(Kind::REGEXP_CONCAT, vr2);
         flag = false;
         break;
       } else {
@@ -1286,8 +1288,8 @@ void RegExpOpr::convert2(unsigned cnt, Node n, Node &r1, Node &r2) {
       vr1.push_back(t1);
       vr2.push_back(t2);
     }
-    r1 = NodeManager::currentNM()->mkNode(Kind::REGEXP_UNION, vr1);
-    r2 = NodeManager::currentNM()->mkNode(Kind::REGEXP_UNION, vr2);
+    r1 = nodeManager()->mkNode(Kind::REGEXP_UNION, vr1);
+    r2 = nodeManager()->mkNode(Kind::REGEXP_UNION, vr2);
   }
   else if (nk == Kind::STRING_TO_REGEXP || nk == Kind::REGEXP_ALLCHAR
            || nk == Kind::REGEXP_RANGE || nk == Kind::REGEXP_COMPLEMENT
@@ -1311,7 +1313,7 @@ Node RegExpOpr::intersectInternal( Node r1, Node r2, std::map< PairNodes, Node >
     r1 = r2;
     r2 = tmpNode;
   }
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   Trace("regexp-int") << "Starting INTERSECT(" << cnt << "):\n  "<< mkString(r1) << ",\n  " << mkString(r2) << std::endl;
   std::pair < Node, Node > p(r1, r2);
   std::map < PairNodes, Node >::const_iterator itr = d_inter_cache.find(p);
@@ -1440,7 +1442,7 @@ Node RegExpOpr::intersectInternal( Node r1, Node r2, std::map< PairNodes, Node >
 
 Node RegExpOpr::removeIntersection(Node r) {
   Assert(checkConstRegExp(r));
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   std::unordered_map<TNode, Node> visited;
   std::unordered_map<TNode, Node>::iterator it;
   std::vector<TNode> visit;
diff --git a/src/theory/strings/regexp_operation.h b/src/theory/strings/regexp_operation.h
index 0ffdc29de..dfacfdad7 100644
--- a/src/theory/strings/regexp_operation.h
+++ b/src/theory/strings/regexp_operation.h
@@ -139,13 +139,14 @@ class RegExpOpr : protected EnvObj
   /**
    * Return the unfolded form of mem of the form (str.in_re s r).
    */
-  static Node reduceRegExpPos(Node mem,
+  static Node reduceRegExpPos(NodeManager* nm,
+                              Node mem,
                               SkolemCache* sc,
                               std::vector<Node>& newSkolems);
   /**
    * Return the unfolded form of mem of the form (not (str.in_re s r)).
    */
-  static Node reduceRegExpNeg(Node mem);
+  static Node reduceRegExpNeg(NodeManager* nm, Node mem);
   /**
    * Return the unfolded form of mem of the form
    *   (not (str.in_re s (re.++ r_0 ... r_{n-1})))
@@ -155,7 +156,10 @@ class RegExpOpr : protected EnvObj
    * This uses reLen as an optimization to improve the reduction. If reLen
    * is null, then this optimization is not applied.
    */
-  static Node reduceRegExpNegConcatFixed(Node mem, Node reLen, bool isRev);
+  static Node reduceRegExpNegConcatFixed(NodeManager* nm,
+                                         Node mem,
+                                         Node reLen,
+                                         bool isRev);
   //------------------------ end trusted reductions
   /**
    * This method returns 1 if the empty string is in r, 2 if the empty string
-- 
2.47.1

