From 1ab962dd751effc557bb67988065f0b47d585ff7 Mon Sep 17 00:00:00 2001
From: Haniel Barbosa <hanielbbarbosa@gmail.com>
Date: Fri, 9 Aug 2024 22:44:55 -0300
Subject: [PATCH 011/312] [alethe] Updates to node converter (#11120)

Updates node conversion for the newest quantifier skolem meaning. Also
adds handling for some totalized kinds and removes an overly restrictive
handling of `BITVECTOR_EAGER_ATOM`.
---
 src/proof/alethe/alethe_node_converter.cpp | 52 +++++++++++-----------
 1 file changed, 26 insertions(+), 26 deletions(-)

diff --git a/src/proof/alethe/alethe_node_converter.cpp b/src/proof/alethe/alethe_node_converter.cpp
index 7cb1de295..81acafa66 100644
--- a/src/proof/alethe/alethe_node_converter.cpp
+++ b/src/proof/alethe/alethe_node_converter.cpp
@@ -72,11 +72,19 @@ Node AletheNodeConverter::postConvert(Node n)
     }
     case Kind::BITVECTOR_EAGER_ATOM:
     {
-      std::stringstream ss;
-      ss << "Proof uses eager bit-blasting, which does not have support for "
-            "Alethe proofs.";
-      d_error = ss.str();
-      return Node::null();
+      return n[0];
+    }
+    case Kind::DIVISION_TOTAL:
+    {
+      return nm->mkNode(Kind::DIVISION, n[0], n[1]);
+    }
+    case Kind::INTS_DIVISION_TOTAL:
+    {
+      return nm->mkNode(Kind::INTS_DIVISION, n[0], n[1]);
+    }
+    case Kind::INTS_MODULUS_TOTAL:
+    {
+      return nm->mkNode(Kind::INTS_MODULUS, n[0], n[1]);
     }
     case Kind::SKOLEM:
     {
@@ -113,17 +121,11 @@ Node AletheNodeConverter::postConvert(Node n)
         Assert(cacheVal.getKind() == Kind::SEXPR
                && cacheVal.getNumChildren() == 2);
         Node quant = cacheVal[0];
-        Assert(quant.getKind() == Kind::EXISTS);
-        Node var = cacheVal[1];
+        Assert(quant.getKind() == Kind::FORALL);
         uint32_t index = -1;
-        for (size_t i = 0, size = quant[0].getNumChildren(); i < size; ++i)
-        {
-          if (var == quant[0][i])
-          {
-            index = i;
-            break;
-          }
-        }
+        ProofRuleChecker::getUInt32(cacheVal[1], index);
+        Assert(index < quant[0].getNumChildren());
+        Node var = quant[0][index];
         // Since cvc5 *always* skolemize FORALLs, we generate the choice term
         // assuming it is gonna be introduced via a sko_forall rule, in which
         // case the body of the choice is negated, which means to have
@@ -131,18 +133,16 @@ Node AletheNodeConverter::postConvert(Node n)
         // body, and the whole thing negated. Likewise, since during
         // Skolemization cvc5 will have negated the body of the original
         // quantifier, we need to revert that as well.
-        Assert(index < quant[0].getNumChildren());
-        Assert(quant[1].getKind() == Kind::NOT);
         Node body =
-            index == quant[0].getNumChildren() - 1
-                ? quant[1]
-                : nm->mkNode(Kind::FORALL,
-                             nm->mkNode(
-                                 Kind::BOUND_VAR_LIST,
-                                 std::vector<Node>{quant[0].begin() + index + 1,
-                                                   quant[0].end()}),
-                             quant[1][0])
-                      .notNode();
+            (index == quant[0].getNumChildren() - 1
+                 ? quant[1]
+                 : nm->mkNode(
+                     Kind::FORALL,
+                     nm->mkNode(Kind::BOUND_VAR_LIST,
+                                std::vector<Node>{quant[0].begin() + index + 1,
+                                                  quant[0].end()}),
+                     quant[1]))
+                .notNode();
         // we need to replace in the body all the free variables (i.e., from 0
         // to index) by their respective choice terms. To do this, we get
         // the skolems for each of these variables, retrieve their
-- 
2.47.1

