From 6f74a531673d0c14e293611ffe08f332b4c41bb9 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Sat, 11 Jan 2025 08:22:17 -0600
Subject: [PATCH 294/312] More cases and fixes for strings infer proof
 constructor (#11508)

---
 src/theory/strings/infer_proof_cons.cpp | 114 ++++++++++++++++++++++--
 1 file changed, 109 insertions(+), 5 deletions(-)

diff --git a/src/theory/strings/infer_proof_cons.cpp b/src/theory/strings/infer_proof_cons.cpp
index aa2b97aa0..5e9064525 100644
--- a/src/theory/strings/infer_proof_cons.cpp
+++ b/src/theory/strings/infer_proof_cons.cpp
@@ -408,8 +408,30 @@ bool InferProofCons::convert(Env& env,
       // if there are substitutions to apply
       if (mainEqIndex > 0)
       {
+        // Compute which equalities we want to flip their substitution.
+        // Currently this is only an issue if e.g. (= (str.++ a a) (str.++ b c))
+        // where we conclude (= a c) from an explanation (= a b) via
+        // STRINGS_F_UNIFY, which would otherwise conclude (= b c) if a -> b
+        // was processed as a substitution.
+        // In contrast, normal form inferences are truly processed as
+        // substitutions in the strings core solver, whereas flat form
+        // inferences simply consider unification without substitutions, leading
+        // to issues like the one above.
         std::vector<Node> rexp(ps.d_children.begin(),
                                ps.d_children.begin() + mainEqIndex);
+        if (infer == InferenceId::STRINGS_F_UNIFY)
+        {
+          Assert(conc.getKind() == Kind::EQUAL);
+          // maybe reorient?
+          for (size_t i = 0; i < mainEqIndex; i++)
+          {
+            Assert(rexp[i].getKind() == Kind::EQUAL);
+            if (rexp[i][0] == conc[0] || rexp[i][0] == conc[1])
+            {
+              rexp[i] = rexp[i][1].eqNode(rexp[i][0]);
+            }
+          }
+        }
         // apply substitution using the util method below
         pmainEq = convertCoreSubs(env, pf, psb, mainEq, rexp, 0, 0);
       }
@@ -571,6 +593,14 @@ bool InferProofCons::convert(Env& env,
         }
         else if (infer == InferenceId::STRINGS_SSPLIT_VAR)
         {
+          // may have to flip
+          Assert(conc.getKind() == Kind::AND && conc[0].getKind() == Kind::OR
+                 && conc[0][0].getKind() == Kind::EQUAL);
+          if (conc[0][0][0] != t0)
+          {
+            applySym = true;
+            std::swap(t0, s0);
+          }
           // it should be the case that lenConstraint => lenReq
           lenReq = nm->mkNode(Kind::STRING_LENGTH, t0)
                        .eqNode(nm->mkNode(Kind::STRING_LENGTH, s0))
@@ -897,7 +927,24 @@ bool InferProofCons::convert(Env& env,
     // ========================== unit injectivity
     case InferenceId::STRINGS_UNIT_INJ:
     {
-      ps.d_rule = ProofRule::STRING_SEQ_UNIT_INJ;
+      Assert(conc.getKind() == Kind::EQUAL);
+      Assert(ps.d_children.size() == 1
+             && ps.d_children[0].getKind() == Kind::EQUAL);
+      Node concS =
+          psb.tryStep(ProofRule::STRING_SEQ_UNIT_INJ, ps.d_children, {});
+      if (!concS.isNull())
+      {
+        // may need to apply symmetry
+        if (concS != conc)
+        {
+          Node ss = psb.tryStep(ProofRule::SYMM, {concS}, {});
+          useBuffer = (ss == conc);
+        }
+        else
+        {
+          useBuffer = true;
+        }
+      }
     }
     break;
     // ========================== prefix conflict
@@ -1088,9 +1135,67 @@ bool InferProofCons::convert(Env& env,
       }
     }
     break;
+    case InferenceId::STRINGS_I_CYCLE_E:
+    {
+      Assert(ps.d_children.size() == 1);
+      Node concE = psb.applyPredElim(ps.d_children[0],
+                                     {},
+                                     MethodId::SB_DEFAULT,
+                                     MethodId::SBA_SEQUENTIAL,
+                                     MethodId::RW_EXT_REWRITE);
+      Trace("strings-ipc-debug") << "... elim to " << concE << std::endl;
+      if (concE != conc)
+      {
+        if (concE.getKind() == Kind::AND)
+        {
+          for (size_t i = 0, nchild = concE.getNumChildren(); i < nchild; i++)
+          {
+            if (concE[i] == conc)
+            {
+              Node ni = nm->mkConstInt(Rational(i));
+              psb.addStep(ProofRule::AND_ELIM, {concE}, {ni}, conc);
+              useBuffer = true;
+              break;
+            }
+          }
+        }
+      }
+      else
+      {
+        useBuffer = true;
+      }
+    }
+    break;
+    case InferenceId::STRINGS_CTN_DECOMPOSE:
+    {
+      if (ps.d_children.size() != 2)
+      {
+        break;
+      }
+      Node ctn = ps.d_children[0];
+      if (ctn.getKind() != Kind::STRING_CONTAINS)
+      {
+        break;
+      }
+      Node pconc = psb.tryStep(ProofRule::STRING_EAGER_REDUCTION, {}, {ctn});
+      Trace("strings-ipc-cons") << "Eager reduction: " << pconc << std::endl;
+      Node pelim = psb.applyPredElim(pconc, {ctn}, MethodId::SB_LITERAL);
+      Trace("strings-ipc-cons") << "After rewriting: " << pelim << std::endl;
+      if (pelim.getKind() != Kind::EQUAL)
+      {
+        break;
+      }
+      Node tgt = ps.d_children[1];
+      Node pelim2 = psb.applyPredElim(tgt, {pelim});
+      Trace("strings-ipc-cons") << "After elim: " << pelim << std::endl;
+      if (pelim2 == conc)
+      {
+        useBuffer = true;
+      }
+    }
+    break;
     // ========================== unknown and currently unsupported
     case InferenceId::STRINGS_CARDINALITY:
-    case InferenceId::STRINGS_I_CYCLE_E:
     case InferenceId::STRINGS_I_CYCLE:
     case InferenceId::STRINGS_INFER_EMP:
     case InferenceId::STRINGS_RE_DELTA:
@@ -1100,7 +1205,6 @@ bool InferProofCons::convert(Env& env,
     case InferenceId::STRINGS_FLOOP_CONFLICT:
     case InferenceId::STRINGS_DEQ_NORM_EMP:
     case InferenceId::STRINGS_CTN_TRANS:
-    case InferenceId::STRINGS_CTN_DECOMPOSE:
     default:
       // do nothing, these will be converted to THEORY_INFERENCE_STRINGS below
       // since the rule is unknown.
@@ -1151,8 +1255,8 @@ bool InferProofCons::convert(Env& env,
         Trace("strings-ipc-fail") << "    e: " << ec << std::endl;
       }
     }
-    // untrustworthy conversion, the argument of THEORY_INFERENCE_STRINGS is its
-    // conclusion
+    //  untrustworthy conversion, the argument of THEORY_INFERENCE_STRINGS is
+    //  its conclusion
     ps.d_args.clear();
     ps.d_args.push_back(mkTrustId(nm, TrustId::THEORY_INFERENCE_STRINGS));
     ps.d_args.push_back(conc);
-- 
2.47.1

