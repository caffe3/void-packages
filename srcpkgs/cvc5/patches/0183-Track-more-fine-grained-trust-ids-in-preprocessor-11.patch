From b1c1d3bcc972c7ea2ef759e36f33721984aa546f Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Tue, 19 Nov 2024 11:28:03 -0600
Subject: [PATCH 183/312] Track more fine grained trust ids in preprocessor
 (#11363)

We now throw an assertion failure in debug if a preprocess pass does not
provide a proper trust id.

Also adds a useful `ensureRewritten` routine to assertions pipeline,
which preprocessing passes can utilize to ensure their trust steps are
modulo rewriting.
---
 src/preprocessing/assertion_pipeline.cpp      | 42 +++++++++----
 src/preprocessing/assertion_pipeline.h        | 44 +++++++++++--
 src/preprocessing/passes/ackermann.cpp        | 10 ++-
 src/preprocessing/passes/bool_to_bv.cpp       |  4 +-
 src/preprocessing/passes/bv_gauss.cpp         |  9 ++-
 src/preprocessing/passes/bv_intro_pow2.cpp    |  5 +-
 src/preprocessing/passes/bv_to_bool.cpp       |  4 +-
 src/preprocessing/passes/bv_to_int.cpp        | 14 +----
 src/preprocessing/passes/ff_bitsum.cpp        |  3 +-
 .../passes/ff_disjunctive_bit.cpp             |  5 +-
 .../passes/foreign_theory_rewrite.cpp         |  9 ++-
 src/preprocessing/passes/fun_def_fmf.cpp      |  8 ++-
 src/preprocessing/passes/ho_elim.cpp          | 20 +++---
 src/preprocessing/passes/ite_simp.cpp         |  9 ++-
 src/preprocessing/passes/learned_rewrite.cpp  |  9 ++-
 src/preprocessing/passes/miplib_trick.cpp     | 19 ++++--
 src/preprocessing/passes/nl_ext_purify.cpp    |  6 +-
 src/preprocessing/passes/non_clausal_simp.cpp |  5 +-
 .../passes/quantifiers_preprocess.cpp         |  4 +-
 src/preprocessing/passes/sort_infer.cpp       |  8 ++-
 src/preprocessing/passes/static_learning.cpp  |  3 +-
 src/preprocessing/passes/strings_eager_pp.cpp |  4 +-
 .../passes/theory_preprocess.cpp              |  5 +-
 .../passes/unconstrained_simplifier.cpp       | 12 +++-
 src/proof/trust_id.cpp                        | 50 ++++++++++++++-
 src/proof/trust_id.h                          | 61 +++++++++++++++++--
 src/smt/preprocess_proof_generator.cpp        | 48 +++++++++------
 src/smt/preprocess_proof_generator.h          | 47 +++++++++-----
 src/theory/trust_substitutions.h              |  2 +-
 29 files changed, 348 insertions(+), 121 deletions(-)

diff --git a/src/preprocessing/assertion_pipeline.cpp b/src/preprocessing/assertion_pipeline.cpp
index 2add87dfc..e19c346f8 100644
--- a/src/preprocessing/assertion_pipeline.cpp
+++ b/src/preprocessing/assertion_pipeline.cpp
@@ -52,7 +52,8 @@ void AssertionPipeline::clear()
 
 void AssertionPipeline::push_back(Node n,
                                   bool isInput,
-                                  ProofGenerator* pgen)
+                                  ProofGenerator* pgen,
+                                  TrustId trustId)
 {
   if (d_conflict)
   {
@@ -74,7 +75,8 @@ void AssertionPipeline::push_back(Node n,
     {
       if (!isInput)
       {
-        d_andElimEpg->addLazyStep(n, pgen, TrustId::PREPROCESS_LEMMA);
+        Assert(pgen != nullptr || trustId != TrustId::UNKNOWN_PREPROCESS_LEMMA);
+        d_andElimEpg->addLazyStep(n, pgen, trustId);
       }
     }
     std::vector<Node> toProcess;
@@ -124,7 +126,7 @@ void AssertionPipeline::push_back(Node n,
     if (!isInput)
     {
       // notice this is always called, regardless of whether pgen is nullptr
-      d_pppg->notifyNewAssert(n, pgen);
+      d_pppg->notifyNewAssert(n, pgen, trustId);
     }
     else
     {
@@ -135,14 +137,17 @@ void AssertionPipeline::push_back(Node n,
   }
 }
 
-void AssertionPipeline::pushBackTrusted(TrustNode trn)
+void AssertionPipeline::pushBackTrusted(TrustNode trn, TrustId trustId)
 {
   Assert(trn.getKind() == TrustNodeKind::LEMMA);
   // push back what was proven
-  push_back(trn.getProven(), false, trn.getGenerator());
+  push_back(trn.getProven(), false, trn.getGenerator(), trustId);
 }
 
-void AssertionPipeline::replace(size_t i, Node n, ProofGenerator* pgen)
+void AssertionPipeline::replace(size_t i,
+                                Node n,
+                                ProofGenerator* pgen,
+                                TrustId trustId)
 {
   Assert(i < d_nodes.size());
   if (n == d_nodes[i])
@@ -154,7 +159,8 @@ void AssertionPipeline::replace(size_t i, Node n, ProofGenerator* pgen)
                            << n << std::endl;
   if (isProofEnabled())
   {
-    d_pppg->notifyPreprocessed(d_nodes[i], n, pgen);
+    Assert(pgen != nullptr || trustId != TrustId::UNKNOWN_PREPROCESS);
+    d_pppg->notifyPreprocessed(d_nodes[i], n, pgen, trustId);
   }
   if (n == d_false)
   {
@@ -166,7 +172,7 @@ void AssertionPipeline::replace(size_t i, Node n, ProofGenerator* pgen)
   }
 }
 
-void AssertionPipeline::replaceTrusted(size_t i, TrustNode trn)
+void AssertionPipeline::replaceTrusted(size_t i, TrustNode trn, TrustId trustId)
 {
   Assert(i < d_nodes.size());
   if (trn.isNull())
@@ -176,7 +182,13 @@ void AssertionPipeline::replaceTrusted(size_t i, TrustNode trn)
   }
   Assert(trn.getKind() == TrustNodeKind::REWRITE);
   Assert(trn.getProven()[0] == d_nodes[i]);
-  replace(i, trn.getNode(), trn.getGenerator());
+  replace(i, trn.getNode(), trn.getGenerator(), trustId);
+}
+
+void AssertionPipeline::ensureRewritten(size_t i)
+{
+  Assert(i < d_nodes.size());
+  replace(i, rewrite(d_nodes[i]), d_rewpg.get());
 }
 
 void AssertionPipeline::enableProofs(smt::PreprocessProofGenerator* pppg)
@@ -187,6 +199,10 @@ void AssertionPipeline::enableProofs(smt::PreprocessProofGenerator* pppg)
     d_andElimEpg.reset(
         new LazyCDProof(d_env, nullptr, userContext(), "AssertionsAndElim"));
   }
+  if (d_rewpg == nullptr)
+  {
+    d_rewpg.reset(new RewriteProofGenerator(d_env));
+  }
 }
 
 bool AssertionPipeline::isProofEnabled() const { return d_pppg != nullptr; }
@@ -202,17 +218,19 @@ void AssertionPipeline::disableStoreSubstsInAsserts()
   d_storeSubstsInAsserts = false;
 }
 
-void AssertionPipeline::addSubstitutionNode(Node n, ProofGenerator* pg)
+void AssertionPipeline::addSubstitutionNode(Node n,
+                                            ProofGenerator* pg,
+                                            TrustId trustId)
 {
   Assert(d_storeSubstsInAsserts);
   Assert(n.getKind() == Kind::EQUAL);
   size_t prevNodeSize = d_nodes.size();
-  push_back(n, false, pg);
+  push_back(n, false, pg, trustId);
   // remember this is a substitution index
   for (size_t i = prevNodeSize, newSize = d_nodes.size(); i < newSize; i++)
   {
     // ensure rewritten
-    replace(i, rewrite(d_nodes[i]));
+    replace(i, rewrite(d_nodes[i]), d_rewpg.get());
     d_substsIndices.insert(i);
   }
 }
diff --git a/src/preprocessing/assertion_pipeline.h b/src/preprocessing/assertion_pipeline.h
index 45477fbd3..8d84d5f36 100644
--- a/src/preprocessing/assertion_pipeline.h
+++ b/src/preprocessing/assertion_pipeline.h
@@ -23,6 +23,7 @@
 
 #include "expr/node.h"
 #include "proof/lazy_proof.h"
+#include "proof/rewrite_proof_generator.h"
 #include "proof/trust_node.h"
 #include "smt/env_obj.h"
 
@@ -61,17 +62,25 @@ class AssertionPipeline : protected EnvObj
   /**
    * Adds an assertion/assumption to be preprocessed.
    *
+   * Note that if proofs are provided, a preprocess pass using this method
+   * is required to either provide a proof generator or a trust id that is not
+   * TrustId::UNKNOWN_PREPROCESS_LEMMA.
+   *
    * @param n The assertion/assumption
    * @param isInput If true, n is an input formula (an assumption in the main
    * body of the overall proof).
    * @param pg The proof generator who can provide a proof of n. The proof
    * generator is not required and is ignored if isInput is true.
+   * @param trustId The trust id to use if pg is not provided when isInput
+   * is false and proofs are enabled.
    */
   void push_back(Node n,
                  bool isInput = false,
-                 ProofGenerator* pg = nullptr);
+                 ProofGenerator* pg = nullptr,
+                 TrustId trustId = TrustId::UNKNOWN_PREPROCESS_LEMMA);
   /** Same as above, with TrustNode */
-  void pushBackTrusted(TrustNode trn);
+  void pushBackTrusted(TrustNode trn,
+                       TrustId trustId = TrustId::UNKNOWN_PREPROCESS_LEMMA);
 
   /**
    * Get the constant reference to the underlying assertions. It is only
@@ -86,17 +95,34 @@ class AssertionPipeline : protected EnvObj
    * Replaces assertion i with node n and records the dependency between the
    * original assertion and its replacement.
    *
+   * Note that if proofs are provided, a preprocess pass using this method
+   * is required to either provide a proof generator or a trust id that is not
+   * TrustId::UNKNOWN_PREPROCESS_LEMMA.
+   *
    * @param i The position of the assertion to replace.
    * @param n The replacement assertion.
    * @param pg The proof generator who can provide a proof of d_nodes[i] == n,
    * where d_nodes[i] is the assertion at position i prior to this call.
+   * @param trustId The trust id to use if pg is not provided and proofs are
+   * enabled.
    */
-  void replace(size_t i, Node n, ProofGenerator* pg = nullptr);
+  void replace(size_t i,
+               Node n,
+               ProofGenerator* pg = nullptr,
+               TrustId trustId = TrustId::UNKNOWN_PREPROCESS);
   /**
    * Same as above, with TrustNode trn, which is of kind REWRITE and proves
    * d_nodes[i] = n for some n.
    */
-  void replaceTrusted(size_t i, TrustNode trn);
+  void replaceTrusted(size_t i,
+                      TrustNode trn,
+                      TrustId trustId = TrustId::UNKNOWN_PREPROCESS);
+  /**
+   * Ensure assertion at index i is rewritten. If it is not already in
+   * rewritten form, the assertion is replaced by its rewritten form.
+   * @param i The index of the assertion.
+   */
+  void ensureRewritten(size_t i);
 
   IteSkolemMap& getIteSkolemMap() { return d_iteSkolemMap; }
   const IteSkolemMap& getIteSkolemMap() const { return d_iteSkolemMap; }
@@ -124,8 +150,12 @@ class AssertionPipeline : protected EnvObj
    *
    * @param n The substitution node
    * @param pg The proof generator that can provide a proof of n.
+   * @param trustId The trust id to use if pg is not provided and proofs are
+   * enabled.
    */
-  void addSubstitutionNode(Node n, ProofGenerator* pg = nullptr);
+  void addSubstitutionNode(Node n,
+                           ProofGenerator* pg = nullptr,
+                           TrustId trustId = TrustId::UNKNOWN_PREPROCESS_LEMMA);
 
   /**
    * Checks whether the assertion at a given index represents substitutions.
@@ -209,6 +239,10 @@ class AssertionPipeline : protected EnvObj
    * Maintains proofs for eliminating top-level AND from inputs to this class.
    */
   std::unique_ptr<LazyCDProof> d_andElimEpg;
+  /**
+   * Maintains proofs for rewrite steps.
+   */
+  std::unique_ptr<RewriteProofGenerator> d_rewpg;
 }; /* class AssertionPipeline */
 
 }  // namespace preprocessing
diff --git a/src/preprocessing/passes/ackermann.cpp b/src/preprocessing/passes/ackermann.cpp
index 7e6ac4874..c98f870be 100644
--- a/src/preprocessing/passes/ackermann.cpp
+++ b/src/preprocessing/passes/ackermann.cpp
@@ -88,7 +88,8 @@ void addLemmaForPair(TNode args1,
   }
   Node func_eq = nm->mkNode(Kind::EQUAL, args1, args2);
   Node lemma = nm->mkNode(Kind::IMPLIES, args_eq, func_eq);
-  assertionsToPreprocess->push_back(lemma);
+  assertionsToPreprocess->push_back(
+      lemma, false, nullptr, TrustId::PREPROCESS_ACKERMANN_LEMMA);
 }
 
 void storeFunctionAndAddLemmas(TNode func,
@@ -286,7 +287,7 @@ void usortsToBitVectors(NodeManager* nm,
       Node newA = usVarsToBVVars.apply((*assertions)[i]);
       if (newA != old)
       {
-        assertions->replace(i, newA);
+        assertions->replace(i, newA, nullptr, TrustId::PREPROCESS_ACKERMANN);
         Trace("uninterpretedSorts-to-bv")
             << "  " << old << " => " << (*assertions)[i] << "\n";
       }
@@ -327,7 +328,10 @@ PreprocessingPassResult Ackermann::applyInternal(
   for (unsigned i = 0, size = assertionsToPreprocess->size(); i < size; ++i)
   {
     assertionsToPreprocess->replace(
-        i, d_funcToSkolem.apply((*assertionsToPreprocess)[i]));
+        i,
+        d_funcToSkolem.apply((*assertionsToPreprocess)[i]),
+        nullptr,
+        TrustId::PREPROCESS_ACKERMANN);
   }
 
   /* replace uninterpreted sorts with bit-vectors */
diff --git a/src/preprocessing/passes/bool_to_bv.cpp b/src/preprocessing/passes/bool_to_bv.cpp
index 5fb6b46c9..6121e5a83 100644
--- a/src/preprocessing/passes/bool_to_bv.cpp
+++ b/src/preprocessing/passes/bool_to_bv.cpp
@@ -58,7 +58,9 @@ PreprocessingPassResult BoolToBV::applyInternal(
     {
       newAssertion = lowerIte((*assertionsToPreprocess)[i]);
     }
-    assertionsToPreprocess->replace(i, rewrite(newAssertion));
+    assertionsToPreprocess->replace(
+        i, newAssertion, nullptr, TrustId::PREPROCESS_BOOL_TO_BV);
+    assertionsToPreprocess->ensureRewritten(i);
     if (assertionsToPreprocess->isInConflict())
     {
       return PreprocessingPassResult::CONFLICT;
diff --git a/src/preprocessing/passes/bv_gauss.cpp b/src/preprocessing/passes/bv_gauss.cpp
index b0c1154bc..437471276 100644
--- a/src/preprocessing/passes/bv_gauss.cpp
+++ b/src/preprocessing/passes/bv_gauss.cpp
@@ -755,7 +755,8 @@ PreprocessingPassResult BVGauss::applyInternal(
       if (ret == BVGauss::Result::NONE)
       {
         Node n = nm->mkConst<bool>(false);
-        assertionsToPreprocess->push_back(n);
+        assertionsToPreprocess->push_back(
+            n, false, nullptr, TrustId::PREPROCESS_BV_GUASS_LEMMA);
         return PreprocessingPassResult::CONFLICT;
       }
       else
@@ -770,7 +771,8 @@ PreprocessingPassResult BVGauss::applyInternal(
           Node a = nm->mkNode(Kind::EQUAL, p.first, p.second);
           Trace("bv-gauss-elim") << "added assertion: " << a << std::endl;
           // add new assertion
-          assertionsToPreprocess->push_back(a);
+          assertionsToPreprocess->push_back(
+              a, false, nullptr, TrustId::PREPROCESS_BV_GUASS_LEMMA);
         }
       }
     }
@@ -785,7 +787,8 @@ PreprocessingPassResult BVGauss::applyInternal(
       Node a = aref[i];
       Node as = a.substitute(subst.begin(), subst.end());
       // replace the assertion
-      assertionsToPreprocess->replace(i, as);
+      assertionsToPreprocess->replace(
+          i, as, nullptr, TrustId::PREPROCESS_BV_GUASS);
     }
   }
   return PreprocessingPassResult::NO_CONFLICT;
diff --git a/src/preprocessing/passes/bv_intro_pow2.cpp b/src/preprocessing/passes/bv_intro_pow2.cpp
index b1c4836fd..d3e84d597 100644
--- a/src/preprocessing/passes/bv_intro_pow2.cpp
+++ b/src/preprocessing/passes/bv_intro_pow2.cpp
@@ -45,8 +45,9 @@ PreprocessingPassResult BvIntroPow2::applyInternal(
     Node res = pow2Rewrite(cur, cache);
     if (res != cur)
     {
-      res = rewrite(res);
-      assertionsToPreprocess->replace(i, res);
+      assertionsToPreprocess->replace(
+          i, res, nullptr, TrustId::PREPROCESS_BV_INTRO_POW2);
+      assertionsToPreprocess->ensureRewritten(i);
     }
   }
   return PreprocessingPassResult::NO_CONFLICT;
diff --git a/src/preprocessing/passes/bv_to_bool.cpp b/src/preprocessing/passes/bv_to_bool.cpp
index 27b0a866d..95ae0ecbd 100644
--- a/src/preprocessing/passes/bv_to_bool.cpp
+++ b/src/preprocessing/passes/bv_to_bool.cpp
@@ -52,7 +52,9 @@ PreprocessingPassResult BVToBool::applyInternal(
   liftBvToBool(assertionsToPreprocess->ref(), new_assertions);
   for (size_t i = 0, size = assertionsToPreprocess->size(); i < size; ++i)
   {
-    assertionsToPreprocess->replace(i, rewrite(new_assertions[i]));
+    assertionsToPreprocess->replace(
+        i, new_assertions[i], nullptr, TrustId::PREPROCESS_BV_TO_BOOL);
+    assertionsToPreprocess->ensureRewritten(i);
     if (assertionsToPreprocess->isInConflict())
     {
       return PreprocessingPassResult::CONFLICT;
diff --git a/src/preprocessing/passes/bv_to_int.cpp b/src/preprocessing/passes/bv_to_int.cpp
index f3e30b742..963994d0a 100644
--- a/src/preprocessing/passes/bv_to_int.cpp
+++ b/src/preprocessing/passes/bv_to_int.cpp
@@ -58,13 +58,8 @@ PreprocessingPassResult BVToInt::applyInternal(
   for (uint64_t i = 0; i < assertionsToPreprocess->size(); ++i)
   {
     // ensure bv rewritten
+    assertionsToPreprocess->ensureRewritten(i);
     Node bvNode = (*assertionsToPreprocess)[i];
-    Node bvnr = rewrite(bvNode);
-    if (bvnr != bvNode)
-    {
-      assertionsToPreprocess->replace(i, bvnr);
-      bvNode = bvnr;
-    }
     TrustNode tr =
         d_intBlaster.trustedIntBlast(bvNode, additionalConstraints, skolems);
     if (tr.isNull())
@@ -76,12 +71,7 @@ PreprocessingPassResult BVToInt::applyInternal(
     Trace("bv-to-int-debug") << "int node: " << tr.getProven()[1] << std::endl;
     assertionsToPreprocess->replaceTrusted(i, tr);
     // ensure integer rewritten
-    Node intNode = (*assertionsToPreprocess)[i];
-    Node inr = rewrite(intNode);
-    if (inr != intNode)
-    {
-      assertionsToPreprocess->replace(i, inr);
-    }
+    assertionsToPreprocess->ensureRewritten(i);
   }
   addFinalizeAssertions(assertionsToPreprocess, additionalConstraints);
   addSkolemDefinitions(skolems);
diff --git a/src/preprocessing/passes/ff_bitsum.cpp b/src/preprocessing/passes/ff_bitsum.cpp
index 8ce746718..3c72101f6 100644
--- a/src/preprocessing/passes/ff_bitsum.cpp
+++ b/src/preprocessing/passes/ff_bitsum.cpp
@@ -121,7 +121,8 @@ PreprocessingPassResult FfBitsum::applyInternal(
     Node newFact = cache[fact];
     if (newFact != fact)
     {
-      assertionsToPreprocess->replace(i, newFact);
+      assertionsToPreprocess->replace(
+          i, newFact, nullptr, TrustId::PREPROCESS_FF_BITSUM);
     }
   }
 
diff --git a/src/preprocessing/passes/ff_disjunctive_bit.cpp b/src/preprocessing/passes/ff_disjunctive_bit.cpp
index a7e87938c..f64372f9f 100644
--- a/src/preprocessing/passes/ff_disjunctive_bit.cpp
+++ b/src/preprocessing/passes/ff_disjunctive_bit.cpp
@@ -46,7 +46,10 @@ PreprocessingPassResult FfDisjunctiveBit::applyInternal(
     {
       Trace("ff::disjunctive-bit") << "rw bit constr: " << *var << std::endl;
       Node var2 = nm->mkNode(Kind::FINITE_FIELD_MULT, *var, *var);
-      assertionsToPreprocess->replace(i, var2.eqNode(*var));
+      assertionsToPreprocess->replace(i,
+                                      var2.eqNode(*var),
+                                      nullptr,
+                                      TrustId::PREPROCESS_FF_DISJUNCTIVE_BIT);
     }
   }
   return PreprocessingPassResult::NO_CONFLICT;
diff --git a/src/preprocessing/passes/foreign_theory_rewrite.cpp b/src/preprocessing/passes/foreign_theory_rewrite.cpp
index 86e5ed97e..af35e9fde 100644
--- a/src/preprocessing/passes/foreign_theory_rewrite.cpp
+++ b/src/preprocessing/passes/foreign_theory_rewrite.cpp
@@ -148,8 +148,15 @@ PreprocessingPassResult ForeignTheoryRewrite::applyInternal(
   for (size_t i = 0, nasserts = assertionsToPreprocess->size(); i < nasserts;
        ++i)
   {
+    const Node& a = (*assertionsToPreprocess)[i];
+    Node ar = d_ftr.simplify(a);
+    if (a == ar)
+    {
+      continue;
+    }
     assertionsToPreprocess->replace(
-        i, rewrite(d_ftr.simplify((*assertionsToPreprocess)[i])));
+        i, ar, nullptr, TrustId::PREPROCESS_FOREIGN_THEORY_REWRITE);
+    assertionsToPreprocess->ensureRewritten(i);
     if (assertionsToPreprocess->isInConflict())
     {
       return PreprocessingPassResult::CONFLICT;
diff --git a/src/preprocessing/passes/fun_def_fmf.cpp b/src/preprocessing/passes/fun_def_fmf.cpp
index a0cd3ca83..59885baf6 100644
--- a/src/preprocessing/passes/fun_def_fmf.cpp
+++ b/src/preprocessing/passes/fun_def_fmf.cpp
@@ -162,8 +162,9 @@ void FunDefFmf::process(AssertionPipeline* assertionsToPreprocess)
             << "FMF fun def: FUNCTION : rewrite " << assertions[i] << std::endl;
         Trace("fmf-fun-def") << "  to " << std::endl;
         Node new_q = nm->mkNode(Kind::FORALL, bvl, bd);
-        new_q = rewrite(new_q);
-        assertionsToPreprocess->replace(i, new_q);
+        assertionsToPreprocess->replace(
+            i, new_q, nullptr, TrustId::PREPROCESS_FUN_DEF_FMF);
+        assertionsToPreprocess->ensureRewritten(i);
         Trace("fmf-fun-def") << "  " << assertions[i] << std::endl;
         fd_assertions.push_back(i);
       }
@@ -201,7 +202,8 @@ void FunDefFmf::process(AssertionPipeline* assertionsToPreprocess)
           << "FMF fun def : rewrite " << assertions[i] << std::endl;
       Trace("fmf-fun-def-rewrite") << "  to " << std::endl;
       Trace("fmf-fun-def-rewrite") << "  " << n << std::endl;
-      assertionsToPreprocess->replace(i, n);
+      assertionsToPreprocess->replace(
+          i, n, nullptr, TrustId::PREPROCESS_FUN_DEF_FMF);
     }
   }
 }
diff --git a/src/preprocessing/passes/ho_elim.cpp b/src/preprocessing/passes/ho_elim.cpp
index f9fafa273..683238829 100644
--- a/src/preprocessing/passes/ho_elim.cpp
+++ b/src/preprocessing/passes/ho_elim.cpp
@@ -329,9 +329,10 @@ PreprocessingPassResult HoElim::applyInternal(
       Node res = eliminateLambdaComplete(prev, newLambda);
       if (res != prev)
       {
-        res = rewrite(res);
-        Assert(!expr::hasFreeVar(res));
-        assertionsToPreprocess->replace(i, res);
+        assertionsToPreprocess->replace(
+            i, res, nullptr, TrustId::PREPROCESS_HO_ELIM);
+        assertionsToPreprocess->ensureRewritten(i);
+        Assert(!expr::hasFreeVar((*assertionsToPreprocess)[i]));
       }
     }
     // do lambda lifting on new lambda definitions
@@ -378,7 +379,8 @@ PreprocessingPassResult HoElim::applyInternal(
       {
         Node axr = rewrite(ax);
         Assert(!expr::hasFreeVar(axr));
-        assertionsToPreprocess->push_back(axr);
+        assertionsToPreprocess->push_back(
+            axr, false, nullptr, TrustId::PREPROCESS_HO_ELIM_LEMMA);
       }
     }
     axioms.clear();
@@ -391,9 +393,10 @@ PreprocessingPassResult HoElim::applyInternal(
     Node res = eliminateHo(prev);
     if (res != prev)
     {
-      res = rewrite(res);
-      Assert(!expr::hasFreeVar(res));
-      assertionsToPreprocess->replace(i, res);
+      assertionsToPreprocess->replace(
+          i, res, nullptr, TrustId::PREPROCESS_HO_ELIM);
+      assertionsToPreprocess->ensureRewritten(i);
+      Assert(!expr::hasFreeVar((*assertionsToPreprocess)[i]));
     }
   }
   // extensionality: process all function types
@@ -477,7 +480,8 @@ PreprocessingPassResult HoElim::applyInternal(
     {
       Node axr = rewrite(ax);
       Assert(!expr::hasFreeVar(axr));
-      assertionsToPreprocess->push_back(axr);
+      assertionsToPreprocess->push_back(
+          axr, false, nullptr, TrustId::PREPROCESS_HO_ELIM_LEMMA);
     }
   }
 
diff --git a/src/preprocessing/passes/ite_simp.cpp b/src/preprocessing/passes/ite_simp.cpp
index 205ea69af..ae693f5da 100644
--- a/src/preprocessing/passes/ite_simp.cpp
+++ b/src/preprocessing/passes/ite_simp.cpp
@@ -184,7 +184,8 @@ bool ITESimp::doneSimpITE(AssertionPipeline* assertionsToPreprocess)
             Node more = aiteu.reduceConstantIteByGCD(res);
             Trace("arith::ite::red") << "  gcd->" << more << endl;
             Node morer = rewrite(more);
-            assertionsToPreprocess->replace(i, morer);
+            assertionsToPreprocess->replace(
+                i, morer, nullptr, TrustId::PREPROCESS_ITE_SIMP);
           }
         }
       }
@@ -224,7 +225,8 @@ bool ITESimp::doneSimpITE(AssertionPipeline* assertionsToPreprocess)
             Node more = aiteu.reduceConstantIteByGCD(res);
             Trace("arith::ite::red") << "  gcd->" << more << endl;
             Node morer = rewrite(more);
-            assertionsToPreprocess->replace(i, morer);
+            assertionsToPreprocess->replace(
+                i, morer, nullptr, TrustId::PREPROCESS_ITE_SIMP);
           }
         }
       }
@@ -252,7 +254,8 @@ PreprocessingPassResult ITESimp::applyInternal(
   {
     d_preprocContext->spendResource(Resource::PreprocessStep);
     Node simp = simpITE(&d_iteUtilities, (*assertionsToPreprocess)[i]);
-    assertionsToPreprocess->replace(i, simp);
+    assertionsToPreprocess->replace(
+        i, simp, nullptr, TrustId::PREPROCESS_ITE_SIMP);
     if (assertionsToPreprocess->isInConflict())
     {
       return PreprocessingPassResult::CONFLICT;
diff --git a/src/preprocessing/passes/learned_rewrite.cpp b/src/preprocessing/passes/learned_rewrite.cpp
index 7ce834f43..f48f061c1 100644
--- a/src/preprocessing/passes/learned_rewrite.cpp
+++ b/src/preprocessing/passes/learned_rewrite.cpp
@@ -135,7 +135,8 @@ PreprocessingPassResult LearnedRewrite::applyInternal(
           continue;
         }
         // conflict, we are done
-        assertionsToPreprocess->push_back(e);
+        assertionsToPreprocess->push_back(
+            e, false, nullptr, TrustId::PREPROCESS_LEARNED_REWRITE_LEMMA);
         return PreprocessingPassResult::CONFLICT;
       }
       llrw.insert(e);
@@ -154,7 +155,8 @@ PreprocessingPassResult LearnedRewrite::applyInternal(
       e = rewrite(e);
       Trace("learned-rewrite-assert")
           << ".......................: " << e << std::endl;
-      assertionsToPreprocess->replace(i, e);
+      assertionsToPreprocess->replace(
+          i, e, nullptr, TrustId::PREPROCESS_LEARNED_REWRITE);
       if (assertionsToPreprocess->isInConflict())
       {
         return PreprocessingPassResult::CONFLICT;
@@ -171,7 +173,8 @@ PreprocessingPassResult LearnedRewrite::applyInternal(
     Trace("learned-rewrite-assert")
         << "Re-add rewritten learned conjunction: " << llc << std::endl;
     llc = rewrite(llc);
-    assertionsToPreprocess->push_back(llc);
+    assertionsToPreprocess->push_back(
+        llc, false, nullptr, TrustId::PREPROCESS_LEARNED_REWRITE_LEMMA);
   }
 
   return PreprocessingPassResult::NO_CONFLICT;
diff --git a/src/preprocessing/passes/miplib_trick.cpp b/src/preprocessing/passes/miplib_trick.cpp
index 232e4172e..d3ea181f6 100644
--- a/src/preprocessing/passes/miplib_trick.cpp
+++ b/src/preprocessing/passes/miplib_trick.cpp
@@ -533,7 +533,8 @@ PreprocessingPassResult MipLibTrick::applyInternal(
               TrustNode tleq = TrustNode::mkTrustLemma(leq, nullptr);
 
               Node n = rewrite(geq.andNode(leq));
-              assertionsToPreprocess->push_back(n);
+              assertionsToPreprocess->push_back(
+                  n, false, nullptr, TrustId::PREPROCESS_MIPLIB_TRICK_LEMMA);
               TrustSubstitutionMap tnullMap(d_env, &fakeContext);
               CVC5_UNUSED SubstitutionMap& nullMap = tnullMap.get();
               Theory::PPAssertStatus status CVC5_UNUSED;  // just for assertions
@@ -596,7 +597,11 @@ PreprocessingPassResult MipLibTrick::applyInternal(
           newAssertion = rewrite(newAssertion);
           Trace("miplib") << "  " << newAssertion << endl;
 
-          assertionsToPreprocess->push_back(newAssertion);
+          assertionsToPreprocess->push_back(
+              newAssertion,
+              false,
+              nullptr,
+              TrustId::PREPROCESS_MIPLIB_TRICK_LEMMA);
           Trace("miplib") << "  assertions to remove: " << endl;
           for (vector<TNode>::const_iterator k = asserts[pos_var].begin(),
                                              k_end = asserts[pos_var].end();
@@ -619,7 +624,8 @@ PreprocessingPassResult MipLibTrick::applyInternal(
       if (removeAssertions.find(assertion.getId()) != removeAssertions.end())
       {
         Trace("miplib") << " - removing " << assertion << endl;
-        assertionsToPreprocess->replace(i, trueNode);
+        assertionsToPreprocess->replace(
+            i, trueNode, nullptr, TrustId::PREPROCESS_MIPLIB_TRICK);
         ++d_statistics.d_numMiplibAssertionsRemoved;
       }
       else if (assertion.getKind() == Kind::AND)
@@ -633,8 +639,11 @@ PreprocessingPassResult MipLibTrick::applyInternal(
         }
       }
       Trace("miplib") << "had: " << assertion << endl;
-      assertionsToPreprocess->replace(
-          i, rewrite(top_level_substs.apply(assertion)));
+      assertionsToPreprocess->replace(i,
+                                      top_level_substs.apply(assertion),
+                                      nullptr,
+                                      TrustId::PREPROCESS_MIPLIB_TRICK);
+      assertionsToPreprocess->ensureRewritten(i);
       Trace("miplib") << "now: " << assertion << endl;
       if (assertionsToPreprocess->isInConflict())
       {
diff --git a/src/preprocessing/passes/nl_ext_purify.cpp b/src/preprocessing/passes/nl_ext_purify.cpp
index 013fa7eb3..ad6b30372 100644
--- a/src/preprocessing/passes/nl_ext_purify.cpp
+++ b/src/preprocessing/passes/nl_ext_purify.cpp
@@ -125,7 +125,8 @@ PreprocessingPassResult NlExtPurify::applyInternal(
     Node ap = purifyNlTerms(a, cache, bcache, var_eq);
     if (a != ap)
     {
-      assertionsToPreprocess->replace(i, ap);
+      assertionsToPreprocess->replace(
+          i, ap, nullptr, TrustId::PREPROCESS_NL_EXT_PURIFY);
       Trace("nl-ext-purify")
           << "Purify : " << a << " -> " << (*assertionsToPreprocess)[i] << "\n";
     }
@@ -134,7 +135,8 @@ PreprocessingPassResult NlExtPurify::applyInternal(
   {
     for (const Node& ve : var_eq)
     {
-      assertionsToPreprocess->push_back(ve);
+      assertionsToPreprocess->push_back(
+          ve, false, nullptr, TrustId::PREPROCESS_NL_EXT_PURIFY_LEMMA);
     }
   }
   return PreprocessingPassResult::NO_CONFLICT;
diff --git a/src/preprocessing/passes/non_clausal_simp.cpp b/src/preprocessing/passes/non_clausal_simp.cpp
index abbcd80ca..ef0295d2e 100644
--- a/src/preprocessing/passes/non_clausal_simp.cpp
+++ b/src/preprocessing/passes/non_clausal_simp.cpp
@@ -117,13 +117,12 @@ PreprocessingPassResult NonClausalSimp::applyInternal(
   CVC5_UNUSED SubstitutionMap& top_level_substs = ttls.get();
   // constant propagations
   std::shared_ptr<TrustSubstitutionMap> constantPropagations =
-      std::make_shared<TrustSubstitutionMap>(
-          d_env, u, "NonClausalSimp::cprop", TrustId::PREPROCESS_LEMMA);
+      std::make_shared<TrustSubstitutionMap>(d_env, u, "NonClausalSimp::cprop");
   SubstitutionMap& cps = constantPropagations->get();
   // new substitutions
   std::shared_ptr<TrustSubstitutionMap> newSubstitutions =
       std::make_shared<TrustSubstitutionMap>(
-          d_env, u, "NonClausalSimp::newSubs", TrustId::PREPROCESS_LEMMA);
+          d_env, u, "NonClausalSimp::newSubs");
   SubstitutionMap& nss = newSubstitutions->get();
 
   size_t j = 0;
diff --git a/src/preprocessing/passes/quantifiers_preprocess.cpp b/src/preprocessing/passes/quantifiers_preprocess.cpp
index db751f4da..98a747043 100644
--- a/src/preprocessing/passes/quantifiers_preprocess.cpp
+++ b/src/preprocessing/passes/quantifiers_preprocess.cpp
@@ -45,7 +45,9 @@ PreprocessingPassResult QuantifiersPreprocess::applyInternal(
     if (!trn.isNull())
     {
       Node next = trn.getNode();
-      assertionsToPreprocess->replace(i, rewrite(next));
+      assertionsToPreprocess->replace(
+          i, next, nullptr, TrustId::PREPROCESS_QUANTIFIERS_PP);
+      assertionsToPreprocess->ensureRewritten(i);
       Trace("quantifiers-preprocess") << "*** Pre-skolemize " << prev << endl;
       Trace("quantifiers-preprocess")
           << "   ...got " << (*assertionsToPreprocess)[i] << endl;
diff --git a/src/preprocessing/passes/sort_infer.cpp b/src/preprocessing/passes/sort_infer.cpp
index b2a3533b5..713c38306 100644
--- a/src/preprocessing/passes/sort_infer.cpp
+++ b/src/preprocessing/passes/sort_infer.cpp
@@ -51,8 +51,9 @@ PreprocessingPassResult SortInferencePass::applyInternal(
       Node next = si->simplify(prev, model_replace_f, visited);
       if (next != prev)
       {
-        next = rewrite(next);
-        assertionsToPreprocess->replace(i, next);
+        assertionsToPreprocess->replace(
+            i, next, nullptr, TrustId::PREPROCESS_SORT_INFER);
+        assertionsToPreprocess->ensureRewritten(i);
         Trace("sort-infer-preprocess")
             << "*** Preprocess SortInferencePass " << prev << endl;
         Trace("sort-infer-preprocess")
@@ -67,7 +68,8 @@ PreprocessingPassResult SortInferencePass::applyInternal(
       Trace("sort-infer-preprocess")
           << "*** Preprocess SortInferencePass : new constraint " << nar
           << endl;
-      assertionsToPreprocess->push_back(nar);
+      assertionsToPreprocess->push_back(
+          nar, false, nullptr, TrustId::PREPROCESS_SORT_INFER_LEMMA);
     }
     // could indicate correspondence between the functions
     // for (f1, f2) in model_replace_f, f1's model should be based on f2.
diff --git a/src/preprocessing/passes/static_learning.cpp b/src/preprocessing/passes/static_learning.cpp
index f339e8072..4a5e5b321 100644
--- a/src/preprocessing/passes/static_learning.cpp
+++ b/src/preprocessing/passes/static_learning.cpp
@@ -60,7 +60,8 @@ PreprocessingPassResult StaticLearning::applyInternal(
     // add the lemmas to the end
     for (const TrustNode& trn : tlems)
     {
-      assertionsToPreprocess->pushBackTrusted(trn);
+      assertionsToPreprocess->pushBackTrusted(
+          trn, TrustId::PREPROCESS_STATIC_LEARNING_LEMMA);
     }
   }
   return PreprocessingPassResult::NO_CONFLICT;
diff --git a/src/preprocessing/passes/strings_eager_pp.cpp b/src/preprocessing/passes/strings_eager_pp.cpp
index cddd6538c..fea7107a1 100644
--- a/src/preprocessing/passes/strings_eager_pp.cpp
+++ b/src/preprocessing/passes/strings_eager_pp.cpp
@@ -49,7 +49,9 @@ PreprocessingPassResult StringsEagerPp::applyInternal(
     }
     if (prev != rew)
     {
-      assertionsToPreprocess->replace(i, rewrite(rew));
+      assertionsToPreprocess->replace(
+          i, rew, nullptr, TrustId::PREPROCESS_STRINGS_EAGER_PP);
+      assertionsToPreprocess->ensureRewritten(i);
       if (assertionsToPreprocess->isInConflict())
       {
         return PreprocessingPassResult::CONFLICT;
diff --git a/src/preprocessing/passes/theory_preprocess.cpp b/src/preprocessing/passes/theory_preprocess.cpp
index 38e04eaed..1b443244c 100644
--- a/src/preprocessing/passes/theory_preprocess.cpp
+++ b/src/preprocessing/passes/theory_preprocess.cpp
@@ -49,7 +49,7 @@ PreprocessingPassResult TheoryPreprocess::applyInternal(
     if (!trn.isNull())
     {
       // process
-      assertions->replaceTrusted(i, trn);
+      assertions->replaceTrusted(i, trn, TrustId::THEORY_PREPROCESS);
       if (assertions->isInConflict())
       {
         return PreprocessingPassResult::CONFLICT;
@@ -58,7 +58,8 @@ PreprocessingPassResult TheoryPreprocess::applyInternal(
     for (const SkolemLemma& lem : newAsserts)
     {
       imap[assertions->size()] = lem.d_skolem;
-      assertions->pushBackTrusted(lem.d_lemma);
+      assertions->pushBackTrusted(lem.d_lemma,
+                                  TrustId::THEORY_PREPROCESS_LEMMA);
     }
   }
 
diff --git a/src/preprocessing/passes/unconstrained_simplifier.cpp b/src/preprocessing/passes/unconstrained_simplifier.cpp
index 845d9a0a4..4dfc485a4 100644
--- a/src/preprocessing/passes/unconstrained_simplifier.cpp
+++ b/src/preprocessing/passes/unconstrained_simplifier.cpp
@@ -858,9 +858,15 @@ PreprocessingPassResult UnconstrainedSimplifier::applyInternal(
     for (size_t i = 0, asize = assertions.size(); i < asize; ++i)
     {
       Node a = assertions[i];
-      Node as = rewrite(d_substitutions.apply(a));
-      // replace the assertion
-      assertionsToPreprocess->replace(i, as);
+      Node as = d_substitutions.apply(a);
+      // nothing to do if substitutions has no effect, skip
+      if (as != a)
+      {
+        // replace the assertion
+        assertionsToPreprocess->replace(
+            i, as, nullptr, TrustId::PREPROCESS_UNCONSTRAINED_SIMP);
+        assertionsToPreprocess->ensureRewritten(i);
+      }
     }
   }
 
diff --git a/src/proof/trust_id.cpp b/src/proof/trust_id.cpp
index e75911f0c..ab14fd248 100644
--- a/src/proof/trust_id.cpp
+++ b/src/proof/trust_id.cpp
@@ -27,14 +27,57 @@ const char* toString(TrustId id)
   switch (id)
   {
     case TrustId::NONE: return "NONE";
+    // core
     case TrustId::THEORY_LEMMA: return "THEORY_LEMMA";
     case TrustId::THEORY_INFERENCE: return "THEORY_INFERENCE";
-    case TrustId::PREPROCESS: return "PREPROCESS";
-    case TrustId::PREPROCESS_LEMMA: return "PREPROCESS_LEMMA";
     case TrustId::PP_STATIC_REWRITE: return "PP_STATIC_REWRITE";
     case TrustId::THEORY_PREPROCESS: return "THEORY_PREPROCESS";
     case TrustId::THEORY_PREPROCESS_LEMMA: return "THEORY_PREPROCESS_LEMMA";
     case TrustId::THEORY_EXPAND_DEF: return "THEORY_EXPAND_DEF";
+    // preprocess passes
+    case TrustId::PREPROCESS_BV_GUASS: return "PREPROCESS_BV_GUASS";
+    case TrustId::PREPROCESS_BV_GUASS_LEMMA: return "PREPROCESS_BV_GUASS_LEMMA";
+    case TrustId::PREPROCESS_BV_TO_BOOL: return "PREPROCESS_BV_TO_BOOL";
+    case TrustId::PREPROCESS_BV_TO_INT: return "PREPROCESS_BV_TO_INT";
+    case TrustId::PREPROCESS_BV_TO_INT_LEMMA:
+      return "PREPROCESS_BV_TO_INT_LEMMA";
+    case TrustId::PREPROCESS_BOOL_TO_BV: return "PREPROCESS_BOOL_TO_BV";
+    case TrustId::PREPROCESS_ACKERMANN: return "PREPROCESS_ACKERMANN";
+    case TrustId::PREPROCESS_ACKERMANN_LEMMA:
+      return "PREPROCESS_ACKERMANN_LEMMA";
+    case TrustId::PREPROCESS_STATIC_LEARNING_LEMMA:
+      return "PREPROCESS_STATIC_LEARNING_LEMMA";
+    case TrustId::PREPROCESS_HO_ELIM: return "PREPROCESS_HO_ELIM";
+    case TrustId::PREPROCESS_HO_ELIM_LEMMA: return "PREPROCESS_HO_ELIM_LEMMA";
+    case TrustId::PREPROCESS_BITVECTOR_EAGER_ATOMS:
+      return "PREPROCESS_BITVECTOR_EAGER_ATOMS";
+    case TrustId::PREPROCESS_FF_BITSUM: return "PREPROCESS_FF_BITSUM";
+    case TrustId::PREPROCESS_FF_DISJUNCTIVE_BIT:
+      return "PREPROCESS_FF_DISJUNCTIVE_BIT";
+    case TrustId::PREPROCESS_FUN_DEF_FMF: return "PREPROCESS_FUN_DEF_FMF";
+    case TrustId::PREPROCESS_ITE_SIMP: return "PREPROCESS_ITE_SIMP";
+    case TrustId::PREPROCESS_LEARNED_REWRITE:
+      return "PREPROCESS_LEARNED_REWRITE";
+    case TrustId::PREPROCESS_LEARNED_REWRITE_LEMMA:
+      return "PREPROCESS_LEARNED_REWRITE_LEMMA";
+    case TrustId::PREPROCESS_MIPLIB_TRICK: return "PREPROCESS_MIPLIB_TRICK";
+    case TrustId::PREPROCESS_MIPLIB_TRICK_LEMMA:
+      return "PREPROCESS_MIPLIB_TRICK_LEMMA";
+    case TrustId::PREPROCESS_NL_EXT_PURIFY: return "PREPROCESS_NL_EXT_PURIFY";
+    case TrustId::PREPROCESS_NL_EXT_PURIFY_LEMMA:
+      return "PREPROCESS_NL_EXT_PURIFY_LEMMA";
+    case TrustId::PREPROCESS_BV_INTRO_POW2: return "PREPROCESS_BV_INTRO_POW2";
+    case TrustId::PREPROCESS_FOREIGN_THEORY_REWRITE:
+      return "PREPROCESS_FOREIGN_THEORY_REWRITE";
+    case TrustId::PREPROCESS_UNCONSTRAINED_SIMP:
+      return "PREPROCESS_UNCONSTRAINED_SIMP";
+    case TrustId::PREPROCESS_QUANTIFIERS_PP: return "PREPROCESS_QUANTIFIERS_PP";
+    case TrustId::PREPROCESS_SORT_INFER: return "PREPROCESS_SORT_INFER";
+    case TrustId::PREPROCESS_SORT_INFER_LEMMA:
+      return "PREPROCESS_SORT_INFER_LEMMA";
+    case TrustId::PREPROCESS_STRINGS_EAGER_PP:
+      return "PREPROCESS_STRINGS_EAGER_PP";
+    // other
     case TrustId::ARITH_NL_COVERING_DIRECT: return "ARITH_NL_COVERING_DIRECT";
     case TrustId::ARITH_NL_COVERING_RECURSIVE:
       return "ARITH_NL_COVERING_RECURSIVE";
@@ -54,6 +97,9 @@ const char* toString(TrustId id)
     case TrustId::MACRO_THEORY_REWRITE_RCONS_SIMPLE:
       return "MACRO_THEORY_REWRITE_RCONS_SIMPLE";
     case TrustId::INT_BLASTER: return "INT_BLASTER";
+    // unknown sources
+    case TrustId::UNKNOWN_PREPROCESS: return "UNKNOWN_PREPROCESS";
+    case TrustId::UNKNOWN_PREPROCESS_LEMMA: return "UNKNOWN_PREPROCESS_LEMMA";
     default: return "TrustId::Unknown";
   };
 }
diff --git a/src/proof/trust_id.h b/src/proof/trust_id.h
index 8347cb045..184f65206 100644
--- a/src/proof/trust_id.h
+++ b/src/proof/trust_id.h
@@ -32,10 +32,6 @@ enum class TrustId : uint32_t
   THEORY_LEMMA,
   /** An internal inference made by a theory without a proof */
   THEORY_INFERENCE,
-  /** A rewrite of the input formula by a preprocessing pass without a proof */
-  PREPROCESS,
-  /** A lemma added during preprocessing without a proof */
-  PREPROCESS_LEMMA,
   /** A ppStaticRewrite step */
   PP_STATIC_REWRITE,
   /** A rewrite of the input formula made by a theory during preprocessing
@@ -45,7 +41,57 @@ enum class TrustId : uint32_t
   THEORY_PREPROCESS_LEMMA,
   /** A expanding of definitions of the input formula made without a proof */
   THEORY_EXPAND_DEF,
-
+  /** Specific preprocessing passes */
+  /** BvGauss */
+  PREPROCESS_BV_GUASS,
+  PREPROCESS_BV_GUASS_LEMMA,
+  /** BvToBool preprocessing pass */
+  PREPROCESS_BV_TO_BOOL,
+  /** BvToInt preprocessing pass */
+  PREPROCESS_BV_TO_INT,
+  PREPROCESS_BV_TO_INT_LEMMA,
+  /** BoolToBv preprocessing pass */
+  PREPROCESS_BOOL_TO_BV,
+  /** Ackermann preprocessing pass */
+  PREPROCESS_ACKERMANN,
+  PREPROCESS_ACKERMANN_LEMMA,
+  /** StaticLearning preprocessing pass */
+  PREPROCESS_STATIC_LEARNING_LEMMA,
+  /** HoElim preprocessing pass */
+  PREPROCESS_HO_ELIM,
+  PREPROCESS_HO_ELIM_LEMMA,
+  /** BitvectorEagerAtoms preprocessing pass */
+  PREPROCESS_BITVECTOR_EAGER_ATOMS,
+  /** FfBitsum preprocessing pass */
+  PREPROCESS_FF_BITSUM,
+  /** FfDisjunctiveBit preprocessing pass */
+  PREPROCESS_FF_DISJUNCTIVE_BIT,
+  /** FunDefFmf preprocessing pass */
+  PREPROCESS_FUN_DEF_FMF,
+  /** ITESimp preprocessing pass */
+  PREPROCESS_ITE_SIMP,
+  /** LearnedRewrite preprocessing pass */
+  PREPROCESS_LEARNED_REWRITE,
+  PREPROCESS_LEARNED_REWRITE_LEMMA,
+  /** MipLibTrick preprocessing pass */
+  PREPROCESS_MIPLIB_TRICK,
+  PREPROCESS_MIPLIB_TRICK_LEMMA,
+  /** NlExtPurify preprocessing pass */
+  PREPROCESS_NL_EXT_PURIFY,
+  PREPROCESS_NL_EXT_PURIFY_LEMMA,
+  /** BvIntroPow2 preprocessing pass */
+  PREPROCESS_BV_INTRO_POW2,
+  /** ForeignTheoryRewrite preprocessing pass */
+  PREPROCESS_FOREIGN_THEORY_REWRITE,
+  /** UnconstrainedSimp preprocessing pass */
+  PREPROCESS_UNCONSTRAINED_SIMP,
+  /** QuantifiersPreprocess preprocessing pass */
+  PREPROCESS_QUANTIFIERS_PP,
+  /** SortInferencePass preprocessing pass */
+  PREPROCESS_SORT_INFER,
+  PREPROCESS_SORT_INFER_LEMMA,
+  /** StringsEagerPp preprocessing pass */
+  PREPROCESS_STRINGS_EAGER_PP,
   /**
    * We use :math:`\texttt{IRP}_k(poly)` for an IndexedRootPredicate that is
    * defined as the :math:`k`'th root of the polynomial :math:`poly`. Note that
@@ -137,6 +183,11 @@ enum class TrustId : uint32_t
   MACRO_THEORY_REWRITE_RCONS_SIMPLE,
   /** An unproven step from the int-blaster */
   INT_BLASTER,
+  /** Untracked sources of trust, which are discouraged */
+  /** A rewrite of the input formula by a preprocessing pass without a proof */
+  UNKNOWN_PREPROCESS,
+  /** A lemma added during preprocessing without a proof */
+  UNKNOWN_PREPROCESS_LEMMA,
 };
 /** Converts a trust id to a string. */
 const char* toString(TrustId id);
diff --git a/src/smt/preprocess_proof_generator.cpp b/src/smt/preprocess_proof_generator.cpp
index 949eda21a..c0de33560 100644
--- a/src/smt/preprocess_proof_generator.cpp
+++ b/src/smt/preprocess_proof_generator.cpp
@@ -30,16 +30,16 @@
 namespace cvc5::internal {
 namespace smt {
 
-PreprocessProofGenerator::PreprocessProofGenerator(
-    Env& env, context::Context* c, std::string name, TrustId ra, TrustId rpp)
+PreprocessProofGenerator::PreprocessProofGenerator(Env& env,
+                                                   context::Context* c,
+                                                   std::string name)
     : EnvObj(env),
       d_ctx(c ? c : &d_context),
       d_src(d_ctx),
       d_helperProofs(env, d_ctx, "PreprocessHelper"),
       d_inputPf(env, c, "InputProof"),
-      d_name(name),
-      d_ra(ra),
-      d_rpp(rpp)
+      d_trustPf(env, c, "PreprocessTrustProof"),
+      d_name(name)
 {
 }
 
@@ -48,7 +48,9 @@ void PreprocessProofGenerator::notifyInput(Node n)
   notifyNewAssert(n, &d_inputPf);
 }
 
-void PreprocessProofGenerator::notifyNewAssert(Node n, ProofGenerator* pg)
+void PreprocessProofGenerator::notifyNewAssert(Node n,
+                                               ProofGenerator* pg,
+                                               TrustId id)
 {
   if (n.isConst() && n.getConst<bool>())
   {
@@ -63,7 +65,10 @@ void PreprocessProofGenerator::notifyNewAssert(Node n, ProofGenerator* pg)
     // if no proof generator provided for (non-true) assertion
     if (pg == nullptr)
     {
-      checkEagerPedantic(d_ra);
+      Assert(id != TrustId::UNKNOWN_PREPROCESS_LEMMA);
+      // if no proof generator provided, use a trust step
+      d_trustPf.addTrustedStep(n, id, {}, {});
+      pg = &d_trustPf;
     }
     d_src[n] = TrustNode::mkTrustLemma(n, pg);
   }
@@ -73,14 +78,15 @@ void PreprocessProofGenerator::notifyNewAssert(Node n, ProofGenerator* pg)
   }
 }
 
-void PreprocessProofGenerator::notifyNewTrustedAssert(TrustNode tn)
+void PreprocessProofGenerator::notifyNewTrustedAssert(TrustNode tn, TrustId id)
 {
-  notifyNewAssert(tn.getProven(), tn.getGenerator());
+  notifyNewAssert(tn.getProven(), tn.getGenerator(), id);
 }
 
 void PreprocessProofGenerator::notifyPreprocessed(Node n,
                                                   Node np,
-                                                  ProofGenerator* pg)
+                                                  ProofGenerator* pg,
+                                                  TrustId id)
 {
   // only do anything if indeed it rewrote
   if (n == np)
@@ -88,10 +94,11 @@ void PreprocessProofGenerator::notifyPreprocessed(Node n,
     return;
   }
   // call the trusted version
-  notifyTrustedPreprocessed(TrustNode::mkTrustRewrite(n, np, pg));
+  notifyTrustedPreprocessed(TrustNode::mkTrustRewrite(n, np, pg), id);
 }
 
-void PreprocessProofGenerator::notifyTrustedPreprocessed(TrustNode tnp)
+void PreprocessProofGenerator::notifyTrustedPreprocessed(TrustNode tnp,
+                                                         TrustId id)
 {
   if (tnp.isNull())
   {
@@ -106,7 +113,9 @@ void PreprocessProofGenerator::notifyTrustedPreprocessed(TrustNode tnp)
   {
     if (tnp.getGenerator() == nullptr)
     {
-      checkEagerPedantic(d_rpp);
+      // if no proof generator provided, use a trust step
+      d_trustPf.addTrustedStep(tnp.getProven(), id, {}, {});
+      tnp = TrustNode::mkReplaceGenTrustNode(tnp, &d_trustPf);
     }
     d_src[np] = tnp;
   }
@@ -189,14 +198,19 @@ std::shared_ptr<ProofNode> PreprocessProofGenerator::getProofFor(Node f)
         Assert(tnk == TrustNodeKind::LEMMA);
       }
 
+      Assert(proofStepProcessed) << "Failed to get proof for preprocess step";
+      // if we had a dynamic failure, e.g. the provided proof generator did
+      // not generate a proof
       if (!proofStepProcessed)
       {
+        // if in production, we get an unknown trust step
+        TrustId id = (tnk == TrustNodeKind::LEMMA)
+                         ? TrustId::UNKNOWN_PREPROCESS_LEMMA
+                         : TrustId::UNKNOWN_PREPROCESS;
         Trace("smt-pppg-debug")
-            << "...justify missing step with "
-            << (tnk == TrustNodeKind::LEMMA ? d_ra : d_rpp) << std::endl;
+            << "...justify missing step with " << id << std::endl;
         // add trusted step, the rule depends on the kind of trust node
-        Node tid = mkTrustId(tnk == TrustNodeKind::LEMMA ? d_ra : d_rpp);
-        cdp.addStep(proven, ProofRule::TRUST, {}, {tid, proven});
+        cdp.addTrustedStep(proven, id, {}, {});
       }
     }
   } while (success);
diff --git a/src/smt/preprocess_proof_generator.h b/src/smt/preprocess_proof_generator.h
index a879e491b..599d205b7 100644
--- a/src/smt/preprocess_proof_generator.h
+++ b/src/smt/preprocess_proof_generator.h
@@ -64,16 +64,10 @@ class PreprocessProofGenerator : protected EnvObj, public ProofGenerator
    * @param env Reference to the environment
    * @param c The context this class depends on
    * @param name The name of this generator (for debugging)
-   * @param ra The id to use when no generator is provided for new
-   * assertions
-   * @param rpp The id to use when no generator is provided for
-   * preprocessing steps.
    */
   PreprocessProofGenerator(Env& env,
                            context::Context* c = nullptr,
-                           std::string name = "PreprocessProofGenerator",
-                           TrustId ra = TrustId::PREPROCESS_LEMMA,
-                           TrustId rpp = TrustId::PREPROCESS);
+                           std::string name = "PreprocessProofGenerator");
   ~PreprocessProofGenerator() {}
   /**
    * Notify that n is an input (its proof is ASSUME).
@@ -81,17 +75,37 @@ class PreprocessProofGenerator : protected EnvObj, public ProofGenerator
   void notifyInput(Node n);
   /**
    * Notify that n is a new assertion, where pg can provide a proof of n.
+   *
+   * @param n The formula to assert.
+   * @param pg The proof generator that may provide a proof of n.
+   * @param id The trust id to use, if pg is nullptr.
    */
-  void notifyNewAssert(Node n, ProofGenerator* pg);
-  /**  Notify a new assertion, trust node version. */
-  void notifyNewTrustedAssert(TrustNode tn);
+  void notifyNewAssert(Node n,
+                       ProofGenerator* pg,
+                       TrustId id = TrustId::UNKNOWN_PREPROCESS_LEMMA);
+  /**
+   * Notify a new assertion, trust node version.
+   *
+   * @param tn The trust node
+   * @param id The trust id to use, if the generator of the trust node is null.
+   */
+  void notifyNewTrustedAssert(TrustNode tn,
+                              TrustId id = TrustId::UNKNOWN_PREPROCESS_LEMMA);
   /**
    * Notify that n was replaced by np due to preprocessing, where pg can
    * provide a proof of the equality n=np.
+   * @param n The original formula.
+   * @param np The preprocessed formula.
+   * @param pg The proof generator that may provide a proof of (= n np).
+   * @param id The trust id to use, if the proof generator is null.
    */
-  void notifyPreprocessed(Node n, Node np, ProofGenerator* pg);
+  void notifyPreprocessed(Node n,
+                          Node np,
+                          ProofGenerator* pg,
+                          TrustId id = TrustId::UNKNOWN_PREPROCESS);
   /** Notify preprocessed, trust node version */
-  void notifyTrustedPreprocessed(TrustNode tnp);
+  void notifyTrustedPreprocessed(TrustNode tnp,
+                                 TrustId id = TrustId::UNKNOWN_PREPROCESS);
   /**
    * Get proof for f, which returns a proof based on proving an equality based
    * on transitivity of preprocessing steps, and then using the original
@@ -133,12 +147,13 @@ class PreprocessProofGenerator : protected EnvObj, public ProofGenerator
    * returns (ASSUME f) for all f.
    */
   CDProof d_inputPf;
+  /**
+   * A cd proof used for when preprocessing steps are not given justification.
+   * Stores only trust steps.
+   */
+  CDProof d_trustPf;
   /** Name for debugging */
   std::string d_name;
-  /** The trust rule for new assertions with no provided proof generator */
-  TrustId d_ra;
-  /** The trust rule for rewrites with no provided proof generator */
-  TrustId d_rpp;
 };
 
 }  // namespace smt
diff --git a/src/theory/trust_substitutions.h b/src/theory/trust_substitutions.h
index c18f6d1a1..09bad7044 100644
--- a/src/theory/trust_substitutions.h
+++ b/src/theory/trust_substitutions.h
@@ -44,7 +44,7 @@ class TrustSubstitutionMap : protected EnvObj, public ProofGenerator
   TrustSubstitutionMap(Env& env,
                        context::Context* c,
                        std::string name = "TrustSubstitutionMap",
-                       TrustId trustId = TrustId::PREPROCESS_LEMMA,
+                       TrustId trustId = TrustId::UNKNOWN_PREPROCESS_LEMMA,
                        MethodId ids = MethodId::SB_DEFAULT);
   /** Gets a reference to the underlying substitution map */
   SubstitutionMap& get();
-- 
2.47.1

