From 809af1833f5f413c7d24582b73700d0b525ef212 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Sat, 11 Jan 2025 08:16:09 -0600
Subject: [PATCH 293/312] Move several string rewrites to extended rewrites
 (#11509)

This is work towards eliminating nested calls to the rewriter from
within the strings theory rewriter.

Several rewrites of this form are now "demoted" to the extended
rewriter.

This is part of a branch that shows no difference in performance wrt
main on SMT-LIB and is roughly 2% faster on an industrial set of
interest.
---
 src/theory/quantifiers/extended_rewrite.cpp | 116 +++++++++++++++++++-
 src/theory/strings/rewrites.cpp             |   4 -
 src/theory/strings/rewrites.h               |   4 -
 src/theory/strings/sequences_rewriter.cpp   |  88 ---------------
 4 files changed, 111 insertions(+), 101 deletions(-)

diff --git a/src/theory/quantifiers/extended_rewrite.cpp b/src/theory/quantifiers/extended_rewrite.cpp
index 76c752a7c..b9e44bde5 100644
--- a/src/theory/quantifiers/extended_rewrite.cpp
+++ b/src/theory/quantifiers/extended_rewrite.cpp
@@ -25,6 +25,7 @@
 #include "theory/strings/arith_entail.h"
 #include "theory/strings/sequences_rewriter.h"
 #include "theory/strings/word.h"
+#include "theory/strings/theory_strings_utils.h"
 #include "theory/theory.h"
 
 using namespace cvc5::internal::kind;
@@ -233,13 +234,29 @@ Node ExtendedRewriter::extendedRewrite(Node n) const
     {
       debugExtendedRewrite(ret, new_ret, "Bool eq-chain simplify");
     }
-    else if (ret[0].getType().isInteger())
+    else
     {
-      theory::strings::ArithEntail ae(&d_rew);
-      new_ret = ae.rewritePredViaEntailment(ret);
-      if (!new_ret.isNull())
+      TypeNode tret = ret[0].getType();
+      if (tret.isInteger())
       {
-        debugExtendedRewrite(ret, new_ret, "String EQUAL len entailment");
+        theory::strings::ArithEntail ae(&d_rew);
+        new_ret = ae.rewritePredViaEntailment(ret);
+        if (!new_ret.isNull())
+        {
+          debugExtendedRewrite(ret, new_ret, "String EQUAL len entailment");
+        }
+      }
+      else if (tret.isStringLike())
+      {
+        Node len0 = d_nm->mkNode(Kind::STRING_LENGTH, ret[0]);
+        Node len1 = d_nm->mkNode(Kind::STRING_LENGTH, ret[1]);
+        Node len_eq = len0.eqNode(len1);
+        len_eq = d_rew.rewrite(len_eq);
+        if (len_eq.isConst() && !len_eq.getConst<bool>())
+        {
+          new_ret = len_eq;
+          debugExtendedRewrite(ret, new_ret, "String EQUAL len entailment");
+        }
       }
     }
   }
@@ -1765,6 +1782,95 @@ Node ExtendedRewriter::extendedRewriteStrings(const Node& node) const
       return ret;
     }
   }
+  else if (k == Kind::STRING_REPLACE)
+  {
+    if (node[0] == node[2])
+    {
+      theory::strings::ArithEntail ae(&d_rew);
+      theory::strings::StringsEntail se(&d_rew, ae, nullptr);
+      // (str.replace x y x) ---> (str.replace x (str.++ y1 ... yn) x)
+      // if 1 >= (str.len x) and (= y "") ---> (= y1 "") ... (= yn "")
+      if (se.checkLengthOne(node[0]))
+      {
+        TypeNode stype = node.getType();
+        Node empty = strings::Word::mkEmptyWord(stype);
+        Node rn1 = d_rew.rewrite(
+            d_rew.rewriteEqualityExt(d_nm->mkNode(Kind::EQUAL, node[1], empty)));
+        if (rn1 != node[1])
+        {
+          std::vector<Node> emptyNodes;
+          bool allEmptyEqs;
+          std::tie(allEmptyEqs, emptyNodes) = strings::utils::collectEmptyEqs(rn1);
+
+          if (allEmptyEqs)
+          {
+            Node nn1 = strings::utils::mkConcat(emptyNodes, stype);
+            if (node[1] != nn1)
+            {
+              Node ret = d_nm->mkNode(Kind::STRING_REPLACE, node[0], nn1, node[2]);
+              debugExtendedRewrite(node, ret, "RPL_X_Y_X_SIMP");
+              return ret;
+            }
+          }
+        }
+      }
+    }
+    Node cmp_con = d_nm->mkNode(Kind::STRING_CONTAINS, node[0], node[1]);
+    Node cmp_conr = d_rew.rewrite(cmp_con);
+    if (cmp_conr.getKind() == Kind::EQUAL || cmp_conr.getKind() == Kind::AND)
+    {
+      TypeNode stype = node.getType();
+      // Rewriting the str.contains may return equalities of the form (= x "").
+      // In that case, we can substitute the variables appearing in those
+      // equalities with the empty string in the third argument of the
+      // str.replace. For example:
+      //
+      // (str.replace x (str.++ x y) y) --> (str.replace x (str.++ x y) "")
+      //
+      // This can be done because str.replace changes x iff (str.++ x y) is in x
+      // but that means that y must be empty in that case. Thus, we can
+      // substitute y with "" in the third argument. Note that the third argument
+      // does not matter when the str.replace does not apply.
+      //
+      Node empty = strings::Word::mkEmptyWord(stype);
+      std::vector<Node> emptyNodes;
+      bool allEmptyEqs;
+      std::tie(allEmptyEqs, emptyNodes) = strings::utils::collectEmptyEqs(cmp_conr);
+      if (emptyNodes.size() > 0)
+      {
+        // Perform the substitutions
+        std::vector<TNode> substs(emptyNodes.size(), TNode(empty));
+        Node nn2 = node[2].substitute(
+            emptyNodes.begin(), emptyNodes.end(), substs.begin(), substs.end());
+
+        // If the contains rewrites to a conjunction of empty-string equalities
+        // and we are doing the replacement in an empty string, we can rewrite
+        // the string-to-replace with a concatenation of all the terms that must
+        // be empty:
+        //
+        // (str.replace "" y z) ---> (str.replace "" (str.++ y1 ... yn)  z)
+        // if (str.contains "" y) ---> (and (= y1 "") ... (= yn ""))
+        if (node[0] == empty && allEmptyEqs)
+        {
+          std::vector<Node> emptyNodesList(emptyNodes.begin(), emptyNodes.end());
+          Node nn1 = strings::utils::mkConcat(emptyNodesList, stype);
+          if (nn1 != node[1] || nn2 != node[2])
+          {
+            Node res = d_nm->mkNode(Kind::STRING_REPLACE, node[0], nn1, nn2);
+            debugExtendedRewrite(node, res, "RPL_EMP_CNTS_SUBSTS");
+            return res;
+          }
+        }
+
+        if (nn2 != node[2])
+        {
+          Node res = d_nm->mkNode(Kind::STRING_REPLACE, node[0], node[1], nn2);
+          debugExtendedRewrite(node, res, "RPL_CNTS_SUBSTS");
+          return res;
+        }
+      }
+    }
+  }
 
   return Node::null();
 }
diff --git a/src/theory/strings/rewrites.cpp b/src/theory/strings/rewrites.cpp
index 224ccd1a6..cccacd7ec 100644
--- a/src/theory/strings/rewrites.cpp
+++ b/src/theory/strings/rewrites.cpp
@@ -52,7 +52,6 @@ const char* toString(Rewrite r)
     case Rewrite::CTN_SPLIT_ONES: return "CTN_SPLIT_ONES";
     case Rewrite::CTN_STRIP_ENDPT: return "CTN_STRIP_ENDPT";
     case Rewrite::CTN_SUBSTR: return "CTN_SUBSTR";
-    case Rewrite::EQ_LEN_DEQ: return "EQ_LEN_DEQ";
     case Rewrite::EQ_NCTN: return "EQ_NCTN";
     case Rewrite::EQ_NFIX: return "EQ_NFIX";
     case Rewrite::FROM_CODE_EVAL: return "FROM_CODE_EVAL";
@@ -119,17 +118,14 @@ const char* toString(Rewrite r)
     case Rewrite::REPLALL_EMPTY_FIND: return "REPLALL_EMPTY_FIND";
     case Rewrite::RPL_CCTN: return "RPL_CCTN";
     case Rewrite::RPL_CCTN_RPL: return "RPL_CCTN_RPL";
-    case Rewrite::RPL_CNTS_SUBSTS: return "RPL_CNTS_SUBSTS";
     case Rewrite::RPL_CONST_FIND: return "RPL_CONST_FIND";
     case Rewrite::RPL_CONST_NFIND: return "RPL_CONST_NFIND";
-    case Rewrite::RPL_EMP_CNTS_SUBSTS: return "RPL_EMP_CNTS_SUBSTS";
     case Rewrite::RPL_ID: return "RPL_ID";
     case Rewrite::RPL_NCTN: return "RPL_NCTN";
     case Rewrite::RPL_PULL_ENDPT: return "RPL_PULL_ENDPT";
     case Rewrite::RPL_REPLACE: return "RPL_REPLACE";
     case Rewrite::RPL_RPL_EMPTY: return "RPL_RPL_EMPTY";
     case Rewrite::RPL_RPL_LEN_ID: return "RPL_RPL_LEN_ID";
-    case Rewrite::RPL_X_Y_X_SIMP: return "RPL_X_Y_X_SIMP";
     case Rewrite::REPLACE_RE_EVAL: return "REPLACE_RE_EVAL";
     case Rewrite::REPLACE_RE_NONE: return "REPLACE_RE_NONE";
     case Rewrite::REPLACE_RE_ALL_EVAL: return "REPLACE_RE_ALL_EVAL";
diff --git a/src/theory/strings/rewrites.h b/src/theory/strings/rewrites.h
index 5992c9bcf..19e0adeaa 100644
--- a/src/theory/strings/rewrites.h
+++ b/src/theory/strings/rewrites.h
@@ -56,7 +56,6 @@ enum class Rewrite : uint32_t
   CTN_SPLIT_ONES,
   CTN_STRIP_ENDPT,
   CTN_SUBSTR,
-  EQ_LEN_DEQ,
   EQ_NCTN,
   EQ_NFIX,
   FROM_CODE_EVAL,
@@ -121,17 +120,14 @@ enum class Rewrite : uint32_t
   REPLALL_EMPTY_FIND,
   RPL_CCTN,
   RPL_CCTN_RPL,
-  RPL_CNTS_SUBSTS,
   RPL_CONST_FIND,
   RPL_CONST_NFIND,
-  RPL_EMP_CNTS_SUBSTS,
   RPL_ID,
   RPL_NCTN,
   RPL_PULL_ENDPT,
   RPL_REPLACE,
   RPL_RPL_EMPTY,
   RPL_RPL_LEN_ID,
-  RPL_X_Y_X_SIMP,
   REPLACE_RE_EVAL,
   REPLACE_RE_NONE,
   REPLACE_RE_ALL_EVAL,
diff --git a/src/theory/strings/sequences_rewriter.cpp b/src/theory/strings/sequences_rewriter.cpp
index 69762be81..7e55124c5 100644
--- a/src/theory/strings/sequences_rewriter.cpp
+++ b/src/theory/strings/sequences_rewriter.cpp
@@ -186,17 +186,6 @@ Node SequencesRewriter::rewriteStrEqualityExt(Node node)
     }
   }
 
-  // ( len( s ) != len( t ) ) => ( s == t ---> false )
-  // This covers cases like str.++( x, x ) == "a" ---> false
-  Node len0 = nodeManager()->mkNode(Kind::STRING_LENGTH, node[0]);
-  Node len1 = nodeManager()->mkNode(Kind::STRING_LENGTH, node[1]);
-  Node len_eq = len0.eqNode(len1);
-  len_eq = d_rr->rewrite(len_eq);
-  if (len_eq.isConst() && !len_eq.getConst<bool>())
-  {
-    return returnRewrite(node, len_eq, Rewrite::EQ_LEN_DEQ);
-  }
-
   std::vector<Node> c[2];
   for (unsigned i = 0; i < 2; i++)
   {
@@ -3035,31 +3024,6 @@ Node SequencesRewriter::rewriteReplace(Node node)
     {
       return returnRewrite(node, node[0], Rewrite::RPL_RPL_LEN_ID);
     }
-
-    // (str.replace x y x) ---> (str.replace x (str.++ y1 ... yn) x)
-    // if 1 >= (str.len x) and (= y "") ---> (= y1 "") ... (= yn "")
-    if (d_stringsEntail.checkLengthOne(node[0]))
-    {
-      Node empty = Word::mkEmptyWord(stype);
-      Node rn1 = d_rr->rewrite(
-          rewriteEqualityExt(nm->mkNode(Kind::EQUAL, node[1], empty)));
-      if (rn1 != node[1])
-      {
-        std::vector<Node> emptyNodes;
-        bool allEmptyEqs;
-        std::tie(allEmptyEqs, emptyNodes) = utils::collectEmptyEqs(rn1);
-
-        if (allEmptyEqs)
-        {
-          Node nn1 = utils::mkConcat(emptyNodes, stype);
-          if (node[1] != nn1)
-          {
-            Node ret = nm->mkNode(Kind::STRING_REPLACE, node[0], nn1, node[2]);
-            return returnRewrite(node, ret, Rewrite::RPL_X_Y_X_SIMP);
-          }
-        }
-      }
-    }
   }
 
   std::vector<Node> children1;
@@ -3115,58 +3079,6 @@ Node SequencesRewriter::rewriteReplace(Node node)
       return returnRewrite(node, node[0], Rewrite::RPL_NCTN);
     }
   }
-  else if (cmp_conr.getKind() == Kind::EQUAL || cmp_conr.getKind() == Kind::AND)
-  {
-    // Rewriting the str.contains may return equalities of the form (= x "").
-    // In that case, we can substitute the variables appearing in those
-    // equalities with the empty string in the third argument of the
-    // str.replace. For example:
-    //
-    // (str.replace x (str.++ x y) y) --> (str.replace x (str.++ x y) "")
-    //
-    // This can be done because str.replace changes x iff (str.++ x y) is in x
-    // but that means that y must be empty in that case. Thus, we can
-    // substitute y with "" in the third argument. Note that the third argument
-    // does not matter when the str.replace does not apply.
-    //
-    Node empty = Word::mkEmptyWord(stype);
-
-    std::vector<Node> emptyNodes;
-    bool allEmptyEqs;
-    std::tie(allEmptyEqs, emptyNodes) = utils::collectEmptyEqs(cmp_conr);
-
-    if (emptyNodes.size() > 0)
-    {
-      // Perform the substitutions
-      std::vector<TNode> substs(emptyNodes.size(), TNode(empty));
-      Node nn2 = node[2].substitute(
-          emptyNodes.begin(), emptyNodes.end(), substs.begin(), substs.end());
-
-      // If the contains rewrites to a conjunction of empty-string equalities
-      // and we are doing the replacement in an empty string, we can rewrite
-      // the string-to-replace with a concatenation of all the terms that must
-      // be empty:
-      //
-      // (str.replace "" y z) ---> (str.replace "" (str.++ y1 ... yn)  z)
-      // if (str.contains "" y) ---> (and (= y1 "") ... (= yn ""))
-      if (node[0] == empty && allEmptyEqs)
-      {
-        std::vector<Node> emptyNodesList(emptyNodes.begin(), emptyNodes.end());
-        Node nn1 = utils::mkConcat(emptyNodesList, stype);
-        if (nn1 != node[1] || nn2 != node[2])
-        {
-          Node res = nm->mkNode(Kind::STRING_REPLACE, node[0], nn1, nn2);
-          return returnRewrite(node, res, Rewrite::RPL_EMP_CNTS_SUBSTS);
-        }
-      }
-
-      if (nn2 != node[2])
-      {
-        Node res = nm->mkNode(Kind::STRING_REPLACE, node[0], node[1], nn2);
-        return returnRewrite(node, res, Rewrite::RPL_CNTS_SUBSTS);
-      }
-    }
-  }
 
   if (cmp_conr != cmp_con)
   {
-- 
2.47.1

