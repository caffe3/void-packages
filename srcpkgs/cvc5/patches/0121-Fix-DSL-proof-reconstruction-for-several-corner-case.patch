From 9ddaa54d766ac5f5cd79cf01a6de5a5672164205 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Mon, 14 Oct 2024 16:14:20 -0500
Subject: [PATCH 121/312] Fix DSL proof reconstruction for several corner cases
 (#11270)

This mainly addresses higher-order logic.

This makes it so that the RARE reconstruction is agnostic to the
representation of lambdas and higher-order applications.

This results in 12 fewer preprocessing holes and 93 fewer trusted
rewrite rules in our regressions.
---
 src/rewriter/rewrite_db_term_process.cpp | 25 +++++++++++++++++++++++-
 src/rewriter/rewrite_db_term_process.h   |  2 ++
 src/theory/uf/theory_uf_rewriter.cpp     |  9 ++++++---
 3 files changed, 32 insertions(+), 4 deletions(-)

diff --git a/src/rewriter/rewrite_db_term_process.cpp b/src/rewriter/rewrite_db_term_process.cpp
index 0a7424f08..70ac9c97e 100644
--- a/src/rewriter/rewrite_db_term_process.cpp
+++ b/src/rewriter/rewrite_db_term_process.cpp
@@ -21,6 +21,8 @@
 #include "theory/builtin/generic_op.h"
 #include "theory/bv/theory_bv_utils.h"
 #include "theory/strings/theory_strings_utils.h"
+#include "theory/uf/function_const.h"
+#include "theory/uf/theory_uf_rewriter.h"
 #include "util/bitvector.h"
 #include "util/rational.h"
 #include "util/string.h"
@@ -79,6 +81,12 @@ Node RewriteDbNodeConverter::postConvert(Node n)
     recordProofStep(n, ret, ProofRule::EVALUATE);
     return ret;
   }
+  else if (k == Kind::FUNCTION_ARRAY_CONST)
+  {
+    Node ret = theory::uf::FunctionConst::toLambda(n);
+    recordProofStep(n, ret, ProofRule::ENCODE_EQ_INTRO);
+    return ret;
+  }
   else if (k == Kind::FORALL)
   {
     // ignore annotation
@@ -90,6 +98,12 @@ Node RewriteDbNodeConverter::postConvert(Node n)
       return ret;
     }
   }
+  else if (k == Kind::APPLY_UF)
+  {
+    Node ret = theory::uf::TheoryUfRewriter::getHoApplyForApplyUf(n);
+    recordProofStep(n, ret, ProofRule::ENCODE_EQ_INTRO);
+    return ret;
+  }
   // convert indexed operators to symbolic
   if (GenericOp::isNumeralIndexedOperatorKind(k))
   {
@@ -148,7 +162,16 @@ void RewriteDbNodeConverter::recordProofStep(const Node& n,
 }
 
 ProofRewriteDbNodeConverter::ProofRewriteDbNodeConverter(Env& env)
-    : EnvObj(env), d_tpg(env, nullptr), d_proof(env)
+    : EnvObj(env),
+      // must rewrite within operators
+      d_tpg(env,
+            nullptr,
+            TConvPolicy::FIXPOINT,
+            TConvCachePolicy::NEVER,
+            "ProofRewriteDb",
+            nullptr,
+            true),
+      d_proof(env)
 {
 }
 
diff --git a/src/rewriter/rewrite_db_term_process.h b/src/rewriter/rewrite_db_term_process.h
index c86026cf3..9ac1f241d 100644
--- a/src/rewriter/rewrite_db_term_process.h
+++ b/src/rewriter/rewrite_db_term_process.h
@@ -37,6 +37,8 @@ namespace rewriter {
  * (2) Constant bitvectors are lifted to CONST_BITVECTOR_SYMBOLIC.
  * (3) Indexed operators are lifted to APPLY_INDEXED_SYMBOLIC.
  * (4) Quantifier patterns are dropped.
+ * (5) APPLY_UF is converted to HO_APPLY chains.
+ * (6) Function constants are converted to lambdas.
  *
  * This node converter converts from the default representation of cvc5 terms
  * to the representation of terms required by the DSL proof reconstruction
diff --git a/src/theory/uf/theory_uf_rewriter.cpp b/src/theory/uf/theory_uf_rewriter.cpp
index e1f5719aa..e05bde375 100644
--- a/src/theory/uf/theory_uf_rewriter.cpp
+++ b/src/theory/uf/theory_uf_rewriter.cpp
@@ -188,12 +188,15 @@ Node TheoryUfRewriter::rewriteViaRule(ProofRewriteRule id, const Node& n)
   {
     case ProofRewriteRule::BETA_REDUCE:
     {
-      if (n.getKind() != Kind::APPLY_UF
-          || n.getOperator().getKind() != Kind::LAMBDA)
+      if (n.getKind() != Kind::APPLY_UF)
+      {
+        return Node::null();
+      }
+      Node lambda = uf::FunctionConst::toLambda(n.getOperator());
+      if (lambda.isNull())
       {
         return Node::null();
       }
-      Node lambda = n.getOperator();
       std::vector<TNode> vars(lambda[0].begin(), lambda[0].end());
       std::vector<TNode> subs(n.begin(), n.end());
       if (vars.size() != subs.size())
-- 
2.47.1

