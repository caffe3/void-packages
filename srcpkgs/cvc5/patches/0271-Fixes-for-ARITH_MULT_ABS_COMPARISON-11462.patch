From baf4c8fa567bdcfff13f2a461bea6a68833fb49b Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Mon, 6 Jan 2025 16:36:18 -0600
Subject: [PATCH 271/312] Fixes for ARITH_MULT_ABS_COMPARISON (#11462)

Adds three regressions demonstrating different issues.

Also makes the failures in this more robust by adding a trust id.
---
 src/proof/trust_id.cpp                        |   1 +
 src/proof/trust_id.h                          |   2 +
 src/smt/proof_post_processor.cpp              |   9 +-
 .../nl/ext/arith_nl_compare_proof_gen.cpp     | 123 +++++++++++-------
 test/regress/cli/CMakeLists.txt               |   3 +
 .../dd.polypaver-bench-exp-3d-chunk-0067.smt2 |   7 +
 .../nl/dd.sin-cos-346-b-chunk-0210.smt2       |   7 +
 .../nl/dd.sin-cos-346-b-chunk-0210_unsat.smt2 |   7 +
 8 files changed, 113 insertions(+), 46 deletions(-)
 create mode 100644 test/regress/cli/regress0/nl/dd.polypaver-bench-exp-3d-chunk-0067.smt2
 create mode 100644 test/regress/cli/regress0/nl/dd.sin-cos-346-b-chunk-0210.smt2
 create mode 100644 test/regress/cli/regress0/nl/dd.sin-cos-346-b-chunk-0210_unsat.smt2

diff --git a/src/proof/trust_id.cpp b/src/proof/trust_id.cpp
index 5a920c344..5cafe4513 100644
--- a/src/proof/trust_id.cpp
+++ b/src/proof/trust_id.cpp
@@ -90,6 +90,7 @@ const char* toString(TrustId id)
     case TrustId::ARITH_NL_COMPARE_LIT_TRANSFORM:
       return "ARITH_NL_COMPARE_LIT_TRANSFORM";
     case TrustId::ARITH_DIO_LEMMA: return "ARITH_DIO_LEMMA";
+    case TrustId::ARITH_NL_COMPARE_LEMMA: return "ARITH_NL_COMPARE_LEMMA";
     case TrustId::DIAMONDS: return "DIAMONDS";
     case TrustId::EXT_THEORY_REWRITE: return "EXT_THEORY_REWRITE";
     case TrustId::REWRITE_NO_ELABORATE: return "REWRITE_NO_ELABORATE";
diff --git a/src/proof/trust_id.h b/src/proof/trust_id.h
index 6f310900f..dd3afe9e3 100644
--- a/src/proof/trust_id.h
+++ b/src/proof/trust_id.h
@@ -157,6 +157,8 @@ enum class TrustId : uint32_t
   ARITH_NL_COMPARE_LIT_TRANSFORM,
   /** A lemma from the DIO solver */
   ARITH_DIO_LEMMA,
+  /** A nonlinear comparison lemma that failed proof reconstruction */
+  ARITH_NL_COMPARE_LEMMA,
   /** Diamonds preprocessing in TheoryUf::ppStaticLearn */
   DIAMONDS,
   /** An extended theory rewrite */
diff --git a/src/smt/proof_post_processor.cpp b/src/smt/proof_post_processor.cpp
index 9bb816743..0ffe3f20d 100644
--- a/src/smt/proof_post_processor.cpp
+++ b/src/smt/proof_post_processor.cpp
@@ -467,10 +467,15 @@ Node ProofPostprocessCallback::expandMacros(ProofRule id,
       Trace("smt-proof-pp-debug")
           << "transform finish (" << r << ")" << std::endl;
     }
-
     // apply transitivity if necessary
     Node eq = addProofForTrans(tchildren, cdp);
-
+    if (eq.isNull())
+    {
+      Assert(false) << "Failed proof for MACRO_SR_PRED_TRANSFORM";
+      Trace("smt-proof-pp-debug")
+          << "Failed transitivity from " << tchildren << std::endl;
+      return Node::null();
+    }
     cdp->addStep(eq[1], ProofRule::EQ_RESOLVE, {children[0], eq}, {});
     return args[0];
   }
diff --git a/src/theory/arith/nl/ext/arith_nl_compare_proof_gen.cpp b/src/theory/arith/nl/ext/arith_nl_compare_proof_gen.cpp
index fc3979270..6f50d1e17 100644
--- a/src/theory/arith/nl/ext/arith_nl_compare_proof_gen.cpp
+++ b/src/theory/arith/nl/ext/arith_nl_compare_proof_gen.cpp
@@ -17,6 +17,9 @@
 
 #include "expr/attribute.h"
 #include "proof/proof.h"
+#include "proof/proof_checker.h"
+#include "proof/proof_node_manager.h"
+#include "smt/env.h"
 #include "theory/arith/arith_utilities.h"
 #include "theory/arith/nl/ext/monomial_check.h"
 
@@ -77,6 +80,8 @@ std::shared_ptr<ProofNode> ArithNlCompareProofGenerator::getProofFor(Node fact)
   }
   // reorder the explanation based on the order it appears in the conclusion
   Node concc = getCompareLit(conc);
+  Trace("arith-nl-compare")
+      << "...processed prove: " << expc << " => " << concc << std::endl;
   Assert(!concc.isNull());
   Assert(concc.getNumChildren() == 2);
   Assert(concc[0].getKind() == Kind::ABS);
@@ -93,30 +98,26 @@ std::shared_ptr<ProofNode> ArithNlCompareProofGenerator::getProofFor(Node fact)
       mi[p]++;
     }
   }
-  // if GT conclusion, ensure the first explanation is GT, which makes checking
-  // simpler
-  if (ck == Kind::GT)
+  // immediately cancel common factors
+  std::map<Node, size_t> mcancel;
+  std::map<Node, size_t>::iterator itmc;
+  for (const std::pair<const Node, size_t>& m : mexp[0])
   {
-    for (size_t i = 0, nexp = expc.size(); i < nexp; i++)
+    itmc = mexp[1].find(m.first);
+    if (itmc != mexp[1].end())
     {
-      if (expc[i].getKind() == Kind::GT)
-      {
-        if (i > 0)
-        {
-          Node tmp = expc[i];
-          expc[i] = expc[0];
-          expc[0] = tmp;
-        }
-        break;
-      }
+      size_t n = m.second > itmc->second ? itmc->second : m.second;
+      mcancel[m.first] = n;
+      mexp[0][m.first] -= n;
+      mexp[1][m.first] -= n;
     }
   }
   std::vector<size_t> eexp;
   // reorder the conclusion based on the explanation
   NodeManager* nm = nodeManager();
-  std::vector<Node> cprodt[2];
   for (const Node& e : expc)
   {
+    Trace("arith-nl-compare") << "- Explanation: " << e << std::endl;
     std::vector<Node> eprod[2];
     decomposeCompareLit(e, eprod[0], eprod[1]);
     Assert(eprod[0].size() <= 1 && eprod[1].size() <= 1);
@@ -132,13 +133,8 @@ std::shared_ptr<ProofNode> ArithNlCompareProofGenerator::getProofFor(Node fact)
         // (> (abs x) (abs 1)) => (> (abs (* x x)) (abs x)),
         // where we should only consume one copy of x.
         size_t n = na - nb;
-        Node one = mkOne(a.getType());
-        for (size_t j = 0; j < n; j++)
-        {
-          cprodt[i].push_back(one);
-          cprodt[ii].push_back(a);
-        }
         mexp[ii][a] -= n;
+        Trace("arith-nl-compare") << "...use " << n << std::endl;
         eexp.emplace_back(n);
         break;
       }
@@ -158,37 +154,56 @@ std::shared_ptr<ProofNode> ArithNlCompareProofGenerator::getProofFor(Node fact)
         for (size_t j = 0; j < 2; j++)
         {
           const Node& c = eprod[j][0];
-          for (size_t k = 0; k < n; k++)
-          {
-            cprodt[j].push_back(c);
-          }
           mexp[j][c] -= n;
         }
         eexp.emplace_back(n);
+        Trace("arith-nl-compare") << "...use " << n << std::endl;
       }
     }
   }
+  // add back cancelled
+  for (const std::pair<const Node, size_t>& m : mcancel)
+  {
+    mexp[0][m.first] += m.second;
+  }
   // now get the leftover factors, one by one
   for (const std::pair<const Node, size_t>& m : mexp[0])
   {
     if (m.second > 0)
     {
-      for (size_t k = 0; k < m.second; k++)
-      {
-        cprodt[0].push_back(m.first);
-        cprodt[1].push_back(m.first);
-      }
+      Trace("arith-nl-compare") << "- Leftover: " << m.first << std::endl;
       Node v = nm->mkNode(Kind::ABS, m.first);
       Node veq = v.eqNode(v);
       cdp.addStep(veq, ProofRule::REFL, {}, {v});
       expc.emplace_back(veq);
       eexp.push_back(m.second);
+      Trace("arith-nl-compare") << "...use leftover " << m.second << std::endl;
     }
   }
   // if strict version, we go back and guard zeroes
   if (ck == Kind::GT)
   {
+    // if GT conclusion, ensure the first explanation is GT, which makes
+    // checking simpler
+    for (size_t i = 0, nexp = expc.size(); i < nexp; i++)
+    {
+      if (expc[i].getKind() == Kind::GT && eexp[i] > 0)
+      {
+        if (i > 0)
+        {
+          Node tmp = expc[i];
+          expc[i] = expc[0];
+          expc[0] = tmp;
+          size_t tmpe = eexp[i];
+          eexp[i] = eexp[0];
+          eexp[0] = tmpe;
+        }
+        break;
+      }
+    }
+    AlwaysAssert(expc[0].getKind() == Kind::GT);
     std::map<Node, Node>::iterator itd;
+    bool expSuccess = true;
     for (size_t i = 0, nexp = expc.size(); i < nexp; i++)
     {
       Node e = expc[i];
@@ -197,22 +212,43 @@ std::shared_ptr<ProofNode> ArithNlCompareProofGenerator::getProofFor(Node fact)
         // needs to have a disequal to zero explanation
         std::vector<Node> eprod[2];
         decomposeCompareLit(e, eprod[0], eprod[1]);
-        if (eprod[0].size() != 1)
+        Node deqAssump;
+        if (eprod[0].size() == 0)
         {
-          Assert(false) << "ArithNlCompareProofGenerator failed explain";
-          return nullptr;
+          Assert(eprod[1].size() == 1);
+          Node one = nm->mkConstRealOrInt(eprod[1][0].getType(), Rational(1));
+          Node zero = nm->mkConstRealOrInt(eprod[1][0].getType(), Rational(0));
+          // case where we require showing 1 != 0
+          Node ceq = one.eqNode(zero);
+          Node ceqf = ceq.eqNode(nm->mkConst(false));
+          cdp.addStep(ceqf, ProofRule::EVALUATE, {}, {ceq});
+          deqAssump = ceq.notNode();
+          cdp.addStep(deqAssump, ProofRule::FALSE_ELIM, {ceqf}, {});
+          Trace("arith-nl-compare")
+              << "Prove by evaluation: " << deqAssump << std::endl;
         }
-        itd = deq.find(eprod[0][0]);
-        if (itd == deq.end())
+        else
         {
-          Assert(false) << "ArithNlCompareProofGenerator failed explain deq";
-          return nullptr;
+          itd = deq.find(eprod[0][0]);
+          if (itd == deq.end())
+          {
+            Assert(false) << "ArithNlCompareProofGenerator failed explain deq";
+            expSuccess = false;
+            break;
+          }
+          deqAssump = itd->second;
         }
-        Node guardEq = nm->mkNode(Kind::AND, e, itd->second);
-        cdp.addStep(guardEq, ProofRule::AND_INTRO, {e, itd->second}, {});
+        Node guardEq = nm->mkNode(Kind::AND, e, deqAssump);
+        cdp.addStep(guardEq, ProofRule::AND_INTRO, {e, deqAssump}, {});
         expc[i] = guardEq;
       }
     }
+    // if we failed, add a trust step
+    if (!expSuccess)
+    {
+      cdp.addTrustedStep(fact, TrustId::ARITH_NL_COMPARE_LEMMA, {}, {});
+      return cdp.getProofFor(fact);
+    }
   }
   Assert(eexp.size() == expc.size());
   // use repetition of explanation to match the exponents
@@ -225,13 +261,12 @@ std::shared_ptr<ProofNode> ArithNlCompareProofGenerator::getProofFor(Node fact)
       expcFinal.emplace_back(expc[i]);
     }
   }
-  Node opa = mkProduct(nm, cprodt[0]);
-  Node opb = mkProduct(nm, cprodt[1]);
-  Node newConc = mkLit(nm, ck, opa, opb);
-  Trace("arith-nl-compare")
-      << "...processed prove: " << expc << " => " << concc << std::endl;
+  ProofChecker* pc = d_env.getProofNodeManager()->getChecker();
+  Node newConc =
+      pc->checkDebug(ProofRule::ARITH_MULT_ABS_COMPARISON, expcFinal, {});
   Trace("arith-nl-compare")
       << "...grouped conclusion is " << newConc << std::endl;
+  Assert(!newConc.isNull());
   cdp.addStep(newConc, ProofRule::ARITH_MULT_ABS_COMPARISON, expcFinal, {});
   // the grouped literal should be equivalent by rewriting
   if (newConc != concc)
diff --git a/test/regress/cli/CMakeLists.txt b/test/regress/cli/CMakeLists.txt
index 3f42ce67c..751d9bf92 100644
--- a/test/regress/cli/CMakeLists.txt
+++ b/test/regress/cli/CMakeLists.txt
@@ -1036,6 +1036,9 @@ set(regress_0_tests
   regress0/nl/combined-uf.smt2
   regress0/nl/dd.fuzz01.smtv1-to-real-idem.smt2
   regress0/nl/dd.iand-wrong-0513-pp.smt2
+  regress0/nl/dd.polypaver-bench-exp-3d-chunk-0067.smt2
+  regress0/nl/dd.sin-cos-346-b-chunk-0210.smt2
+  regress0/nl/dd.sin-cos-346-b-chunk-0210_unsat.smt2
   regress0/nl/iand-no-init.smt2
   regress0/nl/issue10145-ir-pow.smt2
   regress0/nl/issue3003.smt2
diff --git a/test/regress/cli/regress0/nl/dd.polypaver-bench-exp-3d-chunk-0067.smt2 b/test/regress/cli/regress0/nl/dd.polypaver-bench-exp-3d-chunk-0067.smt2
new file mode 100644
index 000000000..e46b85d63
--- /dev/null
+++ b/test/regress/cli/regress0/nl/dd.polypaver-bench-exp-3d-chunk-0067.smt2
@@ -0,0 +1,7 @@
+; COMMAND-LINE: --no-nl-cov
+; EXPECT: unsat
+(set-logic ALL)
+(declare-fun s () Real)
+(declare-fun k () Real)
+(assert (and (< s 1) (<= k 1) (< 0 s) (= 0.0 (+ 1 (* s s k (- 1))))))
+(check-sat)
diff --git a/test/regress/cli/regress0/nl/dd.sin-cos-346-b-chunk-0210.smt2 b/test/regress/cli/regress0/nl/dd.sin-cos-346-b-chunk-0210.smt2
new file mode 100644
index 000000000..b06d23df6
--- /dev/null
+++ b/test/regress/cli/regress0/nl/dd.sin-cos-346-b-chunk-0210.smt2
@@ -0,0 +1,7 @@
+; COMMAND-LINE: --no-nl-cov
+; EXPECT: sat
+(set-logic ALL)
+(declare-const x Real)
+(declare-fun s () Real)
+(assert (and (> s 0) (= 0.0 (* s s (+ (/ 1 9) (* x (/ 1 0)))))))
+(check-sat)
diff --git a/test/regress/cli/regress0/nl/dd.sin-cos-346-b-chunk-0210_unsat.smt2 b/test/regress/cli/regress0/nl/dd.sin-cos-346-b-chunk-0210_unsat.smt2
new file mode 100644
index 000000000..df0cb583f
--- /dev/null
+++ b/test/regress/cli/regress0/nl/dd.sin-cos-346-b-chunk-0210_unsat.smt2
@@ -0,0 +1,7 @@
+; COMMAND-LINE: --no-nl-cov
+; EXPECT: unsat
+(set-logic QF_NRA)
+(declare-fun s () Real)
+(declare-fun k () Real)
+(assert (and (> s 0) (= 3 (* k k)) (= 0.0 (* s s (+ 1.0 (* k k) (* s s (+ (* k (/ 1 13)) (* s k k (/ 1 47)))))))))
+(check-sat)
-- 
2.47.1

