From 6ff0f1791045e96bf06908a3cd4788084a453a35 Mon Sep 17 00:00:00 2001
From: Haniel Barbosa <hanielbbarbosa@gmail.com>
Date: Sun, 11 Aug 2024 12:08:00 -0300
Subject: [PATCH 012/312] [alethe] Updates to resolution post-processing
 (#11119)

This commit also disables the expansion of "MACRO_RESOLUTION" when
printing Alethe proofs, since the `resolution` rule in Alethe coincides
with that rule.
---
 src/proof/alethe/alethe_post_processor.cpp | 188 ++++++++++++---------
 src/smt/proof_manager.cpp                  |   8 +-
 2 files changed, 111 insertions(+), 85 deletions(-)

diff --git a/src/proof/alethe/alethe_post_processor.cpp b/src/proof/alethe/alethe_post_processor.cpp
index 81245fb9e..9e51029f6 100644
--- a/src/proof/alethe/alethe_post_processor.cpp
+++ b/src/proof/alethe/alethe_post_processor.cpp
@@ -522,49 +522,48 @@ bool AletheProofPostprocessCallback::update(Node res,
                            *cdp);
     }
     // ======== Resolution and N-ary Resolution
-    // See proof_rule.h for documentation on the RESOLUTION and CHAIN_RESOLUTION
-    // rule. This comment uses variable names as introduced there.
-    //
     // Because the RESOLUTION rule is merely a special case of CHAIN_RESOLUTION,
     // the same translation can be used for both.
     //
     // The main complication for the translation of the rule is that in the case
-    // that the conclusion C is (or G1 ... Gn), the result is ambigous. E.g.,
+    // that the conclusion is (or G1 ... Gn), the result is ambigous. E.g.,
     //
     // (cl F1 (or F2 F3))    (cl (not F1))
-    // -------------------------------------- RESOLUTION
+    // -------------------------------------- resolution
     // (cl (or F2 F3))
     //
     // (cl F1 F2 F3)         (cl (not F1))
-    // -------------------------------------- RESOLUTION
+    // -------------------------------------- resolution
     // (cl F2 F3)
     //
-    // both (cl (or F2 F3)) and (cl F2 F3) correspond to the same proof node (or
-    // F2 F3). Thus, it has to be checked if C is a singleton clause or not.
+    // both (cl (or F2 F3)) and (cl F2 F3) could be represented by the same node
+    // (or F2 F3). Thus, it has to be checked if the conclusion C is a singleton
+    // clause or not.
     //
     // If C = (or F1 ... Fn) is a non-singleton clause, then:
     //
     //   VP1 ... VPn
-    // ------------------ RESOLUTION
+    // ------------------ resolution
     //  (cl F1 ... Fn)*
     //
     // Else if, C = false:
     //
     //   VP1 ... VPn
-    // ------------------ RESOLUTION
+    // ------------------ resolution
     //       (cl)*
     //
     // Otherwise:
     //
     //   VP1 ... VPn
-    // ------------------ RESOLUTION
+    // ------------------ resolution
     //      (cl C)*
     //
     //  * the corresponding proof node is C
     case ProofRule::RESOLUTION:
     case ProofRule::CHAIN_RESOLUTION:
+    case ProofRule::MACRO_RESOLUTION:
+    case ProofRule::MACRO_RESOLUTION_TRUST:
     {
-      std::vector<Node> newArgs;
       std::vector<Node> cargs;
       if (id == ProofRule::CHAIN_RESOLUTION)
       {
@@ -574,10 +573,36 @@ bool AletheProofPostprocessCallback::update(Node res,
           cargs.push_back(args[1][i]);
         }
       }
+      else if (id == ProofRule::MACRO_RESOLUTION
+               || id == ProofRule::MACRO_RESOLUTION_TRUST)
+      {
+        cargs.insert(cargs.end(), args.begin() + 1, args.end());
+      }
       else
       {
         cargs = args;
       }
+      // The arguments for the actual step will include the id of the rule,
+      // original conclusion and the one to print and so on.
+      std::vector<Node> newArgs{nm->mkConstInt(Rational(static_cast<uint32_t>(
+                                    AletheRule::RESOLUTION_OR))),
+                                res};
+      Node conclusion;
+      if (!isSingletonClause(res, children, cargs))
+      {
+        std::vector<Node> concChildren{d_cl};
+        concChildren.insert(concChildren.end(), res.begin(), res.end());
+        conclusion = nm->mkNode(Kind::SEXPR, concChildren);
+      }
+      else if (res == d_false)
+      {
+        conclusion = nm->mkNode(Kind::SEXPR, d_cl);
+      }
+      else
+      {
+        conclusion = nm->mkNode(Kind::SEXPR, d_cl, res);
+      }
+      newArgs.push_back(conclusion);
       // checker expects opposite order. We always keep the pivots because we
       // need them to compute in updatePost whether we will add OR steps. If
       // d_resPivots is off we will remove the pivots after that.
@@ -586,18 +611,10 @@ bool AletheProofPostprocessCallback::update(Node res,
         newArgs.push_back(cargs[i + 1]);
         newArgs.push_back(cargs[i]);
       }
-      if (!isSingletonClause(res, children, cargs))
-      {
-        return addAletheStepFromOr(
-            AletheRule::RESOLUTION_OR, res, children, newArgs, *cdp);
-      }
-      return addAletheStep(AletheRule::RESOLUTION_OR,
-                           res,
-                           res == d_false ? nm->mkNode(Kind::SEXPR, d_cl)
-                                          : nm->mkNode(Kind::SEXPR, d_cl, res),
-                           children,
-                           newArgs,
-                           *cdp);
+      Trace("alethe-proof")
+          << "... add alethe step " << res << " / " << d_anc.convert(conclusion)
+          << " " << id << " " << children << " / " << newArgs << std::endl;
+      return cdp->addStep(res, ProofRule::ALETHE_RULE, children, newArgs);
     }
     // ======== Factoring
     // See proof_rule.h for documentation on the FACTORING rule. This comment
@@ -2090,28 +2107,26 @@ bool AletheProofPostprocessCallback::updatePost(
   AletheRule rule = getAletheRule(args[0]);
   Trace("alethe-proof") << "...Alethe post-update " << rule << " / " << res
                         << " / args: " << args << std::endl;
+  bool success = true;
   switch (rule)
   {
-    // In the case of a resolution rule the rule might originally have been a
-    // cvc5 RESOLUTION or CHAIN_RESOLUTION rule, it is possible
-    // that one of the children was printed as (cl (or F1 ... Fn)) but used as
-    // (cl F1 ... Fn). However, from the pivot of the
-    // resolution step for the child we can determine an additional OR step is
-    // necessary to convert (cl (or ...)) to (cl ...).
+    // In the case of a resolution rule, the rule might originally have been a
+    // cvc5 RESOLUTION or CHAIN_RESOLUTION rule, and it is possible that one of
+    // the children was printed as (cl (or F1 ... Fn)) but it was actually used
+    // as (cl F1 ... Fn). However, from the pivot of the resolution step for the
+    // child we can determine if an additional OR step is necessary to convert
+    // the clase (cl (or ...)) to (cl ...). This is done below.
     case AletheRule::RESOLUTION_OR:
     {
-      // if we do not have pivots, we can't compute easily, so we do not try.
-      // This should only be the case if this proof node was previously updated
-      // and we are not printing pivots.
-      if (args.size() < 4)
-      {
-        return false;
-      }
+      // We need pivots to more easily do the computations here, so we require
+      // them.
+      Assert(args.size() >= 4);
       std::vector<Node> newChildren = children;
       bool hasUpdated = false;
 
       // Note that we will have inverted the order of polarity/pivot.
       size_t polIdx, pivIdx;
+      // their starting positions in the arguments
       polIdx = 4;
       pivIdx = 3;
       // The first child is used as a non-singleton clause if it is not equal
@@ -2121,19 +2136,20 @@ bool AletheProofPostprocessCallback::updatePost(
           && (args[polIdx] != d_true || args[pivIdx] != children[0]))
       {
         std::shared_ptr<ProofNode> childPf = cdp->getProofFor(children[0]);
-        Node childConclusion = childPf->getArguments()[2];
-        AletheRule childRule = getAletheRule(childPf->getArguments()[0]);
+        bool childPfIsAssume = childPf->getRule() == ProofRule::ASSUME;
+        Node childConclusion =
+            childPfIsAssume ? childPf->getResult() : childPf->getArguments()[2];
         // if child conclusion is of the form (sexpr cl (or ...)), then we need
         // to add an OR step, since this child must not be a singleton
-        if ((childConclusion.getNumChildren() == 2 && childConclusion[0] == d_cl
-             && childConclusion[1].getKind() == Kind::OR)
-            || (childRule == AletheRule::ASSUME
-                && childConclusion.getKind() == Kind::OR))
+        if ((childPfIsAssume && childConclusion.getKind() == Kind::OR)
+            || (childConclusion.getNumChildren() == 2
+                && childConclusion[0] == d_cl
+                && childConclusion[1].getKind() == Kind::OR))
         {
           hasUpdated = true;
           // Add or step
           std::vector<Node> subterms{d_cl};
-          if (childRule == AletheRule::ASSUME)
+          if (childPfIsAssume)
           {
             subterms.insert(
                 subterms.end(), childConclusion.begin(), childConclusion.end());
@@ -2145,12 +2161,12 @@ bool AletheProofPostprocessCallback::updatePost(
                             childConclusion[1].end());
           }
           Node newConclusion = nm->mkNode(Kind::SEXPR, subterms);
-          addAletheStep(AletheRule::OR,
-                        newConclusion,
-                        newConclusion,
-                        {children[0]},
-                        {},
-                        *cdp);
+          success &= addAletheStep(AletheRule::OR,
+                                   newConclusion,
+                                   newConclusion,
+                                   {children[0]},
+                                   {},
+                                   *cdp);
           newChildren[0] = newConclusion;
           Trace("alethe-proof") << "Added OR step for " << childConclusion
                                 << " / " << newConclusion << std::endl;
@@ -2179,29 +2195,27 @@ bool AletheProofPostprocessCallback::updatePost(
         polIdx = 2 * (i - 1) + 3 + 1;
         pivIdx = 2 * (i - 1) + 3;
         if (children[i].getKind() == Kind::OR
-            && (args[polIdx] != d_false || args[pivIdx] != children[i]))
+            && (args[polIdx] != d_false
+                || d_anc.convert(args[pivIdx]) != d_anc.convert(children[i])))
         {
-          // the arguments will have been converted to witness form already, so
-          // we also check whether after conversion the child is still not the
-          // same (in the case where we'd need to have them different)
           if (args[polIdx] == d_false
-              && args[pivIdx] == d_anc.convert(children[i]))
+              && d_anc.convert(args[pivIdx]) == d_anc.convert(children[i]))
           {
             continue;
           }
           std::shared_ptr<ProofNode> childPf = cdp->getProofFor(children[i]);
-          Node childConclusion = childPf->getArguments()[2];
-          AletheRule childRule = getAletheRule(childPf->getArguments()[0]);
+          bool childPfIsAssume = childPf->getRule() == ProofRule::ASSUME;
+          Node childConclusion = childPfIsAssume ? childPf->getResult()
+                                                 : childPf->getArguments()[2];
           // Add or step
-          if ((childConclusion.getNumChildren() == 2
-               && childConclusion[0] == d_cl
-               && childConclusion[1].getKind() == Kind::OR)
-              || (childRule == AletheRule::ASSUME
-                  && childConclusion.getKind() == Kind::OR))
+          if ((childPfIsAssume && childConclusion.getKind() == Kind::OR)
+              || (childConclusion.getNumChildren() == 2
+                  && childConclusion[0] == d_cl
+                  && childConclusion[1].getKind() == Kind::OR))
           {
             hasUpdated = true;
             std::vector<Node> lits{d_cl};
-            if (childRule == AletheRule::ASSUME)
+            if (childPfIsAssume)
             {
               lits.insert(
                   lits.end(), childConclusion.begin(), childConclusion.end());
@@ -2213,12 +2227,12 @@ bool AletheProofPostprocessCallback::updatePost(
                           childConclusion[1].end());
             }
             Node conclusion = nm->mkNode(Kind::SEXPR, lits);
-            addAletheStep(AletheRule::OR,
-                          conclusion,
-                          conclusion,
-                          {children[i]},
-                          {},
-                          *cdp);
+            success &= addAletheStep(AletheRule::OR,
+                                     conclusion,
+                                     conclusion,
+                                     {children[i]},
+                                     {},
+                                     *cdp);
             newChildren[i] = conclusion;
             Trace("alethe-proof") << "Added OR step for " << childConclusion
                                   << " / " << conclusion << std::endl;
@@ -2228,7 +2242,8 @@ bool AletheProofPostprocessCallback::updatePost(
         // premise is a singleton but the rule concluding it yields a clause.
         else if (children[i].getKind() == Kind::OR)
         {
-          Assert(args[polIdx] == d_false && args[pivIdx] == children[i]);
+          Assert(args[polIdx] == d_false
+                 && d_anc.convert(args[pivIdx]) == d_anc.convert(children[i]));
           if (maybeReplacePremiseProof(children[i], cdp))
           {
             hasUpdated = true;
@@ -2236,21 +2251,28 @@ bool AletheProofPostprocessCallback::updatePost(
           }
         }
       }
-      if (hasUpdated || !d_resPivots)
+      if (TraceIsOn("alethe-proof"))
       {
-        Trace("alethe-proof")
-            << "... update alethe step in finalizer " << res << " "
-            << newChildren << " / " << args << std::endl;
-        cdp->addStep(res,
-                     ProofRule::ALETHE_RULE,
-                     newChildren,
-                     d_resPivots
-                         ? args
-                         : std::vector<Node>{args.begin(), args.begin() + 3});
-        return true;
+        if (hasUpdated)
+        {
+          Trace("alethe-proof")
+              << "... update alethe step in finalizer " << res << " "
+              << newChildren << " / " << args << std::endl;
+        }
+        else
+        {
+          Trace("alethe-proof") << "... no update\n";
+        }
       }
-      Trace("alethe-proof") << "... no update\n";
-      return false;
+      success &= addAletheStep(
+          AletheRule::RESOLUTION,
+          res,
+          args[2],
+          newChildren,
+          d_resPivots ? std::vector<Node>{args.begin() + 3, args.end()}
+                      : std::vector<Node>{},
+          *cdp);
+      return success;
     }
     // A application of the FACTORING rule:
     //
diff --git a/src/smt/proof_manager.cpp b/src/smt/proof_manager.cpp
index 3871f77dc..b655d714c 100644
--- a/src/smt/proof_manager.cpp
+++ b/src/smt/proof_manager.cpp
@@ -113,8 +113,12 @@ PfManager::PfManager(Env& env)
     d_pfpp->setEliminateRule(ProofRule::MACRO_SR_PRED_INTRO);
     d_pfpp->setEliminateRule(ProofRule::MACRO_SR_PRED_ELIM);
     d_pfpp->setEliminateRule(ProofRule::MACRO_SR_PRED_TRANSFORM);
-    d_pfpp->setEliminateRule(ProofRule::MACRO_RESOLUTION_TRUST);
-    d_pfpp->setEliminateRule(ProofRule::MACRO_RESOLUTION);
+    // Alethe does not require macro resolution to be expanded
+    if (options().proof.proofFormatMode != options::ProofFormatMode::ALETHE)
+    {
+      d_pfpp->setEliminateRule(ProofRule::MACRO_RESOLUTION_TRUST);
+      d_pfpp->setEliminateRule(ProofRule::MACRO_RESOLUTION);
+    }
     d_pfpp->setEliminateRule(ProofRule::MACRO_ARITH_SCALE_SUM_UB);
     if (options().proof.proofGranularityMode
         != options::ProofGranularityMode::REWRITE)
-- 
2.47.1

