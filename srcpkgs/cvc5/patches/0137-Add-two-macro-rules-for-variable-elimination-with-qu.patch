From 4e2ddcd89fad37919f87c732e1e05128f75799ea Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Tue, 22 Oct 2024 12:55:13 -0500
Subject: [PATCH 137/312] Add two macro rules for variable elimination with
 quantifiers (#11294)

Followup PRs will reconstruct these macros to proof rewrite rules.

Makes a minor change to the quantifiers rewriter to apply variable
elimination one variable at a time to ease proof reconstruction.

These two macros occur 82 and 39 times respectively in our regressions.

---------

Co-authored-by: Abdalrhman Mohamed <abdoo8080@outlook.com>
---
 include/cvc5/cvc5_proof_rule.h                | 26 ++++++
 src/api/cpp/cvc5_proof_rule_template.cpp      |  4 +
 .../quantifiers/quantifiers_rewriter.cpp      | 93 +++++++++++++------
 3 files changed, 93 insertions(+), 30 deletions(-)

diff --git a/include/cvc5/cvc5_proof_rule.h b/include/cvc5/cvc5_proof_rule.h
index 00aecd89d..bd5ce21da 100644
--- a/include/cvc5/cvc5_proof_rule.h
+++ b/include/cvc5/cvc5_proof_rule.h
@@ -2505,6 +2505,32 @@ enum ENUM(ProofRewriteRule)
    * \endverbatim
    */
   EVALUE(MACRO_QUANT_PARTITION_CONNECTED_FV),
+  /**
+   * \verbatim embed:rst:leading-asterisk
+   * **Quantifiers -- Macro variable elimination equality**
+   *
+   * .. math::
+   *   \forall x Y.\> F = \forall Y.\> F \{ x \mapsto t \}
+   *
+   * where :math:`\neg F` entails :math:`x = t`.
+   *
+   * \endverbatim
+   */
+  EVALUE(MACRO_QUANT_VAR_ELIM_EQ),
+  /**
+   * \verbatim embed:rst:leading-asterisk
+   * **Quantifiers -- Macro variable elimination inequality**
+   *
+   * .. math::
+   *   \forall x Y.\> F = \forall Y.\> G
+   *
+   * where :math:`G` is the result of replacing all literals containing
+   * :math:`x` with a constant. This is applied only when all such literals
+   * are lower (resp. upper) bounds for :math:`x`.
+   *
+   * \endverbatim
+   */
+  EVALUE(MACRO_QUANT_VAR_ELIM_INEQ),
   /**
    * \verbatim embed:rst:leading-asterisk
    * **Datatypes -- Instantiation**
diff --git a/src/api/cpp/cvc5_proof_rule_template.cpp b/src/api/cpp/cvc5_proof_rule_template.cpp
index 053f0b58d..ee38c04e2 100644
--- a/src/api/cpp/cvc5_proof_rule_template.cpp
+++ b/src/api/cpp/cvc5_proof_rule_template.cpp
@@ -240,6 +240,10 @@ const char* toString(cvc5::ProofRewriteRule rule)
     case ProofRewriteRule::QUANT_MINISCOPE_FV: return "quant-miniscope-fv";
     case ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV:
       return "macro-quant-partition-connected-fv";
+    case ProofRewriteRule::MACRO_QUANT_VAR_ELIM_EQ:
+      return "macro-quant-var-elim-eq";
+    case ProofRewriteRule::MACRO_QUANT_VAR_ELIM_INEQ:
+      return "macro-quant-var-elim-ineq";
     case ProofRewriteRule::DT_INST: return "dt-inst";
     case ProofRewriteRule::DT_COLLAPSE_SELECTOR: return "dt-collapse-selector";
     case ProofRewriteRule::DT_COLLAPSE_TESTER: return "dt-collapse-tester";
diff --git a/src/theory/quantifiers/quantifiers_rewriter.cpp b/src/theory/quantifiers/quantifiers_rewriter.cpp
index c0a9d0c95..efa18e540 100644
--- a/src/theory/quantifiers/quantifiers_rewriter.cpp
+++ b/src/theory/quantifiers/quantifiers_rewriter.cpp
@@ -108,6 +108,10 @@ QuantifiersRewriter::QuantifiersRewriter(NodeManager* nm,
                            TheoryRewriteCtx::PRE_DSL);
   registerProofRewriteRule(ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV,
                            TheoryRewriteCtx::PRE_DSL);
+  registerProofRewriteRule(ProofRewriteRule::MACRO_QUANT_VAR_ELIM_EQ,
+                           TheoryRewriteCtx::PRE_DSL);
+  registerProofRewriteRule(ProofRewriteRule::MACRO_QUANT_VAR_ELIM_INEQ,
+                           TheoryRewriteCtx::PRE_DSL);
 }
 
 Node QuantifiersRewriter::rewriteViaRule(ProofRewriteRule id, const Node& n)
@@ -256,6 +260,42 @@ Node QuantifiersRewriter::rewriteViaRule(ProofRewriteRule id, const Node& n)
       return ret;
     }
     break;
+    case ProofRewriteRule::MACRO_QUANT_VAR_ELIM_EQ:
+    case ProofRewriteRule::MACRO_QUANT_VAR_ELIM_INEQ:
+    {
+      if (n.getKind() != Kind::FORALL)
+      {
+        return Node::null();
+      }
+      std::vector<Node> args(n[0].begin(), n[0].end());
+      std::vector<Node> vars;
+      std::vector<Node> subs;
+      if (id == ProofRewriteRule::MACRO_QUANT_VAR_ELIM_EQ)
+      {
+        getVarElim(n[1], args, vars, subs);
+      }
+      else
+      {
+        // assume empty attribute
+        QAttributes qa;
+        getVarElimIneq(n[1], args, vars, subs, qa);
+      }
+      // if we eliminated a variable, update body and reprocess
+      if (!vars.empty())
+      {
+        Assert(vars.size() == subs.size());
+        std::vector<Node> qc(n.begin(), n.end());
+        qc[1] =
+            n[1].substitute(vars.begin(), vars.end(), subs.begin(), subs.end());
+        if (args.empty())
+        {
+          return qc[1];
+        }
+        qc[0] = d_nm->mkNode(Kind::BOUND_VAR_LIST, args);
+        return d_nm->mkNode(Kind::FORALL, qc);
+      }
+    }
+    break;
     default: break;
   }
   return Node::null();
@@ -1508,39 +1548,32 @@ Node QuantifiersRewriter::computeVarElimination(Node body,
   }
   Trace("var-elim-quant-debug")
       << "computeVarElimination " << body << std::endl;
-  Node prev;
-  while (prev != body && !args.empty())
+  std::vector<Node> vars;
+  std::vector<Node> subs;
+  // standard variable elimination
+  if (d_opts.quantifiers.varElimQuant)
   {
-    prev = body;
-
-    std::vector<Node> vars;
-    std::vector<Node> subs;
-    // standard variable elimination
-    if (d_opts.quantifiers.varElimQuant)
-    {
-      getVarElim(body, args, vars, subs);
-    }
-    // variable elimination based on one-direction inequalities
-    if (vars.empty() && d_opts.quantifiers.varIneqElimQuant)
-    {
-      getVarElimIneq(body, args, vars, subs, qa);
-    }
-    // if we eliminated a variable, update body and reprocess
-    if (!vars.empty())
+    getVarElim(body, args, vars, subs);
+  }
+  // variable elimination based on one-direction inequalities
+  if (vars.empty() && d_opts.quantifiers.varIneqElimQuant)
+  {
+    getVarElimIneq(body, args, vars, subs, qa);
+  }
+  // if we eliminated a variable, update body and reprocess
+  if (!vars.empty())
+  {
+    Trace("var-elim-quant-debug")
+        << "VE " << vars.size() << "/" << args.size() << std::endl;
+    Assert(vars.size() == subs.size());
+    // remake with eliminated nodes
+    body = body.substitute(vars.begin(), vars.end(), subs.begin(), subs.end());
+    if (!qa.d_ipl.isNull())
     {
-      Trace("var-elim-quant-debug")
-          << "VE " << vars.size() << "/" << args.size() << std::endl;
-      Assert(vars.size() == subs.size());
-      // remake with eliminated nodes
-      body =
-          body.substitute(vars.begin(), vars.end(), subs.begin(), subs.end());
-      if (!qa.d_ipl.isNull())
-      {
-        qa.d_ipl = qa.d_ipl.substitute(
-            vars.begin(), vars.end(), subs.begin(), subs.end());
-      }
-      Trace("var-elim-quant") << "Return " << body << std::endl;
+      qa.d_ipl = qa.d_ipl.substitute(
+          vars.begin(), vars.end(), subs.begin(), subs.end());
     }
+    Trace("var-elim-quant") << "Return " << body << std::endl;
   }
   return body;
 }
-- 
2.47.1

