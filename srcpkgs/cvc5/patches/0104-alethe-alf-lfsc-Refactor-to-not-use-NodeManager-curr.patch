From 2baeefea4425791e33e35f29ee4ec6f6477a2802 Mon Sep 17 00:00:00 2001
From: Daniel Larraz <daniel-larraz@users.noreply.github.com>
Date: Fri, 4 Oct 2024 08:13:27 -0500
Subject: [PATCH 104/312] alethe/alf/lfsc: Refactor to not use
 NodeManager::currentNM() (#11253)

---
 src/proof/alethe/alethe_let_binding.cpp       |   5 +-
 src/proof/alethe/alethe_let_binding.h         |   2 +-
 src/proof/alethe/alethe_node_converter.cpp    |  48 ++---
 src/proof/alethe/alethe_printer.cpp           |   2 +-
 src/proof/alf/alf_node_converter.cpp          |  36 ++--
 src/proof/alf/alf_printer.cpp                 |   2 +-
 .../lfsc/lfsc_list_sc_node_converter.cpp      |  10 +-
 src/proof/lfsc/lfsc_node_converter.cpp        | 168 +++++++++---------
 src/proof/lfsc/lfsc_post_processor.cpp        |  13 +-
 src/proof/lfsc/lfsc_post_processor.h          |   2 +-
 src/proof/lfsc/lfsc_util.cpp                  |   5 +-
 src/proof/lfsc/lfsc_util.h                    |   2 +-
 12 files changed, 140 insertions(+), 155 deletions(-)

diff --git a/src/proof/alethe/alethe_let_binding.cpp b/src/proof/alethe/alethe_let_binding.cpp
index f1d775b82..cb2ac123b 100644
--- a/src/proof/alethe/alethe_let_binding.cpp
+++ b/src/proof/alethe/alethe_let_binding.cpp
@@ -25,13 +25,14 @@ AletheLetBinding::AletheLetBinding(uint32_t thresh) : LetBinding("let", thresh)
 {
 }
 
-Node AletheLetBinding::convert(Node n, const std::string& prefix)
+Node AletheLetBinding::convert(NodeManager* nm,
+                               Node n,
+                               const std::string& prefix)
 {
   if (d_letMap.empty())
   {
     return n;
   }
-  NodeManager* nm = NodeManager::currentNM();
   // terms with a child that is being declared
   std::unordered_set<TNode> hasDeclaredChild;
   // For a term being declared, its position relative to the list of children
diff --git a/src/proof/alethe/alethe_let_binding.h b/src/proof/alethe/alethe_let_binding.h
index 1f1461c55..ea0d35719 100644
--- a/src/proof/alethe/alethe_let_binding.h
+++ b/src/proof/alethe/alethe_let_binding.h
@@ -46,7 +46,7 @@ class AletheLetBinding : public LetBinding
    * @param prefix The prefix of variables to convert
    * @return the converted node.
    */
-  Node convert(Node n, const std::string& prefix);
+  Node convert(NodeManager* nm, Node n, const std::string& prefix);
 
  private:
   /** The set of terms that have already been "decleared", i.e., already had
diff --git a/src/proof/alethe/alethe_node_converter.cpp b/src/proof/alethe/alethe_node_converter.cpp
index 767fac30e..2b474c344 100644
--- a/src/proof/alethe/alethe_node_converter.cpp
+++ b/src/proof/alethe/alethe_node_converter.cpp
@@ -41,7 +41,6 @@ Node AletheNodeConverter::maybeConvert(Node n, bool isAssumption)
 
 Node AletheNodeConverter::postConvert(Node n)
 {
-  NodeManager* nm = NodeManager::currentNM();
   Kind k = n.getKind();
   Trace("alethe-conv") << "AletheNodeConverter: convert " << n << ", kind " << k
                        << "\n";
@@ -52,9 +51,9 @@ Node AletheNodeConverter::postConvert(Node n)
       std::stringstream ss;
       ss << "(_ @bitOf " << n.getOperator().getConst<BitVectorBit>().d_bitIndex
          << ")";
-      TypeNode fType = nm->mkFunctionType(n[0].getType(), n.getType());
+      TypeNode fType = d_nm->mkFunctionType(n[0].getType(), n.getType());
       Node op = mkInternalSymbol(ss.str(), fType, true);
-      Node converted = nm->mkNode(Kind::APPLY_UF, op, n[0]);
+      Node converted = d_nm->mkNode(Kind::APPLY_UF, op, n[0]);
       return converted;
     }
     case Kind::BITVECTOR_FROM_BOOLS:
@@ -66,10 +65,10 @@ Node AletheNodeConverter::postConvert(Node n)
         childrenTypes.push_back(c.getType());
         children.push_back(c);
       }
-      TypeNode fType = nm->mkFunctionType(childrenTypes, n.getType());
+      TypeNode fType = d_nm->mkFunctionType(childrenTypes, n.getType());
       Node op = mkInternalSymbol("@bbT", fType, true);
       children.insert(children.begin(), op);
-      Node converted = nm->mkNode(Kind::APPLY_UF, children);
+      Node converted = d_nm->mkNode(Kind::APPLY_UF, children);
       return converted;
     }
     case Kind::BITVECTOR_EAGER_ATOM:
@@ -78,21 +77,21 @@ Node AletheNodeConverter::postConvert(Node n)
     }
     case Kind::DIVISION_TOTAL:
     {
-      return nm->mkNode(Kind::DIVISION, n[0], n[1]);
+      return d_nm->mkNode(Kind::DIVISION, n[0], n[1]);
     }
     case Kind::INTS_DIVISION_TOTAL:
     {
-      return nm->mkNode(Kind::INTS_DIVISION, n[0], n[1]);
+      return d_nm->mkNode(Kind::INTS_DIVISION, n[0], n[1]);
     }
     case Kind::INTS_MODULUS_TOTAL:
     {
-      return nm->mkNode(Kind::INTS_MODULUS, n[0], n[1]);
+      return d_nm->mkNode(Kind::INTS_MODULUS, n[0], n[1]);
     }
     case Kind::SKOLEM:
     {
       Trace("alethe-conv") << "AletheNodeConverter: handling skolem " << n
                            << "\n";
-      SkolemManager* sm = nm->getSkolemManager();
+      SkolemManager* sm = d_nm->getSkolemManager();
       SkolemId sfi = SkolemId::NONE;
       Node cacheVal;
       sm->isSkolemFunction(n, sfi, cacheVal);
@@ -138,12 +137,12 @@ Node AletheNodeConverter::postConvert(Node n)
         Node body =
             (index == quant[0].getNumChildren() - 1
                  ? quant[1]
-                 : nm->mkNode(
-                     Kind::FORALL,
-                     nm->mkNode(Kind::BOUND_VAR_LIST,
-                                std::vector<Node>{quant[0].begin() + index + 1,
-                                                  quant[0].end()}),
-                     quant[1]))
+                 : d_nm->mkNode(Kind::FORALL,
+                                d_nm->mkNode(Kind::BOUND_VAR_LIST,
+                                             std::vector<Node>{
+                                                 quant[0].begin() + index + 1,
+                                                 quant[0].end()}),
+                                quant[1]))
                 .notNode();
         // we need to replace in the body all the free variables (i.e., from 0
         // to index) by their respective choice terms. To do this, we get
@@ -154,7 +153,7 @@ Node AletheNodeConverter::postConvert(Node n)
           std::vector<Node> subs;
           for (size_t i = 0; i < index; ++i)
           {
-            std::vector<Node> cacheVals{quant, nm->mkConstInt(Rational(i))};
+            std::vector<Node> cacheVals{quant, d_nm->mkConstInt(Rational(i))};
             Node sk = sm->mkSkolemFunction(SkolemId::QUANTIFIERS_SKOLEMIZE,
                                            cacheVals);
             Assert(!sk.isNull());
@@ -165,8 +164,8 @@ Node AletheNodeConverter::postConvert(Node n)
                                  subs.begin(),
                                  subs.end());
         }
-        Node witness = nm->mkNode(
-            Kind::WITNESS, nm->mkNode(Kind::BOUND_VAR_LIST, var), body);
+        Node witness = d_nm->mkNode(
+            Kind::WITNESS, d_nm->mkNode(Kind::BOUND_VAR_LIST, var), body);
         Trace("alethe-conv") << ".. witness: " << witness << "\n";
         witness = convert(witness);
         if (d_defineSkolems)
@@ -179,7 +178,7 @@ Node AletheNodeConverter::postConvert(Node n)
             for (size_t i = index + 1; i > 0; --i)
             {
               std::vector<Node> cacheVals{quant,
-                                          nm->mkConstInt(Rational(i - 1))};
+                                          d_nm->mkConstInt(Rational(i - 1))};
               Node sk = sm->mkSkolemFunction(SkolemId::QUANTIFIERS_SKOLEMIZE,
                                              cacheVals);
               Assert(!sk.isNull());
@@ -203,7 +202,8 @@ Node AletheNodeConverter::postConvert(Node n)
     case Kind::FORALL:
     {
       // remove patterns, if any
-      return n.getNumChildren() == 3 ? nm->mkNode(Kind::FORALL, n[0], n[1]) : n;
+      return n.getNumChildren() == 3 ? d_nm->mkNode(Kind::FORALL, n[0], n[1])
+                                     : n;
     }
     // we must make it to be printed with "choice", so we create an operator
     // with that name and the correct type and do a function application
@@ -214,9 +214,9 @@ Node AletheNodeConverter::postConvert(Node n)
       {
         childrenTypes.push_back(c.getType());
       }
-      TypeNode fType = nm->mkFunctionType(childrenTypes, n.getType());
+      TypeNode fType = d_nm->mkFunctionType(childrenTypes, n.getType());
       Node choiceOp = mkInternalSymbol("choice", fType);
-      Node converted = nm->mkNode(Kind::APPLY_UF, choiceOp, n[0], n[1]);
+      Node converted = d_nm->mkNode(Kind::APPLY_UF, choiceOp, n[0], n[1]);
       Trace("alethe-conv") << ".. converted to choice: " << converted << "\n";
       return converted;
     }
@@ -427,8 +427,8 @@ Node AletheNodeConverter::mkInternalSymbol(const std::string& name,
   {
     return it->second;
   }
-  NodeManager* nm = NodeManager::currentNM();
-  Node sym = useRawSym ? nm->mkRawSymbol(name, tn) : nm->mkBoundVar(name, tn);
+  Node sym =
+      useRawSym ? d_nm->mkRawSymbol(name, tn) : d_nm->mkBoundVar(name, tn);
   d_symbolsMap[key] = sym;
   return sym;
 }
diff --git a/src/proof/alethe/alethe_printer.cpp b/src/proof/alethe/alethe_printer.cpp
index 9253164f9..aa89c8efa 100644
--- a/src/proof/alethe/alethe_printer.cpp
+++ b/src/proof/alethe/alethe_printer.cpp
@@ -154,7 +154,7 @@ void AletheProofPrinter::printTerm(std::ostream& out, TNode n)
   options::ioutils::applyDagThresh(ss, 0);
   // Guarantee we print reals as expected
   options::ioutils::applyPrintArithLitToken(ss, true);
-  ss << d_lbind.convert(n, "@p_");
+  ss << d_lbind.convert(nodeManager(), n, "@p_");
   out << ss.str();
 }
 
diff --git a/src/proof/alf/alf_node_converter.cpp b/src/proof/alf/alf_node_converter.cpp
index 4d0d18417..eb6f0a0e8 100644
--- a/src/proof/alf/alf_node_converter.cpp
+++ b/src/proof/alf/alf_node_converter.cpp
@@ -72,7 +72,6 @@ Node AlfNodeConverter::preConvert(Node n)
 
 Node AlfNodeConverter::postConvert(Node n)
 {
-  NodeManager* nm = NodeManager::currentNM();
   Kind k = n.getKind();
   // we eliminate MATCH at preConvert above
   Assert(k != Kind::MATCH);
@@ -105,7 +104,7 @@ Node AlfNodeConverter::postConvert(Node n)
     // This case will only apply for terms originating from places with no
     // proof support. Note it is not added as a declared variable, instead it
     // is used as (var N T) throughout.
-    Node index = nm->mkConstInt(Rational(getOrAssignIndexForConst(n)));
+    Node index = d_nm->mkConstInt(Rational(getOrAssignIndexForConst(n)));
     Node tc = typeAsNode(tn);
     return mkInternalApp("const", {index, tc}, tn);
   }
@@ -127,7 +126,7 @@ Node AlfNodeConverter::postConvert(Node n)
     // A variable x of type T can unambiguously referred to as (eo::var "x" T).
     // We convert to this representation here, which will often be letified.
     std::vector<Node> args;
-    Node nn = nm->mkConst(String(sname));
+    Node nn = d_nm->mkConst(String(sname));
     args.push_back(nn);
     Node tnn = typeAsNode(tn);
     args.push_back(tnn);
@@ -200,8 +199,8 @@ Node AlfNodeConverter::postConvert(Node n)
   else if (k == Kind::CONST_FINITE_FIELD)
   {
     const FiniteFieldValue& ffv = n.getConst<FiniteFieldValue>();
-    Node v = convert(nm->mkConstInt(ffv.getValue()));
-    Node fs = convert(nm->mkConstInt(ffv.getFieldSize()));
+    Node v = convert(d_nm->mkConstInt(ffv.getValue()));
+    Node fs = convert(d_nm->mkConstInt(ffv.getFieldSize()));
     return mkInternalApp("ff.value", {fs, v}, tn);
   }
   else if (k == Kind::FUNCTION_ARRAY_CONST)
@@ -235,14 +234,14 @@ Node AlfNodeConverter::postConvert(Node n)
     }
     newArgs.push_back(opc);
     newArgs.insert(newArgs.end(), n.begin(), n.end());
-    return nm->mkNode(Kind::APPLY_UF, newArgs);
+    return d_nm->mkNode(Kind::APPLY_UF, newArgs);
   }
   else if (k == Kind::INDEXED_ROOT_PREDICATE)
   {
     const IndexedRootPredicate& irp =
         n.getOperator().getConst<IndexedRootPredicate>();
     std::vector<Node> newArgs;
-    newArgs.push_back(nm->mkConstInt(irp.d_index));
+    newArgs.push_back(d_nm->mkConstInt(irp.d_index));
     newArgs.insert(newArgs.end(), n.begin(), n.end());
     return mkInternalApp("@indexed_root_predicate", newArgs, tn);
   }
@@ -320,8 +319,7 @@ bool AlfNodeConverter::shouldTraverse(Node n)
 
 Node AlfNodeConverter::maybeMkSkolemFun(Node k)
 {
-  NodeManager* nm = NodeManager::currentNM();
-  SkolemManager* sm = nm->getSkolemManager();
+  SkolemManager* sm = d_nm->getSkolemManager();
   SkolemId sfi = SkolemId::NONE;
   Node cacheVal;
   TypeNode tn = k.getType();
@@ -392,7 +390,7 @@ size_t AlfNodeConverter::getNumChildrenToProcessForClosure(Kind k) const
 Node AlfNodeConverter::mkList(const std::vector<Node>& args)
 {
   Assert(!args.empty());
-  TypeNode tn = NodeManager::currentNM()->booleanType();
+  TypeNode tn = d_nm->booleanType();
   // singleton lists are handled due to (@list x) ---> (@list x eo::nil)
   return mkInternalApp("@list", args, tn);
 }
@@ -402,8 +400,8 @@ Node AlfNodeConverter::mkInternalSymbol(const std::string& name,
                                         bool useRawSym)
 {
   // use raw symbol so that it is never quoted
-  NodeManager* nm = NodeManager::currentNM();
-  Node sym = useRawSym ? nm->mkRawSymbol(name, tn) : nm->mkBoundVar(name, tn);
+  Node sym =
+      useRawSym ? d_nm->mkRawSymbol(name, tn) : d_nm->mkBoundVar(name, tn);
   d_symbols.insert(sym);
   return sym;
 }
@@ -421,13 +419,12 @@ Node AlfNodeConverter::mkInternalApp(const std::string& name,
       Assert(!a.isNull());
       argTypes.push_back(a.getType());
     }
-    NodeManager* nm = NodeManager::currentNM();
-    TypeNode atype = nm->mkFunctionType(argTypes, ret);
+    TypeNode atype = d_nm->mkFunctionType(argTypes, ret);
     Node op = mkInternalSymbol(name, atype, useRawSym);
     std::vector<Node> aargs;
     aargs.push_back(op);
     aargs.insert(aargs.end(), args.begin(), args.end());
-    return nm->mkNode(Kind::APPLY_UF, aargs);
+    return d_nm->mkNode(Kind::APPLY_UF, aargs);
   }
   return mkInternalSymbol(name, ret, useRawSym);
 }
@@ -435,7 +432,6 @@ Node AlfNodeConverter::mkInternalApp(const std::string& name,
 Node AlfNodeConverter::getOperatorOfTerm(Node n, bool reqCast)
 {
   Assert(n.hasOperator());
-  NodeManager* nm = NodeManager::currentNM();
   Kind k = n.getKind();
   std::stringstream opName;
   Trace("alf-term-process-debug2")
@@ -493,7 +489,7 @@ Node AlfNodeConverter::getOperatorOfTerm(Node n, bool reqCast)
         if (dt.isTuple())
         {
           opName << "tuple.update";
-          indices.push_back(nm->mkConstInt(cindex));
+          indices.push_back(d_nm->mkConstInt(cindex));
         }
         else
         {
@@ -544,7 +540,7 @@ Node AlfNodeConverter::getOperatorOfTerm(Node n, bool reqCast)
       const DType& dt = DType::datatypeOf(op);
       if (dt.isTuple())
       {
-        indices.push_back(nm->mkConstInt(index));
+        indices.push_back(d_nm->mkConstInt(index));
         opName << "tuple.select";
       }
       else
@@ -572,14 +568,14 @@ Node AlfNodeConverter::getOperatorOfTerm(Node n, bool reqCast)
           || k == Kind::BITVECTOR_XOR)
       {
         TypeNode tna = n[0].getType();
-        indices.push_back(nm->mkConstInt(tna.getBitVectorSize()));
+        indices.push_back(d_nm->mkConstInt(tna.getBitVectorSize()));
         isParameterized = true;
       }
       else if (k == Kind::FINITE_FIELD_ADD || k == Kind::FINITE_FIELD_BITSUM
                || k == Kind::FINITE_FIELD_MULT)
       {
         TypeNode tna = n[0].getType();
-        indices.push_back(nm->mkConstInt(tna.getFfSize()));
+        indices.push_back(d_nm->mkConstInt(tna.getFfSize()));
         isParameterized = true;
       }
       else if (k == Kind::STRING_CONCAT)
diff --git a/src/proof/alf/alf_printer.cpp b/src/proof/alf/alf_printer.cpp
index a65410951..c5b947fcc 100644
--- a/src/proof/alf/alf_printer.cpp
+++ b/src/proof/alf/alf_printer.cpp
@@ -492,7 +492,7 @@ void AlfPrinter::printDslRule(std::ostream& out, ProofRewriteRule r)
     // renamed to `x1s2123`, which will be renamed to `x1s1` here.
     std::string str = sss.str();
     size_t index = str.find_last_not_of("0123456789");
-    std::string result = str.substr(0, index+1);
+    std::string result = str.substr(0, index + 1);
     sss.str("");
     nameCount[result]++;
     sss << result << nameCount[result];
diff --git a/src/proof/lfsc/lfsc_list_sc_node_converter.cpp b/src/proof/lfsc/lfsc_list_sc_node_converter.cpp
index 72acf2299..cd3ba4824 100644
--- a/src/proof/lfsc/lfsc_list_sc_node_converter.cpp
+++ b/src/proof/lfsc/lfsc_list_sc_node_converter.cpp
@@ -29,7 +29,6 @@ LfscListScNodeConverter::LfscListScNodeConverter(
 
 Node LfscListScNodeConverter::postConvert(Node n)
 {
-  NodeManager* nm = NodeManager::currentNM();
   Kind k = n.getKind();
   if (d_isPre)
   {
@@ -63,7 +62,7 @@ Node LfscListScNodeConverter::postConvert(Node n)
       children.push_back(d_conv.convert(null));
       Node sop = mkOperatorFor("nary_elim", children, tn);
       children.insert(children.begin(), sop);
-      return nm->mkNode(Kind::APPLY_UF, children);
+      return d_nm->mkNode(Kind::APPLY_UF, children);
     }
     return n;
   }
@@ -86,7 +85,7 @@ Node LfscListScNodeConverter::postConvert(Node n)
       Assert(k != Kind::UNDEFINED_KIND);
       // for uniformity, reconstruct in original form
       std::vector<Node> nchildren(n.begin(), n.end());
-      n = nm->mkNode(k, nchildren);
+      n = d_nm->mkNode(k, nchildren);
     }
     Node null = d_conv.getNullTerminator(k, tn);
     AlwaysAssert(!null.isNull())
@@ -106,7 +105,7 @@ Node LfscListScNodeConverter::postConvert(Node n)
     children.push_back(null);
     Node sop = mkOperatorFor("nary_concat", children, tn);
     children.insert(children.begin(), sop);
-    return nm->mkNode(Kind::APPLY_UF, children);
+    return d_nm->mkNode(Kind::APPLY_UF, children);
   }
   return n;
 }
@@ -115,13 +114,12 @@ Node LfscListScNodeConverter::mkOperatorFor(const std::string& name,
                                             const std::vector<Node>& children,
                                             TypeNode retType)
 {
-  NodeManager* nm = NodeManager::currentNM();
   std::vector<TypeNode> childTypes;
   for (const Node& c : children)
   {
     childTypes.push_back(c.getType());
   }
-  TypeNode ftype = nm->mkFunctionType(childTypes, retType);
+  TypeNode ftype = d_nm->mkFunctionType(childTypes, retType);
   return d_conv.mkInternalSymbol(name, ftype);
 }
 
diff --git a/src/proof/lfsc/lfsc_node_converter.cpp b/src/proof/lfsc/lfsc_node_converter.cpp
index f6b41bf2b..1791f1ba1 100644
--- a/src/proof/lfsc/lfsc_node_converter.cpp
+++ b/src/proof/lfsc/lfsc_node_converter.cpp
@@ -89,7 +89,6 @@ Node LfscNodeConverter::preConvert(Node n)
 
 Node LfscNodeConverter::postConvert(Node n)
 {
-  NodeManager* nm = NodeManager::currentNM();
   Kind k = n.getKind();
   // we eliminate MATCH at preConvert above
   Assert(k != Kind::MATCH);
@@ -109,10 +108,10 @@ Node LfscNodeConverter::postConvert(Node n)
       return n;
     }
     // bound variable v is (bvar x T)
-    TypeNode intType = nm->integerType();
-    Node x = nm->mkConstInt(Rational(getOrAssignIndexForBVar(n)));
+    TypeNode intType = d_nm->integerType();
+    Node x = d_nm->mkConstInt(Rational(getOrAssignIndexForBVar(n)));
     Node tc = typeAsNode(convertType(tn));
-    TypeNode ftype = nm->mkFunctionType({intType, d_sortType}, tn);
+    TypeNode ftype = d_nm->mkFunctionType({intType, d_sortType}, tn);
     Node bvarOp = getSymbolInternal(k, ftype, "bvar");
     return mkApplyUf(bvarOp, {x, tc});
   }
@@ -142,7 +141,7 @@ Node LfscNodeConverter::postConvert(Node n)
       wi = convert(wi);
       Trace("lfsc-term-process-debug")
           << "...converted original for " << wi << std::endl;
-      TypeNode ftype = nm->mkFunctionType(tn, tn);
+      TypeNode ftype = d_nm->mkFunctionType(tn, tn);
       Node skolemOp = getSymbolInternal(k, ftype, "skolem");
       return mkApplyUf(skolemOp, {wi});
     }
@@ -156,10 +155,10 @@ Node LfscNodeConverter::postConvert(Node n)
     // This case will only apply for terms originating from places with no
     // proof support. Note it is not added as a declared variable, instead it
     // is used as (var N T) throughout.
-    TypeNode intType = nm->integerType();
-    TypeNode varType = nm->mkFunctionType({intType, d_sortType}, tn);
+    TypeNode intType = d_nm->integerType();
+    TypeNode varType = d_nm->mkFunctionType({intType, d_sortType}, tn);
     Node var = mkInternalSymbol("var", varType);
-    Node index = nm->mkConstInt(Rational(getOrAssignIndexForFVar(n)));
+    Node index = d_nm->mkConstInt(Rational(getOrAssignIndexForFVar(n)));
     Node tc = typeAsNode(convertType(tn));
     return mkApplyUf(var, {index, tc});
   }
@@ -175,9 +174,9 @@ Node LfscNodeConverter::postConvert(Node n)
     const CardinalityConstraint& cc =
         n.getOperator().getConst<CardinalityConstraint>();
     Node tnn = typeAsNode(convertType(cc.getType()));
-    Node ub = nm->mkConstInt(Rational(cc.getUpperBound()));
-    TypeNode tnc =
-        nm->mkFunctionType({tnn.getType(), ub.getType()}, nm->booleanType());
+    Node ub = d_nm->mkConstInt(Rational(cc.getUpperBound()));
+    TypeNode tnc = d_nm->mkFunctionType({tnn.getType(), ub.getType()},
+                                        d_nm->booleanType());
     Node fcard = getSymbolInternal(k, tnc, "fmf.card");
     return mkApplyUf(fcard, {tnn, ub});
   }
@@ -205,13 +204,13 @@ Node LfscNodeConverter::postConvert(Node n)
     std::vector<TypeNode> argTypes;
     argTypes.push_back(n[0].getType());
     argTypes.push_back(n[1].getType());
-    TypeNode tnh = nm->mkFunctionType(argTypes, tn);
+    TypeNode tnh = d_nm->mkFunctionType(argTypes, tn);
     Node hconstf = getSymbolInternal(k, tnh, "apply");
     return mkApplyUf(hconstf, {n[0], n[1]});
   }
   else if (k == Kind::CONST_RATIONAL || k == Kind::CONST_INTEGER)
   {
-    TypeNode tnv = nm->mkFunctionType(tn, tn);
+    TypeNode tnv = d_nm->mkFunctionType(tn, tn);
     Node rconstf;
     Node arg;
     Rational r = n.getConst<Rational>();
@@ -221,8 +220,8 @@ Node LfscNodeConverter::postConvert(Node n)
       if (r.sgn() == -1)
       {
         // use LFSC syntax for mpz negation
-        Node mpzn = getSymbolInternal(k, nm->mkFunctionType(tn, tn), "~");
-        arg = mkApplyUf(mpzn, {nm->mkConstInt(r.abs())});
+        Node mpzn = getSymbolInternal(k, d_nm->mkFunctionType(tn, tn), "~");
+        arg = mkApplyUf(mpzn, {d_nm->mkConstInt(r.abs())});
       }
       else
       {
@@ -241,7 +240,7 @@ Node LfscNodeConverter::postConvert(Node n)
       // negative (~ n/m)
       if (r.sgn() == -1)
       {
-        Node mpzn = getSymbolInternal(k, nm->mkFunctionType(tn, tn), "~");
+        Node mpzn = getSymbolInternal(k, d_nm->mkFunctionType(tn, tn), "~");
         arg = mkApplyUf(mpzn, {arg});
       }
     }
@@ -249,8 +248,8 @@ Node LfscNodeConverter::postConvert(Node n)
   }
   else if (k == Kind::CONST_BITVECTOR)
   {
-    TypeNode btn = nm->booleanType();
-    TypeNode tnv = nm->mkFunctionType(btn, tn);
+    TypeNode btn = d_nm->booleanType();
+    TypeNode tnv = d_nm->mkFunctionType(btn, tn);
     BitVector bv = n.getConst<BitVector>();
     Node ret = convertBitVector(bv);
     Node bconstf = getSymbolInternal(k, tnv, "bv");
@@ -260,20 +259,20 @@ Node LfscNodeConverter::postConvert(Node n)
   {
     BitVector s, e, i;
     n.getConst<FloatingPoint>().getIEEEBitvectors(s, e, i);
-    Node sn = convert(nm->mkConst(s));
-    Node en = convert(nm->mkConst(e));
-    Node in = convert(nm->mkConst(i));
+    Node sn = convert(d_nm->mkConst(s));
+    Node en = convert(d_nm->mkConst(e));
+    Node in = convert(d_nm->mkConst(i));
     TypeNode tnv =
-        nm->mkFunctionType({sn.getType(), en.getType(), in.getType()}, tn);
+        d_nm->mkFunctionType({sn.getType(), en.getType(), in.getType()}, tn);
     Node bconstf = getSymbolInternal(k, tnv, "fp");
     return mkApplyUf(bconstf, {sn, en, in});
   }
   else if (k == Kind::CONST_FINITE_FIELD)
   {
     const FiniteFieldValue& ffv = n.getConst<FiniteFieldValue>();
-    Node v = convert(nm->mkConstInt(ffv.getValue()));
-    Node fs = convert(nm->mkConstInt(ffv.getFieldSize()));
-    TypeNode tnv = nm->mkFunctionType({v.getType(), fs.getType()}, tn);
+    Node v = convert(d_nm->mkConstInt(ffv.getValue()));
+    Node fs = convert(d_nm->mkConstInt(ffv.getFieldSize()));
+    TypeNode tnv = d_nm->mkFunctionType({v.getType(), fs.getType()}, tn);
     Node ffconstf = getSymbolInternal(k, tnv, "ff.value");
     return mkApplyUf(ffconstf, {v, fs});
   }
@@ -294,34 +293,35 @@ Node LfscNodeConverter::postConvert(Node n)
     Node ret = postConvert(getNullTerminator(Kind::STRING_CONCAT, tn));
     for (size_t i = 0, size = charVec.size(); i < size; i++)
     {
-      ret = nm->mkNode(Kind::STRING_CONCAT, charVec[i], ret);
+      ret = d_nm->mkNode(Kind::STRING_CONCAT, charVec[i], ret);
     }
     return ret;
   }
   else if (k == Kind::CONST_SEQUENCE)
   {
     const std::vector<Node>& charVec = n.getConst<Sequence>().getVec();
-    TypeNode etype = nm->mkFunctionType(d_sortType, tn);
+    TypeNode etype = d_nm->mkFunctionType(d_sortType, tn);
     Node ret = getSymbolInternal(k, etype, "seq.empty");
     ret = mkApplyUf(ret, {typeAsNode(convertType(tn))});
     std::vector<Node> vecu;
     for (size_t i = 0, size = charVec.size(); i < size; i++)
     {
-      Node u = nm->mkNode(Kind::SEQ_UNIT, postConvert(charVec[size - (i + 1)]));
+      Node u =
+          d_nm->mkNode(Kind::SEQ_UNIT, postConvert(charVec[size - (i + 1)]));
       if (size == 1)
       {
         // singleton case
         return u;
       }
-      ret = nm->mkNode(Kind::STRING_CONCAT, u, ret);
+      ret = d_nm->mkNode(Kind::STRING_CONCAT, u, ret);
     }
     return ret;
   }
   else if (k == Kind::STORE_ALL)
   {
     Node t = typeAsNode(convertType(tn));
-    TypeNode caRetType = nm->mkFunctionType(tn.getArrayConstituentType(), tn);
-    TypeNode catype = nm->mkFunctionType(d_sortType, caRetType);
+    TypeNode caRetType = d_nm->mkFunctionType(tn.getArrayConstituentType(), tn);
+    TypeNode catype = d_nm->mkFunctionType(d_sortType, caRetType);
     Node bconstf = getSymbolInternal(k, catype, "array_const");
     Node f = mkApplyUf(bconstf, {t});
     ArrayStoreAll storeAll = n.getConst<ArrayStoreAll>();
@@ -344,7 +344,7 @@ Node LfscNodeConverter::postConvert(Node n)
            || k == Kind::BAG_EMPTY)
   {
     Node t = typeAsNode(convertType(tn));
-    TypeNode etype = nm->mkFunctionType(d_sortType, tn);
+    TypeNode etype = d_nm->mkFunctionType(d_sortType, tn);
     Node ef = getSymbolInternal(
         k,
         etype,
@@ -383,27 +383,27 @@ Node LfscNodeConverter::postConvert(Node n)
   else if (k == Kind::REGEXP_LOOP)
   {
     // ((_ re.loop n1 n2) t) is ((re.loop n1 n2) t)
-    TypeNode intType = nm->integerType();
+    TypeNode intType = d_nm->integerType();
     TypeNode relType =
-        nm->mkFunctionType({intType, intType}, nm->mkFunctionType(tn, tn));
+        d_nm->mkFunctionType({intType, intType}, d_nm->mkFunctionType(tn, tn));
     Node rop = getSymbolInternal(
         k, relType, printer::smt2::Smt2Printer::smtKindString(k));
     RegExpLoop op = n.getOperator().getConst<RegExpLoop>();
-    Node n1 = nm->mkConstInt(Rational(op.d_loopMinOcc));
-    Node n2 = nm->mkConstInt(Rational(op.d_loopMaxOcc));
+    Node n1 = d_nm->mkConstInt(Rational(op.d_loopMinOcc));
+    Node n2 = d_nm->mkConstInt(Rational(op.d_loopMaxOcc));
     return mkApplyUf(mkApplyUf(rop, {n1, n2}), {n[0]});
   }
   else if (k == Kind::BITVECTOR_FROM_BOOLS)
   {
-    TypeNode btn = nm->booleanType();
+    TypeNode btn = d_nm->booleanType();
     // (from_bools t1 ... tn) is
     // (from_bools t1 (from_bools t2 ... (from_bools tn emptybv)))
     // where notice that each from_bools has a different type
     Node curr = getNullTerminator(Kind::BITVECTOR_CONCAT, tn);
     for (size_t i = 0, nchild = n.getNumChildren(); i < nchild; ++i)
     {
-      TypeNode bvt = nm->mkBitVectorType(i + 1);
-      TypeNode ftype = nm->mkFunctionType({btn, curr.getType()}, bvt);
+      TypeNode bvt = d_nm->mkBitVectorType(i + 1);
+      TypeNode ftype = d_nm->mkFunctionType({btn, curr.getType()}, bvt);
       Node bbt = getSymbolInternal(k, ftype, "from_bools");
       curr = mkApplyUf(bbt, {n[nchild - (i + 1)], curr});
     }
@@ -412,7 +412,7 @@ Node LfscNodeConverter::postConvert(Node n)
   else if (k == Kind::SEP_NIL)
   {
     Node tnn = typeAsNode(convertType(tn));
-    TypeNode ftype = nm->mkFunctionType(d_sortType, tn);
+    TypeNode ftype = d_nm->mkFunctionType(d_sortType, tn);
     Node s = getSymbolInternal(k, ftype, "sep.nil");
     return mkApplyUf(s, {tnn});
   }
@@ -427,14 +427,14 @@ Node LfscNodeConverter::postConvert(Node n)
     {
       // DISTINCT(x1,...,xn) --->
       // AND(DISTINCT(x1,x2), AND(,..., AND(,..,DISTINCT(x_{n-1},x_n))))
-      Node ret = nm->mkNode(k, children[0], children[1]);
+      Node ret = d_nm->mkNode(k, children[0], children[1]);
       for (unsigned i = 0; i < nchild; i++)
         for (unsigned j = i + 1; j < nchild; j++)
         {
           if (i != 0 && j != 1)
           {
-            ret = nm->mkNode(
-                Kind::AND, ret, nm->mkNode(k, children[i], children[j]));
+            ret = d_nm->mkNode(
+                Kind::AND, ret, d_nm->mkNode(k, children[i], children[j]));
           }
         }
       Trace("lfsc-term-process-debug") << "n: " << n << std::endl
@@ -484,13 +484,13 @@ Node LfscNodeConverter::postConvert(Node n)
         // avoid debug failures.
         TypeNode tn1 = children[i].getType();
         TypeNode tn2 = ret.getType();
-        TypeNode ftype = nm->mkFunctionType({tn1, tn2}, tn);
+        TypeNode ftype = d_nm->mkFunctionType({tn1, tn2}, tn);
         Node opc = getSymbolInternal(k, ftype, arithOpName.str());
         ret = mkApplyUf(opc, {children[i], ret});
       }
       else
       {
-        ret = nm->mkNode(k, children[i], ret);
+        ret = d_nm->mkNode(k, children[i], ret);
       }
     }
     Trace("lfsc-term-process-debug")
@@ -502,7 +502,6 @@ Node LfscNodeConverter::postConvert(Node n)
 
 Node LfscNodeConverter::mkApplyUf(Node op, const std::vector<Node>& args) const
 {
-  NodeManager * nm = NodeManager::currentNM();
   std::vector<Node> aargs;
   if (op.isVar())
   {
@@ -515,11 +514,11 @@ Node LfscNodeConverter::mkApplyUf(Node op, const std::vector<Node>& args) const
     options::ioutils::applyOutputLanguage(ss, Language::LANG_SMTLIB_V2_6);
     options::ioutils::applyDagThresh(ss, 0);
     ss << op;
-    Node opv = nm->mkRawSymbol(ss.str(), op.getType());
+    Node opv = d_nm->mkRawSymbol(ss.str(), op.getType());
     aargs.push_back(opv);
   }
   aargs.insert(aargs.end(), args.begin(), args.end());
-  return nm->mkNode(Kind::APPLY_UF, aargs);
+  return d_nm->mkNode(Kind::APPLY_UF, aargs);
 }
 
 TypeNode LfscNodeConverter::preConvertType(TypeNode tn)
@@ -536,7 +535,6 @@ TypeNode LfscNodeConverter::preConvertType(TypeNode tn)
 
 TypeNode LfscNodeConverter::postConvertType(TypeNode tn)
 {
-  NodeManager* nm = NodeManager::currentNM();
   TypeNode cur = tn;
   Node tnn;
   Kind k = tn.getKind();
@@ -559,21 +557,21 @@ TypeNode LfscNodeConverter::postConvertType(TypeNode tn)
       std::vector<TypeNode> aargs;
       aargs.push_back(*it);
       aargs.push_back(cur);
-      cur = nm->mkSort(d_arrow, aargs);
+      cur = d_nm->mkSort(d_arrow, aargs);
       tnn = mkApplyUf(arrown, {typeAsNode(*it), tnn});
     }
   }
   else if (k == Kind::BITVECTOR_TYPE)
   {
     tnn = d_typeKindToNodeCons[k];
-    Node w = nm->mkConstInt(Rational(tn.getBitVectorSize()));
+    Node w = d_nm->mkConstInt(Rational(tn.getBitVectorSize()));
     tnn = mkApplyUf(tnn, {w});
   }
   else if (k == Kind::FLOATINGPOINT_TYPE)
   {
     tnn = d_typeKindToNodeCons[k];
-    Node e = nm->mkConstInt(Rational(tn.getFloatingPointExponentSize()));
-    Node s = nm->mkConstInt(Rational(tn.getFloatingPointSignificandSize()));
+    Node e = d_nm->mkConstInt(Rational(tn.getFloatingPointExponentSize()));
+    Node s = d_nm->mkConstInt(Rational(tn.getFloatingPointSignificandSize()));
     tnn = mkApplyUf(tnn, {e, s});
   }
   else if (k == Kind::TUPLE_TYPE)
@@ -592,14 +590,14 @@ TypeNode LfscNodeConverter::postConvertType(TypeNode tn)
         convTypes.push_back(tnc);
         targs.push_back(typeAsNode(tnc));
       }
-      TypeNode ftype = nm->mkFunctionType(types, d_sortType);
+      TypeNode ftype = d_nm->mkFunctionType(types, d_sortType);
       // must distinguish by arity
       std::stringstream ss;
       ss << "Tuple_" << nargs;
       tnn = mkApplyUf(getSymbolInternal(k, ftype, ss.str()), targs);
       // we are changing its name, we must make a sort constructor
-      cur = nm->mkSortConstructor(ss.str(), nargs);
-      cur = nm->mkSort(cur, convTypes);
+      cur = d_nm->mkSortConstructor(ss.str(), nargs);
+      cur = d_nm->mkSort(cur, convTypes);
     }
     else
     {
@@ -620,13 +618,14 @@ TypeNode LfscNodeConverter::postConvertType(TypeNode tn)
     {
       std::string s = getNameForUserNameOfInternal(tn.getId(), ss.str());
       tnn = getSymbolInternal(k, d_sortType, s, false);
-      cur = nm->mkSortConstructor(s, tn.getUninterpretedSortConstructorArity());
+      cur =
+          d_nm->mkSortConstructor(s, tn.getUninterpretedSortConstructorArity());
     }
     else if (tn.isUninterpretedSort() || tn.isDatatype())
     {
       std::string s = getNameForUserNameOfInternal(tn.getId(), ss.str());
       tnn = getSymbolInternal(k, d_sortType, s, false);
-      cur = nm->mkSort(s);
+      cur = d_nm->mkSort(s);
     }
     else
     {
@@ -652,7 +651,7 @@ TypeNode LfscNodeConverter::postConvertType(TypeNode tn)
       // erase first child, which repeats the datatype
       targs.erase(targs.begin(), targs.begin() + 1);
       types.erase(types.begin(), types.begin() + 1);
-      TypeNode ftype = nm->mkFunctionType(types, d_sortType);
+      TypeNode ftype = d_nm->mkFunctionType(types, d_sortType);
       // the operator has been converted; it is no longer a datatype, thus
       // we must print to get its name.
       std::stringstream ss;
@@ -667,13 +666,13 @@ TypeNode LfscNodeConverter::postConvertType(TypeNode tn)
       // should be erased from children.
       targs.erase(targs.begin(), targs.begin() + 1);
       types.erase(types.begin(), types.begin() + 1);
-      TypeNode ftype = nm->mkFunctionType(types, d_sortType);
+      TypeNode ftype = d_nm->mkFunctionType(types, d_sortType);
       std::string name = tn.getUninterpretedSortConstructor().getName();
       op = getSymbolInternal(k, ftype, name, false);
     }
     else if (k == Kind::NULLABLE_TYPE)
     {
-      TypeNode ftype = nm->mkFunctionType(d_sortType, d_sortType);
+      TypeNode ftype = d_nm->mkFunctionType(d_sortType, d_sortType);
       op = getSymbolInternal(k, ftype, "Nullable", false);
     }
     else
@@ -792,8 +791,7 @@ bool LfscNodeConverter::shouldTraverse(Node n)
 
 Node LfscNodeConverter::maybeMkSkolemFun(Node k, bool macroApply)
 {
-  NodeManager* nm = NodeManager::currentNM();
-  SkolemManager* sm = nm->getSkolemManager();
+  SkolemManager* sm = d_nm->getSkolemManager();
   SkolemId sfi = SkolemId::NONE;
   Node cacheVal;
   TypeNode tn = k.getType();
@@ -804,10 +802,10 @@ Node LfscNodeConverter::maybeMkSkolemFun(Node k, bool macroApply)
       // a skolem corresponding to a regular expression unfolding component
       // should print as (skolem_re_unfold_pos t R n) where the skolem is the
       // n^th component for the unfolding of (str.in_re t R).
-      TypeNode strType = nm->stringType();
-      TypeNode reType = nm->regExpType();
-      TypeNode intType = nm->integerType();
-      TypeNode reut = nm->mkFunctionType({strType, reType, intType}, strType);
+      TypeNode strType = d_nm->stringType();
+      TypeNode reType = d_nm->regExpType();
+      TypeNode intType = d_nm->integerType();
+      TypeNode reut = d_nm->mkFunctionType({strType, reType, intType}, strType);
       Node sk = getSymbolInternal(k.getKind(), reut, "skolem_re_unfold_pos");
       Assert(!cacheVal.isNull() && cacheVal.getKind() == Kind::SEXPR
              && cacheVal.getNumChildren() == 3);
@@ -833,8 +831,8 @@ Node LfscNodeConverter::mkInternalSymbol(const std::string& name,
                                          bool useRawSym)
 {
   // use raw symbol so that it is never quoted
-  NodeManager* nm = NodeManager::currentNM();
-  Node sym = useRawSym ? nm->mkRawSymbol(name, tn) : nm->mkBoundVar(name, tn);
+  Node sym =
+      useRawSym ? d_nm->mkRawSymbol(name, tn) : d_nm->mkBoundVar(name, tn);
   d_symbols.insert(sym);
   return sym;
 }
@@ -867,7 +865,6 @@ Node LfscNodeConverter::getSymbolInternal(Kind k,
 void LfscNodeConverter::getCharVectorInternal(Node c, std::vector<Node>& chars)
 {
   Assert(c.getKind() == Kind::CONST_STRING);
-  NodeManager* nm = NodeManager::currentNM();
   const std::vector<unsigned>& vec = c.getConst<String>().getVec();
   if (vec.size() == 0)
   {
@@ -875,20 +872,19 @@ void LfscNodeConverter::getCharVectorInternal(Node c, std::vector<Node>& chars)
     chars.push_back(ec);
     return;
   }
-  TypeNode tnc = nm->mkFunctionType(nm->integerType(), c.getType());
+  TypeNode tnc = d_nm->mkFunctionType(d_nm->integerType(), c.getType());
   Node aconstf = getSymbolInternal(Kind::CONST_STRING, tnc, "char");
   for (unsigned i = 0, size = vec.size(); i < size; i++)
   {
-    Node cc = mkApplyUf(aconstf, {nm->mkConstInt(Rational(vec[i]))});
+    Node cc = mkApplyUf(aconstf, {d_nm->mkConstInt(Rational(vec[i]))});
     chars.push_back(cc);
   }
 }
 
 Node LfscNodeConverter::convertBitVector(const BitVector& bv)
 {
-  NodeManager* nm = NodeManager::currentNM();
-  TypeNode btn = nm->booleanType();
-  TypeNode btnv = nm->mkFunctionType({btn, btn}, btn);
+  TypeNode btn = d_nm->booleanType();
+  TypeNode btnv = d_nm->mkFunctionType({btn, btn}, btn);
   size_t w = bv.getSize();
   Node ret = getSymbolInternal(Kind::CONST_BITVECTOR, btn, "bvn");
   Node b0 = getSymbolInternal(Kind::CONST_BITVECTOR, btn, "b0");
@@ -904,7 +900,6 @@ Node LfscNodeConverter::convertBitVector(const BitVector& bv)
 
 Node LfscNodeConverter::getNullTerminator(Kind k, TypeNode tn)
 {
-  NodeManager* nm = NodeManager::currentNM();
   Node nullTerm;
   switch (k)
   {
@@ -918,7 +913,7 @@ Node LfscNodeConverter::getNullTerminator(Kind k, TypeNode tn)
       // the null terminator of bitvector concat is a dummy variable of
       // bit-vector type with zero width, regardless of the type of the overall
       // concat.
-      TypeNode bvz = nm->mkBitVectorType(0);
+      TypeNode bvz = d_nm->mkBitVectorType(0);
       nullTerm = getSymbolInternal(k, bvz, "emptybv");
     }
     break;
@@ -948,7 +943,6 @@ Node LfscNodeConverter::getOperatorOfTerm(Node n, bool macroApply)
 {
   Assert(n.hasOperator());
   Assert(!n.isClosure());
-  NodeManager* nm = NodeManager::currentNM();
   Kind k = n.getKind();
   std::stringstream opName;
   Trace("lfsc-term-process-debug2")
@@ -967,7 +961,7 @@ Node LfscNodeConverter::getOperatorOfTerm(Node n, bool macroApply)
       {
         Assert(indices.size() == 1);
         // must convert to user name
-        TypeNode intType = nm->integerType();
+        TypeNode intType = d_nm->integerType();
         indices[0] =
             getSymbolInternal(k, intType, getNameForUserNameOf(indices[0]));
       }
@@ -985,7 +979,7 @@ Node LfscNodeConverter::getOperatorOfTerm(Node n, bool macroApply)
     TypeNode ftype = n.getType();
     if (!argTypes.empty())
     {
-      ftype = nm->mkFunctionType(argTypes, ftype);
+      ftype = d_nm->mkFunctionType(argTypes, ftype);
     }
     Node ret;
     if (GenericOp::isIndexedOperatorKind(k))
@@ -997,7 +991,7 @@ Node LfscNodeConverter::getOperatorOfTerm(Node n, bool macroApply)
       }
       if (!itypes.empty())
       {
-        ftype = nm->mkFunctionType(itypes, ftype);
+        ftype = d_nm->mkFunctionType(itypes, ftype);
       }
       if (!macroApply)
       {
@@ -1087,7 +1081,7 @@ Node LfscNodeConverter::getOperatorOfTerm(Node n, bool macroApply)
     argTypes.resize(2);
   }
   TypeNode tn = n.getType();
-  TypeNode ftype = nm->mkFunctionType(argTypes, tn);
+  TypeNode ftype = d_nm->mkFunctionType(argTypes, tn);
   // most functions are called f_X where X is the SMT-LIB name, if we are
   // getting the macroApply variant, then we don't prefix with `f_`.
   if (!macroApply)
@@ -1117,13 +1111,12 @@ Node LfscNodeConverter::getOperatorOfClosure(Node q,
                                              bool macroApply,
                                              bool isPartial)
 {
-  NodeManager* nm = NodeManager::currentNM();
   TypeNode retType = isPartial ? q[1].getType() : q.getType();
-  TypeNode bodyType = nm->mkFunctionType(q[1].getType(), retType);
+  TypeNode bodyType = d_nm->mkFunctionType(q[1].getType(), retType);
   // We permit non-flat function types here
   // intType is used here for variable indices
-  TypeNode intType = nm->integerType();
-  TypeNode ftype = nm->mkFunctionType({intType, d_sortType}, bodyType);
+  TypeNode intType = d_nm->integerType();
+  TypeNode ftype = d_nm->mkFunctionType({intType, d_sortType}, bodyType);
   Kind k = q.getKind();
   std::stringstream opName;
   if (!macroApply)
@@ -1136,8 +1129,7 @@ Node LfscNodeConverter::getOperatorOfClosure(Node q,
 
 Node LfscNodeConverter::getOperatorOfBoundVar(Node cop, Node v)
 {
-  NodeManager* nm = NodeManager::currentNM();
-  Node x = nm->mkConstInt(Rational(getOrAssignIndexForBVar(v)));
+  Node x = d_nm->mkConstInt(Rational(getOrAssignIndexForBVar(v)));
   Node tc = typeAsNode(convertType(v.getType()));
   return mkApplyUf(cop, {x, tc});
 }
diff --git a/src/proof/lfsc/lfsc_post_processor.cpp b/src/proof/lfsc/lfsc_post_processor.cpp
index 8b570e100..04139e053 100644
--- a/src/proof/lfsc/lfsc_post_processor.cpp
+++ b/src/proof/lfsc/lfsc_post_processor.cpp
@@ -59,7 +59,7 @@ bool LfscProofPostprocessCallback::update(Node res,
   Trace("lfsc-pp") << "LfscProofPostprocessCallback::update: " << id
                    << std::endl;
   Trace("lfsc-pp-debug") << "...proves " << res << std::endl;
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   Assert(id != ProofRule::LFSC_RULE);
 
   switch (id)
@@ -114,7 +114,7 @@ bool LfscProofPostprocessCallback::update(Node res,
         size_t ii = (nargs - 1) - i;
         // Use a dummy conclusion for what LAMBDA proves, since there is no
         // FOL representation for its type.
-        Node fconc = mkDummyPredicate();
+        Node fconc = mkDummyPredicate(nm);
         addLfscRule(cdp, fconc, {curr}, LfscRule::LAMBDA, {args[ii]});
         // we use a chained implication (=> F1 ... (=> Fn C)) which avoids
         // aliasing.
@@ -478,7 +478,7 @@ void LfscProofPostprocessCallback::updateCong(Node res,
   }
   Node curL = currEq[0];
   Node curR = currEq[1];
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   for (; i < nchildren; i++)
   {
     // CONG rules for each child
@@ -507,7 +507,7 @@ void LfscProofPostprocessCallback::addLfscRule(
     const std::vector<Node>& args)
 {
   std::vector<Node> largs;
-  largs.push_back(mkLfscRuleNode(lr));
+  largs.push_back(mkLfscRuleNode(nodeManager(), lr));
   largs.push_back(conc);
   largs.insert(largs.end(), args.begin(), args.end());
   cdp->addStep(conc, ProofRule::LFSC_RULE, children, largs);
@@ -517,7 +517,7 @@ Node LfscProofPostprocessCallback::mkChain(Kind k,
                                            const std::vector<Node>& children)
 {
   Assert(!children.empty());
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   size_t nchildren = children.size();
   size_t i = 0;
   // do we have a null terminator? If so, we start with it.
@@ -535,9 +535,8 @@ Node LfscProofPostprocessCallback::mkChain(Kind k,
   return ret;
 }
 
-Node LfscProofPostprocessCallback::mkDummyPredicate()
+Node LfscProofPostprocessCallback::mkDummyPredicate(NodeManager* nm)
 {
-  NodeManager* nm = NodeManager::currentNM();
   return nm->mkBoundVar(nm->booleanType());
 }
 
diff --git a/src/proof/lfsc/lfsc_post_processor.h b/src/proof/lfsc/lfsc_post_processor.h
index 7e913fc49..e68851fb0 100644
--- a/src/proof/lfsc/lfsc_post_processor.h
+++ b/src/proof/lfsc/lfsc_post_processor.h
@@ -89,7 +89,7 @@ class LfscProofPostprocessCallback : protected EnvObj,
                   CDProof* cdp,
                   Node startOp);
   /** Make fresh dummy predicate */
-  static Node mkDummyPredicate();
+  static Node mkDummyPredicate(NodeManager* nm);
 };
 
 /**
diff --git a/src/proof/lfsc/lfsc_util.cpp b/src/proof/lfsc/lfsc_util.cpp
index 2fbc91126..643ceae13 100644
--- a/src/proof/lfsc/lfsc_util.cpp
+++ b/src/proof/lfsc/lfsc_util.cpp
@@ -69,10 +69,9 @@ LfscRule getLfscRule(Node n)
   return lr;
 }
 
-Node mkLfscRuleNode(LfscRule r)
+Node mkLfscRuleNode(NodeManager* nm, LfscRule r)
 {
-  return NodeManager::currentNM()->mkConstInt(
-      Rational(static_cast<uint32_t>(r)));
+  return nm->mkConstInt(Rational(static_cast<uint32_t>(r)));
 }
 
 bool LfscProofLetifyTraverseCallback::shouldTraverse(const ProofNode* pn)
diff --git a/src/proof/lfsc/lfsc_util.h b/src/proof/lfsc/lfsc_util.h
index 4f4109518..3808953bc 100644
--- a/src/proof/lfsc/lfsc_util.h
+++ b/src/proof/lfsc/lfsc_util.h
@@ -96,7 +96,7 @@ LfscRule getLfscRule(Node n);
 /** Get LFSC rule from a node, return true if success and store in lr */
 bool getLfscRule(Node n, LfscRule& lr);
 /** Make node for LFSC rule */
-Node mkLfscRuleNode(LfscRule r);
+Node mkLfscRuleNode(NodeManager* nm, LfscRule r);
 
 /** Helper class used for letifying LFSC proofs. */
 class LfscProofLetifyTraverseCallback : public ProofLetifyTraverseCallback
-- 
2.47.1

