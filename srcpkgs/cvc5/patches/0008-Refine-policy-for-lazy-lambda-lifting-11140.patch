From 7e1b0dffe4553aa260b3050ae620ab4617fb82db Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Fri, 9 Aug 2024 16:10:34 -0500
Subject: [PATCH 008/312] Refine policy for lazy lambda lifting (#11140)

Certain lambdas may need to be lifted based on the symbols in their
body. In particular, a lambda like `(lambda ((x Int)) (+ 1 (f x))` may
need to be lifted since its body contains a free symbol `f`. In
particular equating `f` to this lambda leads to unsat, which we do via
lambda lifting.

This refines this policy so that the only lift such lambdas if they
become equal to other function symbols; otherwise their model value is
not relevant.

This also makes some minor fixes to the core model to ensure that lambda
values are fully reduced in models.
---
 src/theory/inference_id.cpp                   |  1 +
 src/theory/inference_id.h                     |  2 +
 src/theory/theory_engine.cpp                  |  4 +-
 src/theory/theory_model_builder.cpp           | 11 ++-
 src/theory/uf/ho_extension.cpp                | 33 +++++++
 src/theory/uf/lambda_lift.cpp                 | 85 ++++++++++++-------
 src/theory/uf/lambda_lift.h                   |  7 ++
 test/regress/cli/CMakeLists.txt               |  2 +
 .../cli/regress0/ho/model-dep-arg.smt2        |  9 ++
 .../regress1/sets/filter-no-lift-red_2.smt2   |  8 ++
 10 files changed, 126 insertions(+), 36 deletions(-)
 create mode 100644 test/regress/cli/regress0/ho/model-dep-arg.smt2
 create mode 100644 test/regress/cli/regress1/sets/filter-no-lift-red_2.smt2

diff --git a/src/theory/inference_id.cpp b/src/theory/inference_id.cpp
index ac1740523..f17e8fdb4 100644
--- a/src/theory/inference_id.cpp
+++ b/src/theory/inference_id.cpp
@@ -558,6 +558,7 @@ const char* toString(InferenceId i)
       return "UF_HO_MODEL_EXTENSIONALITY";
     case InferenceId::UF_HO_LAMBDA_UNIV_EQ: return "HO_LAMBDA_UNIV_EQ";
     case InferenceId::UF_HO_LAMBDA_APP_REDUCE: return "HO_LAMBDA_APP_REDUCE";
+    case InferenceId::UF_HO_LAMBDA_LAZY_LIFT: return "UF_HO_LAMBDA_LAZY_LIFT";
     case InferenceId::UF_ARITH_BV_CONV_REDUCTION:
       return "UF_ARITH_BV_CONV_REDUCTION";
     case InferenceId::UF_ARITH_BV_CONV_VALUE_REFINE:
diff --git a/src/theory/inference_id.h b/src/theory/inference_id.h
index afefcf36b..dbd2e36f0 100644
--- a/src/theory/inference_id.h
+++ b/src/theory/inference_id.h
@@ -969,6 +969,8 @@ enum class InferenceId
   // This is applied when lamda function f and ordinary function h are in the
   // same eq class.
   UF_HO_LAMBDA_APP_REDUCE,
+  // Lazy lambda lifting
+  UF_HO_LAMBDA_LAZY_LIFT,
   //-------------------- end model-construction specific part
   //-------------------- end HO extension to UF
   //-------------------- UF arith/bv conversions solver
diff --git a/src/theory/theory_engine.cpp b/src/theory/theory_engine.cpp
index f68c2b276..33b9e1d4a 100644
--- a/src/theory/theory_engine.cpp
+++ b/src/theory/theory_engine.cpp
@@ -1513,7 +1513,9 @@ void TheoryEngine::lemma(TrustNode tlemma,
   Node node = tlemma.getNode();
   Node lemma = tlemma.getProven();
 
-  Assert(!expr::hasFreeVar(lemma))
+  // must rewrite when checking here since we may have shadowing in rare cases,
+  // e.g. lazy lambda lifting lemmas
+  Assert(!expr::hasFreeVar(rewrite(lemma)))
       << "Lemma " << lemma << " from " << from << " has a free variable";
 
   // when proofs are enabled, we ensure the trust node has a generator by
diff --git a/src/theory/theory_model_builder.cpp b/src/theory/theory_model_builder.cpp
index bb02d9840..e36b31b41 100644
--- a/src/theory/theory_model_builder.cpp
+++ b/src/theory/theory_model_builder.cpp
@@ -1214,7 +1214,13 @@ Node TheoryEngineModelBuilder::normalize(TheoryModel* m, TNode r, bool evalOnly)
   std::map<Node, Node>::iterator itMap = d_constantReps.find(r);
   if (itMap != d_constantReps.end())
   {
-    return (*itMap).second;
+    r = (*itMap).second;
+    // if d_constantReps stores a constant, we are done, otherwise we process
+    // it below.
+    if (r.isConst())
+    {
+      return r;
+    }
   }
   NodeMap::iterator it = d_normalizedCache.find(r);
   if (it != d_normalizedCache.end())
@@ -1244,7 +1250,8 @@ Node TheoryEngineModelBuilder::normalize(TheoryModel* m, TNode r, bool evalOnly)
           {
             ri = (*itMap).second;
             Trace("model-builder-debug") << i << ": const child " << ri << std::endl;
-            recurse = false;
+            // need to recurse if d_constantReps stores a non-constant
+            recurse = !ri.isConst();
           }
           else if (!evalOnly)
           {
diff --git a/src/theory/uf/ho_extension.cpp b/src/theory/uf/ho_extension.cpp
index dd1619e6c..fcdb43863 100644
--- a/src/theory/uf/ho_extension.cpp
+++ b/src/theory/uf/ho_extension.cpp
@@ -104,6 +104,24 @@ TrustNode HoExtension::ppRewrite(Node node, std::vector<SkolemLemma>& lems)
             << "Beta reduce: " << node << " -> " << app << std::endl;
         return TrustNode::mkTrustRewrite(node, app, nullptr);
       }
+      // If an unlifted lambda occurs in an argument to APPLY_UF, it must be
+      // lifted. We do this only if the lambda needs lifting, i.e. it is one
+      // that may induce circular model dependencies.
+      for (const Node& nc : node)
+      {
+        if (nc.getType().isFunction())
+        {
+          Node lam = d_ll.getLambdaFor(nc);
+          if (!lam.isNull() && d_ll.needsLift(lam))
+          {
+            TrustNode trn = d_ll.lift(lam);
+            if (!trn.isNull())
+            {
+              lems.push_back(SkolemLemma(trn, nc));
+            }
+          }
+        }
+      }
     }
   }
   else if (k == Kind::LAMBDA || k == Kind::FUNCTION_ARRAY_CONST)
@@ -531,6 +549,8 @@ unsigned HoExtension::checkLazyLambda()
     eq::EqClassIterator eqc_i = eq::EqClassIterator(eqc, ee);
     Node lamRep;  // the first lambda function we encounter in the equivalence
                   // class
+    bool needsLift = false;
+    bool doLift = false;
     Node lamRepLam;
     std::unordered_set<Node> normalEqFunWait;
     while (!eqc_i.isFinished())
@@ -545,6 +565,7 @@ unsigned HoExtension::checkLazyLambda()
           // if we are equal to a lambda function, we must beta-reduce
           // applications of this
           normalEqFuns.insert(n);
+          doLift = needsLift;
         }
         else
         {
@@ -558,6 +579,8 @@ unsigned HoExtension::checkLazyLambda()
         // there is a lambda function in this equivalence class
         lamRep = n;
         lamRepLam = lam;
+        needsLift = d_ll.needsLift(lam) && !d_ll.isLifted(lam);
+        doLift = needsLift && !normalEqFunWait.empty();
         // must consider all normal functions we've seen so far
         normalEqFuns.insert(normalEqFunWait.begin(), normalEqFunWait.end());
         normalEqFunWait.clear();
@@ -638,6 +661,16 @@ unsigned HoExtension::checkLazyLambda()
     if (!lamRep.isNull())
     {
       d_lambdaEqc[eqc] = lamRep;
+      // Do the lambda lifting lemma if needed. This happens if a lambda
+      // needs lifting based on the symbols in its body and is equated to an
+      // ordinary function symbol. For example, this is what ensures we
+      // handle conflicts like f = (lambda ((x Int)) (+ 1 (f x))).
+      if (doLift)
+      {
+        TrustNode tlift = d_ll.lift(lamRepLam);
+        Assert(!tlift.isNull());
+        d_im.trustedLemma(tlift, InferenceId::UF_HO_LAMBDA_LAZY_LIFT);
+      }
     }
   }
   Trace("uf-ho-debug")
diff --git a/src/theory/uf/lambda_lift.cpp b/src/theory/uf/lambda_lift.cpp
index bc7cc75b7..74817a04e 100644
--- a/src/theory/uf/lambda_lift.cpp
+++ b/src/theory/uf/lambda_lift.cpp
@@ -59,6 +59,55 @@ TrustNode LambdaLift::lift(Node node)
       assertion, ProofRule::MACRO_SR_PRED_INTRO, {}, {assertion});
 }
 
+bool LambdaLift::needsLift(const Node& lam)
+{
+  Assert(lam.getKind() == Kind::LAMBDA);
+  std::map<Node, bool>::iterator it = d_needsLift.find(lam);
+  if (it != d_needsLift.end())
+  {
+    return it->second;
+  }
+  // Model construction considers types in order of their type size
+  // (SortTypeSize::getTypeSize). If the lambda has a free variable, that
+  // comes later in the model construction, it may need to be lifted eagerly.
+  // As an example, say f : Int -> Int, g : Int x Int -> Int
+  // The following lambdas require eager lifting:
+  // - (lambda ((x Int)) (g x x))
+  // - (lambda ((x Int) (y Int)) (f (g x y)))
+  // The following lambads do not require eager lifting:
+  // - (lambda ((x Int)) (+ x 1)), since it has no free symbols.
+  // - (lambda ((x Int) (y Int)) (f x)), since its free symbol f has a type
+  // Int -> Int which is processed before the type of the lambda, i.e.
+  // Int x Int -> Int.
+  // Note that we only eagerly lift lambdas that furthermore impact model
+  // construction, which is only the case if the lambda occurs as an argument
+  // to a APPLY_UF or is equated to another function symbol.
+  bool shouldLift = false;
+  std::unordered_set<Node> syms;
+  expr::getSymbols(lam[1], syms);
+  SortTypeSize sts;
+  size_t lsize = sts.getTypeSize(lam.getType());
+  Trace("uf-lazy-ll") << "Lift " << lam << "?" << std::endl;
+  for (const Node& v : syms)
+  {
+    TypeNode tn = v.getType();
+    if (!tn.isFirstClass())
+    {
+      // don't need to worry about constructor/selector/testers/etc.
+      continue;
+    }
+    size_t vsize = sts.getTypeSize(tn);
+    if (vsize >= lsize)
+    {
+      shouldLift = true;
+      Trace("uf-lazy-ll") << "...yes due to " << v << std::endl;
+      break;
+    }
+  }
+  d_needsLift[lam] = shouldLift;
+  return shouldLift;
+}
+
 bool LambdaLift::isLifted(const Node& node) const
 {
   return d_lifted.find(node)!=d_lifted.end();
@@ -76,40 +125,10 @@ TrustNode LambdaLift::ppRewrite(Node node, std::vector<SkolemLemma>& lems)
   bool shouldLift = true;
   if (options().uf.ufHoLazyLambdaLift)
   {
-    Trace("uf-lazy-ll") << "Lift " << lam << "?" << std::endl;
+    // We never lift eagerly. Lambdas that may induce inconsistencies based
+    // on the symbols in their bodies are lifted lazily if/when they become
+    // equal to ordinary function symbols. This is handled in the ho extension.
     shouldLift = false;
-    // Model construction considers types in order of their type size
-    // (SortTypeSize::getTypeSize). If the lambda has a free variable, that
-    // comes later in the model construction, it must be lifted eagerly.
-    // As an example, say f : Int -> Int, g : Int x Int -> Int
-    // The following lambdas require eager lifting:
-    // - (lambda ((x Int)) (g x x))
-    // - (lambda ((x Int) (y Int)) (f (g x y)))
-    // The following lambads do not require eager lifting:
-    // - (lambda ((x Int)) (+ x 1)), since it has no free symbols.
-    // - (lambda ((x Int) (y Int)) (f x)), since its free symbol f has a type
-    // Int -> Int which is processed before the type of the lambda, i.e.
-    // Int x Int -> Int.
-    std::unordered_set<Node> syms;
-    expr::getSymbols(lam[1], syms);
-    SortTypeSize sts;
-    size_t lsize = sts.getTypeSize(lam.getType());
-    for (const Node& v : syms)
-    {
-      TypeNode tn = v.getType();
-      if (!tn.isFirstClass())
-      {
-        // don't need to worry about constructor/selector/testers/etc.
-        continue;
-      }
-      size_t vsize = sts.getTypeSize(tn);
-      if (vsize>=lsize)
-      {
-        shouldLift = true;
-        Trace("uf-lazy-ll") << "...yes due to " << v << std::endl;
-        break;
-      }
-    }
   }
   if (shouldLift)
   {
diff --git a/src/theory/uf/lambda_lift.h b/src/theory/uf/lambda_lift.h
index eab9a8e2d..b6110d9bd 100644
--- a/src/theory/uf/lambda_lift.h
+++ b/src/theory/uf/lambda_lift.h
@@ -50,6 +50,11 @@ class LambdaLift : protected EnvObj
    * the lambda lifting lemma has already been generated in this context.
    */
   TrustNode lift(Node node);
+  /**
+   * Do we need to lift the given lambda? This is true if the body of the
+   * lambda may induce circular dependencies in model construction.
+   */
+  bool needsLift(const Node& lam);
   /** Have we lifted node? */
   bool isLifted(const Node& node) const;
 
@@ -92,6 +97,8 @@ class LambdaLift : protected EnvObj
   NodeNodeMap d_lambdaMap;
   /** An eager proof generator */
   std::unique_ptr<EagerProofGenerator> d_epg;
+  /** A cache for needs lift */
+  std::map<Node, bool> d_needsLift;
 };
 
 }  // namespace uf
diff --git a/test/regress/cli/CMakeLists.txt b/test/regress/cli/CMakeLists.txt
index d60bd1eea..f1d53f08c 100644
--- a/test/regress/cli/CMakeLists.txt
+++ b/test/regress/cli/CMakeLists.txt
@@ -939,6 +939,7 @@ set(regress_0_tests
   regress0/ho/m-enum-bug2.smt2 
   regress0/ho/m-enum-bug3.smt2 
   regress0/ho/match-middle.smt2
+  regress0/ho/model-dep-arg.smt2
   regress0/ho/model-lam-simple.smt2
   regress0/ho/modulo-func-equality.smt2
   regress0/ho/qgu-fuzz-ho-1-dd.smt2
@@ -3000,6 +3001,7 @@ set(regress_1_tests
   regress1/sets/comp-pos-member.smt2
   regress1/sets/copy_check_heap_access_33_4.smt2
   regress1/sets/deepmeas0.hs.fqout.cvc4.41.smt2
+  regress1/sets/filter-no-lift-red_2.smt2
   regress1/sets/finite-type/bug3663.smt2
   regress1/sets/finite-type/sets-card-arrcolor.smt2
   regress1/sets/finite-type/sets-card-arrunit.smt2
diff --git a/test/regress/cli/regress0/ho/model-dep-arg.smt2 b/test/regress/cli/regress0/ho/model-dep-arg.smt2
new file mode 100644
index 000000000..5df091238
--- /dev/null
+++ b/test/regress/cli/regress0/ho/model-dep-arg.smt2
@@ -0,0 +1,9 @@
+; COMMAND-LINE: --simplification=none
+; EXPECT: unsat
+(set-logic HO_ALL)
+(declare-fun f ((-> Int Int)) Int)
+(declare-fun g (Int) Int)
+(declare-fun h (Int) Int)
+(assert (not (= (f (lambda ((x Int)) (+ 1 (f g)))) (f (lambda ((x Int)) (+ 1 (f h)))))))
+(assert (= g h))
+(check-sat)
diff --git a/test/regress/cli/regress1/sets/filter-no-lift-red_2.smt2 b/test/regress/cli/regress1/sets/filter-no-lift-red_2.smt2
new file mode 100644
index 000000000..d8917ee46
--- /dev/null
+++ b/test/regress/cli/regress1/sets/filter-no-lift-red_2.smt2
@@ -0,0 +1,8 @@
+; EXPECT: sat
+(set-logic HO_ALL)
+(declare-const x Bool)
+(declare-const r (Set (Tuple Int)))
+(declare-const M (Set (Tuple Int Bool Int Bool Int)))
+(assert (distinct (as set.empty (Set (Tuple Int))) (set.filter (lambda ((tuple_36 (Tuple Int))) true) r)))
+(assert (= (as set.empty (Set (Tuple Int))) (set.filter (lambda ((tuple_1 (Tuple Int))) (= (as set.empty (Set (Tuple Int Bool Int Bool Int))) (set.filter (lambda ((tuple_2 (Tuple Int Bool Int Bool Int))) x) M))) r)))
+(check-sat)
-- 
2.47.1

