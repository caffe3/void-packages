From f50a593836789d0937fc7edc8233075da7adb3fe Mon Sep 17 00:00:00 2001
From: Daniel Larraz <daniel-larraz@users.noreply.github.com>
Date: Fri, 4 Oct 2024 11:03:10 -0500
Subject: [PATCH 108/312] preprocessing: Refactor to not use
 NodeManager::currentNM() (#11250)

Co-authored-by: Aina Niemetz <aina.niemetz@gmail.com>
---
 src/preprocessing/passes/ackermann.cpp        | 27 ++++++++++++-------
 src/preprocessing/passes/ff_bitsum.cpp        |  9 +++----
 src/preprocessing/passes/int_to_bv.cpp        |  8 +++---
 src/preprocessing/passes/ite_simp.cpp         |  3 +--
 .../passes/pseudo_boolean_processor.cpp       | 20 +++++++-------
 .../passes/pseudo_boolean_processor.h         |  2 +-
 src/preprocessing/passes/sep_skolem_emp.cpp   |  9 ++++---
 src/preprocessing/util/ite_utilities.cpp      | 26 +++++++++---------
 src/preprocessing/util/ite_utilities.h        |  2 +-
 9 files changed, 55 insertions(+), 51 deletions(-)

diff --git a/src/preprocessing/passes/ackermann.cpp b/src/preprocessing/passes/ackermann.cpp
index df46d3ad5..7e6ac4874 100644
--- a/src/preprocessing/passes/ackermann.cpp
+++ b/src/preprocessing/passes/ackermann.cpp
@@ -145,13 +145,13 @@ void storeFunctionAndAddLemmas(TNode func,
  * storeFunctionAndAddLemmas will then add the constraint g(x)=g(y) ->
  * f(g(x))=f(g(y)).
  * Now that we see g(x) and g(y), we explicitly add them as well. */
-void collectFunctionsAndLemmas(FunctionToArgsMap& fun_to_args,
+void collectFunctionsAndLemmas(NodeManager* nm,
+                               FunctionToArgsMap& fun_to_args,
                                SubstitutionMap& fun_to_skolem,
                                std::vector<TNode>* vec,
                                AssertionPipeline* assertions)
 {
   TNodeSet seen;
-  NodeManager* nm = NodeManager::currentNM();
   TNode term;
   while (!vec->empty())
   {
@@ -203,11 +203,11 @@ size_t getBVSkolemSize(size_t capacity)
  * a sufficient bit-vector size.
  * Populate usVarsToBVVars so that it maps variables with uninterpreted sort to
  * the fresh skolem BV variables. variables */
-void collectUSortsToBV(const std::unordered_set<TNode>& vars,
+void collectUSortsToBV(NodeManager* nm,
+                       const std::unordered_set<TNode>& vars,
                        const USortToBVSizeMap& usortCardinality,
                        SubstitutionMap& usVarsToBVVars)
 {
-  NodeManager* nm = NodeManager::currentNM();
   SkolemManager* sm = nm->getSkolemManager();
 
   for (TNode var : vars)
@@ -253,7 +253,8 @@ std::unordered_set<TNode> getVarsWithUSorts(AssertionPipeline* assertions)
  * size. The size is calculated to have enough capacity, that can accommodate
  * the variables occured in the original formula. At the end, all variables of
  * uninterpreted sorts will be converted into Skolem variables of BV */
-void usortsToBitVectors(const LogicInfo& d_logic,
+void usortsToBitVectors(NodeManager* nm,
+                        const LogicInfo& d_logic,
                         AssertionPipeline* assertions,
                         USortToBVSizeMap& usortCardinality,
                         SubstitutionMap& usVarsToBVVars)
@@ -277,7 +278,7 @@ void usortsToBitVectors(const LogicInfo& d_logic,
       usortCardinality[type] = usortCardinality[type] + 1;
     }
 
-    collectUSortsToBV(toProcess, usortCardinality, usVarsToBVVars);
+    collectUSortsToBV(nm, toProcess, usortCardinality, usVarsToBVVars);
 
     for (size_t i = 0, size = assertions->size(); i < size; ++i)
     {
@@ -315,8 +316,11 @@ PreprocessingPassResult Ackermann::applyInternal(
   {
     to_process.push_back(a);
   }
-  collectFunctionsAndLemmas(
-      d_funcToArgs, d_funcToSkolem, &to_process, assertionsToPreprocess);
+  collectFunctionsAndLemmas(nodeManager(),
+                            d_funcToArgs,
+                            d_funcToSkolem,
+                            &to_process,
+                            assertionsToPreprocess);
 
   /* replace applications of UF by skolems */
   // FIXME for model building, github issue #1901
@@ -327,8 +331,11 @@ PreprocessingPassResult Ackermann::applyInternal(
   }
 
   /* replace uninterpreted sorts with bit-vectors */
-  usortsToBitVectors(
-      d_logic, assertionsToPreprocess, d_usortCardinality, d_usVarsToBVVars);
+  usortsToBitVectors(nodeManager(),
+                     d_logic,
+                     assertionsToPreprocess,
+                     d_usortCardinality,
+                     d_usVarsToBVVars);
 
   return PreprocessingPassResult::NO_CONFLICT;
 }
diff --git a/src/preprocessing/passes/ff_bitsum.cpp b/src/preprocessing/passes/ff_bitsum.cpp
index 60163f1f2..8ce746718 100644
--- a/src/preprocessing/passes/ff_bitsum.cpp
+++ b/src/preprocessing/passes/ff_bitsum.cpp
@@ -35,12 +35,11 @@ FfBitsum::FfBitsum(PreprocessingPassContext* preprocContext)
 {
 }
 
-Node mkAdd(const std::vector<Node>& children)
+Node mkAdd(NodeManager* nm, const std::vector<Node>& children)
 {
   Assert(children.size() > 0);
   return children.size() == 1 ? children[0]
-                              : NodeManager::currentNM()->mkNode(
-                                  Kind::FINITE_FIELD_ADD, children);
+                              : nm->mkNode(Kind::FINITE_FIELD_ADD, children);
 }
 
 PreprocessingPassResult FfBitsum::applyInternal(
@@ -67,7 +66,7 @@ PreprocessingPassResult FfBitsum::applyInternal(
   }
 
   // collect bitsums
-  auto nm = NodeManager::currentNM();
+  auto nm = nodeManager();
   std::unordered_map<Node, Node> cache{};
   for (uint64_t i = 0, n = assertionsToPreprocess->size(); i < n; ++i)
   {
@@ -113,7 +112,7 @@ PreprocessingPassResult FfBitsum::applyInternal(
               Trace("ff::bitsum") << "found " << scaled << std::endl;
               bs->second.push_back(scaled);
             }
-            translation = mkAdd(std::move(bs->second));
+            translation = mkAdd(nm, std::move(bs->second));
           }
         }
       }
diff --git a/src/preprocessing/passes/int_to_bv.cpp b/src/preprocessing/passes/int_to_bv.cpp
index d1ec15ddb..1350df0ac 100644
--- a/src/preprocessing/passes/int_to_bv.cpp
+++ b/src/preprocessing/passes/int_to_bv.cpp
@@ -58,14 +58,12 @@ bool childrenTypesChanged(Node n, NodeMap& cache) {
   return false;
 }
 
-
-Node intToBVMakeBinary(TNode n, NodeMap& cache)
+Node intToBVMakeBinary(NodeManager* nm, TNode n, NodeMap& cache)
 {
   for (TNode current : NodeDfsIterable(n, VisitOrder::POSTORDER,
            [&cache](TNode nn) { return cache.count(nn) > 0; }))
   {
     Node result;
-    NodeManager* nm = NodeManager::currentNM();
     if (current.getNumChildren() == 0)
     {
       result = current;
@@ -112,10 +110,10 @@ Node IntToBV::intToBV(TNode n, NodeMap& cache)
   AlwaysAssert(size > 0);
   AlwaysAssert(!options().base.incrementalSolving);
 
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   SkolemManager* sm = nm->getSkolemManager();
   NodeMap binaryCache;
-  Node n_binary = intToBVMakeBinary(n, binaryCache);
+  Node n_binary = intToBVMakeBinary(nm, n, binaryCache);
 
   for (TNode current : NodeDfsIterable(n_binary, VisitOrder::POSTORDER,
            [&cache](TNode nn) { return cache.count(nn) > 0; }))
diff --git a/src/preprocessing/passes/ite_simp.cpp b/src/preprocessing/passes/ite_simp.cpp
index a38b9648e..205ea69af 100644
--- a/src/preprocessing/passes/ite_simp.cpp
+++ b/src/preprocessing/passes/ite_simp.cpp
@@ -32,9 +32,8 @@ namespace cvc5::internal {
 namespace preprocessing {
 namespace passes {
 
-Node mkAssocAnd(const std::vector<Node>& children)
+Node mkAssocAnd(NodeManager* nm, const std::vector<Node>& children)
 {
-  NodeManager* nm = NodeManager::currentNM();
   if (children.size() == 0)
   {
     return nm->mkConst(true);
diff --git a/src/preprocessing/passes/pseudo_boolean_processor.cpp b/src/preprocessing/passes/pseudo_boolean_processor.cpp
index ac6f8f3c4..6e2ccd265 100644
--- a/src/preprocessing/passes/pseudo_boolean_processor.cpp
+++ b/src/preprocessing/passes/pseudo_boolean_processor.cpp
@@ -298,9 +298,8 @@ void PseudoBooleanProcessor::learn(Node assertion)
   }
 }
 
-Node PseudoBooleanProcessor::mkGeqOne(Node v)
+Node PseudoBooleanProcessor::mkGeqOne(NodeManager* nm, Node v)
 {
-  NodeManager* nm = NodeManager::currentNM();
   return nm->mkNode(
       Kind::GEQ, v, nm->mkConstRealOrInt(v.getType(), Rational(1)));
 }
@@ -340,6 +339,8 @@ void PseudoBooleanProcessor::learnGeqSub(Node geq)
 
   // \sum pos >= \sum neg + off
 
+  NodeManager* nm = nodeManager();
+
   // for now special case everything we want
   // target easy clauses
   if (d_pos.size() == 1 && d_neg.size() == 1 && off.isZero())
@@ -349,8 +350,8 @@ void PseudoBooleanProcessor::learnGeqSub(Node geq)
     Node x = d_pos.front();
     Node y = d_neg.front();
 
-    Node xGeq1 = mkGeqOne(x);
-    Node yGeq1 = mkGeqOne(y);
+    Node xGeq1 = mkGeqOne(nm, x);
+    Node yGeq1 = mkGeqOne(nm, y);
     Node imp = yGeq1.impNode(xGeq1);
     addSub(geq, imp);
   }
@@ -362,8 +363,8 @@ void PseudoBooleanProcessor::learnGeqSub(Node geq)
     Node x = d_neg[0];
     Node y = d_neg[1];
 
-    Node xGeq1 = mkGeqOne(x);
-    Node yGeq1 = mkGeqOne(y);
+    Node xGeq1 = mkGeqOne(nm, x);
+    Node yGeq1 = mkGeqOne(nm, y);
     Node cases = (xGeq1.notNode()).orNode(yGeq1.notNode());
     addSub(geq, cases);
   }
@@ -375,10 +376,9 @@ void PseudoBooleanProcessor::learnGeqSub(Node geq)
     Node y = d_pos[1];
     Node z = d_neg[0];
 
-    Node xGeq1 = mkGeqOne(x);
-    Node yGeq1 = mkGeqOne(y);
-    Node zGeq1 = mkGeqOne(z);
-    NodeManager* nm = NodeManager::currentNM();
+    Node xGeq1 = mkGeqOne(nm, x);
+    Node yGeq1 = mkGeqOne(nm, y);
+    Node zGeq1 = mkGeqOne(nm, z);
     Node dis = nm->mkNode(Kind::OR, zGeq1.notNode(), xGeq1, yGeq1);
     addSub(geq, dis);
   }
diff --git a/src/preprocessing/passes/pseudo_boolean_processor.h b/src/preprocessing/passes/pseudo_boolean_processor.h
index 35cc05dd0..4febff54a 100644
--- a/src/preprocessing/passes/pseudo_boolean_processor.h
+++ b/src/preprocessing/passes/pseudo_boolean_processor.h
@@ -87,7 +87,7 @@ class PseudoBooleanProcessor : public PreprocessingPass
   void addSub(Node from, Node to);
   void learnGeqSub(Node geq);
 
-  static Node mkGeqOne(Node v);
+  static Node mkGeqOne(NodeManager* nm, Node v);
 
   // x ->  <geqZero, leqOne>
   typedef context::CDHashMap<Node, std::pair<Node, Node>> CDNode2PairMap;
diff --git a/src/preprocessing/passes/sep_skolem_emp.cpp b/src/preprocessing/passes/sep_skolem_emp.cpp
index d0b99e092..20bbd60b1 100644
--- a/src/preprocessing/passes/sep_skolem_emp.cpp
+++ b/src/preprocessing/passes/sep_skolem_emp.cpp
@@ -37,7 +37,8 @@ using namespace cvc5::internal::theory;
 
 namespace {
 
-Node preSkolemEmp(TypeNode locType,
+Node preSkolemEmp(NodeManager* nm,
+                  TypeNode locType,
                   TypeNode dataType,
                   Node n,
                   bool pol,
@@ -46,7 +47,6 @@ Node preSkolemEmp(TypeNode locType,
   std::map<Node, Node>::iterator it = visited[pol].find(n);
   if (it == visited[pol].end())
   {
-    NodeManager* nm = NodeManager::currentNM();
     SkolemManager* sm = nm->getSkolemManager();
     Trace("sep-preprocess") << "Pre-skolem emp " << n << " with pol " << pol
                             << std::endl;
@@ -81,7 +81,7 @@ Node preSkolemEmp(TypeNode locType,
         Node nc = n[i];
         if (newHasPol)
         {
-          nc = preSkolemEmp(locType, dataType, n[i], newPol, visited);
+          nc = preSkolemEmp(nm, locType, dataType, n[i], newPol, visited);
           childChanged = childChanged || nc != n[i];
         }
         children.push_back(nc);
@@ -122,7 +122,8 @@ PreprocessingPassResult SepSkolemEmp::applyInternal(
   {
     Node prev = (*assertionsToPreprocess)[i];
     bool pol = true;
-    Node next = preSkolemEmp(locType, dataType, prev, pol, visited);
+    Node next =
+        preSkolemEmp(nodeManager(), locType, dataType, prev, pol, visited);
     if (next != prev)
     {
       assertionsToPreprocess->replace(i, rewrite(next));
diff --git a/src/preprocessing/util/ite_utilities.cpp b/src/preprocessing/util/ite_utilities.cpp
index 269ff65c3..22776ffe4 100644
--- a/src/preprocessing/util/ite_utilities.cpp
+++ b/src/preprocessing/util/ite_utilities.cpp
@@ -146,7 +146,7 @@ Node ITEUtilities::simplifyWithCare(TNode e)
 {
   if (d_careSimp == NULL)
   {
-    d_careSimp = new ITECareSimplifier();
+    d_careSimp = new ITECareSimplifier(nodeManager());
   }
   return d_careSimp->simplifyWithCare(e);
 }
@@ -296,8 +296,8 @@ ITECompressor::ITECompressor(Env& env, ContainsTermITEVisitor* contains)
 {
   Assert(d_contains != NULL);
 
-  d_true = NodeManager::currentNM()->mkConst<bool>(true);
-  d_false = NodeManager::currentNM()->mkConst<bool>(false);
+  d_true = nodeManager()->mkConst<bool>(true);
+  d_false = nodeManager()->mkConst<bool>(false);
 }
 
 ITECompressor::~ITECompressor() { reset(); }
@@ -345,7 +345,7 @@ Node ITECompressor::push_back_boolean(Node original, Node compressed)
   }
   else
   {
-    NodeManager* nm = NodeManager::currentNM();
+    NodeManager* nm = nodeManager();
     SkolemManager* sm = nm->getSkolemManager();
     Node skolem = sm->mkDummySkolem("compress", nm->booleanType());
     d_compressed[rewritten] = skolem;
@@ -654,8 +654,8 @@ ITESimplifier::ITESimplifier(Env& env, ContainsTermITEVisitor* contains)
       d_statistics(env.getStatisticsRegistry())
 {
   Assert(d_containsVisitor != NULL);
-  d_true = NodeManager::currentNM()->mkConst<bool>(true);
-  d_false = NodeManager::currentNM()->mkConst<bool>(false);
+  d_true = nodeManager()->mkConst<bool>(true);
+  d_false = nodeManager()->mkConst<bool>(false);
 }
 
 ITESimplifier::~ITESimplifier()
@@ -977,7 +977,7 @@ Node ITESimplifier::attemptLiftEquality(TNode atom)
               search.nonConstants.size());
           Trace("ite::simpite") << "used " << search.nonConstants.size()
                                 << " nonconstants" << endl;
-          NodeManager* nm = NodeManager::currentNM();
+          NodeManager* nm = nodeManager();
           Node simpVar = getSimpVar(notIte.getType());
           TNode newLeft = leftIsIte ? simpVar : notIte;
           TNode newRight = leftIsIte ? notIte : simpVar;
@@ -1010,7 +1010,7 @@ Node ITESimplifier::attemptLiftEquality(TNode atom)
     Node lT = lite[1];
     Node lE = lite[2];
 
-    NodeManager* nm = NodeManager::currentNM();
+    NodeManager* nm = nodeManager();
     Node negRite = atom[1][1];
     Node rC = negRite[0];
     Node rT = nm->mkNode(Kind::MULT, negOne, negRite[1]);
@@ -1045,7 +1045,7 @@ Node ITESimplifier::transformAtom(TNode atom)
     if (atom.getKind() == Kind::EQUAL && atom[0].isConst() && atom[1].isConst())
     {
       // constant equality
-      return NodeManager::currentNM()->mkConst<bool>(atom[0] == atom[1]);
+      return nodeManager()->mkConst<bool>(atom[0] == atom[1]);
     }
     return Node::null();
   }
@@ -1360,7 +1360,7 @@ Node ITESimplifier::getSimpVar(TypeNode t)
   {
     return (*it).second;
   }
-  SkolemManager* sm = NodeManager::currentNM()->getSkolemManager();
+  SkolemManager* sm = nodeManager()->getSkolemManager();
   Node var = sm->mkDummySkolem(
       "iteSimp", t, "is a variable resulting from ITE simplification");
   d_simpVars[t] = var;
@@ -1614,10 +1614,10 @@ Node ITESimplifier::simpITE(TNode assertion)
   return d_simpITECache[assertion];
 }
 
-ITECareSimplifier::ITECareSimplifier() : d_careSetsOutstanding(0), d_usedSets()
+ITECareSimplifier::ITECareSimplifier(NodeManager* nm) : d_careSetsOutstanding(0), d_usedSets()
 {
-  d_true = NodeManager::currentNM()->mkConst<bool>(true);
-  d_false = NodeManager::currentNM()->mkConst<bool>(false);
+  d_true = nm->mkConst<bool>(true);
+  d_false = nm->mkConst<bool>(false);
 }
 
 ITECareSimplifier::~ITECareSimplifier()
diff --git a/src/preprocessing/util/ite_utilities.h b/src/preprocessing/util/ite_utilities.h
index a1e338700..317c5366b 100644
--- a/src/preprocessing/util/ite_utilities.h
+++ b/src/preprocessing/util/ite_utilities.h
@@ -327,7 +327,7 @@ class ITESimplifier : protected EnvObj
 class ITECareSimplifier
 {
  public:
-  ITECareSimplifier();
+  ITECareSimplifier(NodeManager* nm);
   ~ITECareSimplifier();
 
   Node simplifyWithCare(TNode e);
-- 
2.47.1

