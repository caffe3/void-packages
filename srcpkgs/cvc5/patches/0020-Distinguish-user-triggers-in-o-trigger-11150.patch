From e678344cda47347b7f6d2dcc82131d844a8ed993 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Tue, 13 Aug 2024 02:26:09 -0500
Subject: [PATCH 020/312] Distinguish user triggers in -o trigger (#11150)

---
 .../quantifiers/ematching/ho_trigger.cpp      |  5 ++--
 src/theory/quantifiers/ematching/ho_trigger.h |  3 ++-
 .../ematching/inst_strategy_e_matching.cpp    |  6 +++--
 .../inst_strategy_e_matching_user.cpp         |  7 +++---
 src/theory/quantifiers/ematching/trigger.cpp  | 19 +++++++++++----
 src/theory/quantifiers/ematching/trigger.h    | 14 +++++++++--
 .../ematching/trigger_database.cpp            | 11 +++++----
 .../quantifiers/ematching/trigger_database.h  | 24 +++++++++++--------
 8 files changed, 59 insertions(+), 30 deletions(-)

diff --git a/src/theory/quantifiers/ematching/ho_trigger.cpp b/src/theory/quantifiers/ematching/ho_trigger.cpp
index 955ec9c73..dff206211 100644
--- a/src/theory/quantifiers/ematching/ho_trigger.cpp
+++ b/src/theory/quantifiers/ematching/ho_trigger.cpp
@@ -42,8 +42,9 @@ HigherOrderTrigger::HigherOrderTrigger(
     TermRegistry& tr,
     Node q,
     std::vector<Node>& nodes,
-    std::map<Node, std::vector<Node> >& ho_apps)
-    : Trigger(env, qs, qim, qr, tr, q, nodes), d_ho_var_apps(ho_apps)
+    std::map<Node, std::vector<Node> >& ho_apps,
+    bool isUser)
+    : Trigger(env, qs, qim, qr, tr, q, nodes, isUser), d_ho_var_apps(ho_apps)
 {
   NodeManager* nm = NodeManager::currentNM();
   // process the higher-order variable applications
diff --git a/src/theory/quantifiers/ematching/ho_trigger.h b/src/theory/quantifiers/ematching/ho_trigger.h
index 13af17790..0e77aee2c 100644
--- a/src/theory/quantifiers/ematching/ho_trigger.h
+++ b/src/theory/quantifiers/ematching/ho_trigger.h
@@ -99,7 +99,8 @@ class HigherOrderTrigger : public Trigger
                      TermRegistry& tr,
                      Node q,
                      std::vector<Node>& nodes,
-                     std::map<Node, std::vector<Node> >& ho_apps);
+                     std::map<Node, std::vector<Node> >& ho_apps,
+                     bool isUser = false);
   virtual ~HigherOrderTrigger();
 
   /** Collect higher order var apply terms
diff --git a/src/theory/quantifiers/ematching/inst_strategy_e_matching.cpp b/src/theory/quantifiers/ematching/inst_strategy_e_matching.cpp
index 1db0d681b..83136724d 100644
--- a/src/theory/quantifiers/ematching/inst_strategy_e_matching.cpp
+++ b/src/theory/quantifiers/ematching/inst_strategy_e_matching.cpp
@@ -286,7 +286,8 @@ void InstStrategyAutoGenTriggers::generateTriggers(Node q)
                                    patTermsSingle[i],
                                    false,
                                    TriggerDatabase::TR_RETURN_NULL,
-                                   d_num_trigger_vars[q]);
+                                   d_num_trigger_vars[q],
+                                   false);
       addTrigger(tr, q);
     }
     if (!options().quantifiers.multiTriggerWhenSingle)
@@ -318,7 +319,8 @@ void InstStrategyAutoGenTriggers::generateTriggers(Node q)
                                patTermsMulti,
                                false,
                                TriggerDatabase::TR_GET_OLD,
-                               d_num_trigger_vars[q]);
+                               d_num_trigger_vars[q],
+                               false);
   addTrigger(tr, q);
   // we only add a single multi-trigger
 }
diff --git a/src/theory/quantifiers/ematching/inst_strategy_e_matching_user.cpp b/src/theory/quantifiers/ematching/inst_strategy_e_matching_user.cpp
index 171f6d0b8..8e310a023 100644
--- a/src/theory/quantifiers/ematching/inst_strategy_e_matching_user.cpp
+++ b/src/theory/quantifiers/ematching/inst_strategy_e_matching_user.cpp
@@ -86,8 +86,8 @@ InstStrategyStatus InstStrategyUserPatterns::process(Node q,
     std::vector<std::vector<Node> >& ugw = d_user_gen_wait[q];
     for (size_t i = 0, usize = ugw.size(); i < usize; i++)
     {
-      Trigger* t =
-          d_td.mkTrigger(q, ugw[i], true, TriggerDatabase::TR_RETURN_NULL);
+      Trigger* t = d_td.mkTrigger(
+          q, ugw[i], true, TriggerDatabase::TR_RETURN_NULL, 0, true);
       if (t)
       {
         d_user_gen[q].push_back(t);
@@ -149,7 +149,8 @@ void InstStrategyUserPatterns::addUserPattern(Node q, Node pat)
     d_user_gen_wait[q].push_back(nodes);
     return;
   }
-  Trigger* t = d_td.mkTrigger(q, nodes, true, TriggerDatabase::TR_MAKE_NEW);
+  Trigger* t =
+      d_td.mkTrigger(q, nodes, true, TriggerDatabase::TR_MAKE_NEW, 0, true);
   if (t)
   {
     d_user_gen[q].push_back(t);
diff --git a/src/theory/quantifiers/ematching/trigger.cpp b/src/theory/quantifiers/ematching/trigger.cpp
index c8d60830c..846809e1c 100644
--- a/src/theory/quantifiers/ematching/trigger.cpp
+++ b/src/theory/quantifiers/ematching/trigger.cpp
@@ -49,7 +49,8 @@ Trigger::Trigger(Env& env,
                  QuantifiersRegistry& qr,
                  TermRegistry& tr,
                  Node q,
-                 std::vector<Node>& nodes)
+                 std::vector<Node>& nodes,
+                 bool isUser)
     : EnvObj(env),
       d_qstate(qs),
       d_qim(qim),
@@ -88,29 +89,33 @@ Trigger::Trigger(Env& env,
   d_trNode = NodeManager::currentNM()->mkNode(Kind::SEXPR, extNodes);
   if (isOutputOn(OutputTag::TRIGGER))
   {
+    output(OutputTag::TRIGGER) << (isUser ? "(user-trigger " : "(trigger ");
     QuantAttributes& qa = d_qreg.getQuantAttributes();
-    output(OutputTag::TRIGGER) << "(trigger " << qa.quantToString(q) << " "
-                               << d_trNode << ")" << std::endl;
+    output(OutputTag::TRIGGER)
+        << qa.quantToString(q) << " " << d_trNode;
   }
   QuantifiersStatistics& stats = qs.getStats();
   if( d_nodes.size()==1 ){
     if (TriggerTermInfo::isSimpleTrigger(d_nodes[0]))
     {
       d_mg = new InstMatchGeneratorSimple(env, this, q, d_nodes[0]);
-      ++(stats.d_triggers);
+      ++(stats.d_simple_triggers);
+      output(OutputTag::TRIGGER) << " :simple";
     }else{
       d_mg = InstMatchGenerator::mkInstMatchGenerator(env, this, q, d_nodes[0]);
-      ++(stats.d_simple_triggers);
+      ++(stats.d_triggers);
     }
   }else{
     if (options().quantifiers.multiTriggerCache)
     {
       d_mg = new InstMatchGeneratorMulti(env, this, q, d_nodes);
+      output(OutputTag::TRIGGER) << " :multi-cache";
     }
     else
     {
       d_mg =
           InstMatchGenerator::mkInstMatchGeneratorMulti(env, this, q, d_nodes);
+      output(OutputTag::TRIGGER) << " :multi";
     }
     if (TraceIsOn("multi-trigger"))
     {
@@ -122,6 +127,10 @@ Trigger::Trigger(Env& env,
     }
     ++(stats.d_multi_triggers);
   }
+  if (isOutputOn(OutputTag::TRIGGER))
+  {
+    output(OutputTag::TRIGGER) << ")" << std::endl;
+  }
 
   Trace("trigger-debug") << "Finished making trigger." << std::endl;
 }
diff --git a/src/theory/quantifiers/ematching/trigger.h b/src/theory/quantifiers/ematching/trigger.h
index 527915df6..538f868a1 100644
--- a/src/theory/quantifiers/ematching/trigger.h
+++ b/src/theory/quantifiers/ematching/trigger.h
@@ -102,14 +102,24 @@ class Trigger : protected EnvObj
   friend class IMGenerator;
 
  public:
-  /** trigger constructor */
+  /** trigger constructor
+   *
+   * @param env Reference to the environment.
+   * @param qs Reference to quantifiers state.
+   * @param qr Reference to quantifiers registry.
+   * @param tr Reference to term registry.
+   * @param q The quantified formula this is a trigger for.
+   * @param node The nodes comprising the trigger.
+   * @param isUser Whether this was a user trigger (for output trace).
+   */
   Trigger(Env& env,
           QuantifiersState& qs,
           QuantifiersInferenceManager& qim,
           QuantifiersRegistry& qr,
           TermRegistry& tr,
           Node q,
-          std::vector<Node>& nodes);
+          std::vector<Node>& nodes,
+          bool isUser = false);
   virtual ~Trigger();
   /** get the generator associated with this trigger */
   IMGenerator* getGenerator() { return d_mg; }
diff --git a/src/theory/quantifiers/ematching/trigger_database.cpp b/src/theory/quantifiers/ematching/trigger_database.cpp
index a66f3c5b2..9b84ccafd 100644
--- a/src/theory/quantifiers/ematching/trigger_database.cpp
+++ b/src/theory/quantifiers/ematching/trigger_database.cpp
@@ -38,7 +38,8 @@ Trigger* TriggerDatabase::mkTrigger(Node q,
                                     const std::vector<Node>& nodes,
                                     bool keepAll,
                                     int trOption,
-                                    size_t useNVars)
+                                    size_t useNVars,
+                                    bool isUser)
 {
   std::vector<Node> trNodes;
   if (!keepAll)
@@ -80,22 +81,22 @@ Trigger* TriggerDatabase::mkTrigger(Node q,
   if (!hoApps.empty())
   {
     t = new HigherOrderTrigger(
-        d_env, d_qs, d_qim, d_qreg, d_treg, q, trNodes, hoApps);
+        d_env, d_qs, d_qim, d_qreg, d_treg, q, trNodes, hoApps, isUser);
   }
   else
   {
-    t = new Trigger(d_env, d_qs, d_qim, d_qreg, d_treg, q, trNodes);
+    t = new Trigger(d_env, d_qs, d_qim, d_qreg, d_treg, q, trNodes, isUser);
   }
   d_trie.addTrigger(trNodes, t);
   return t;
 }
 
 Trigger* TriggerDatabase::mkTrigger(
-    Node q, Node n, bool keepAll, int trOption, size_t useNVars)
+    Node q, Node n, bool keepAll, int trOption, size_t useNVars, bool isUser)
 {
   std::vector<Node> nodes;
   nodes.push_back(n);
-  return mkTrigger(q, nodes, keepAll, trOption, useNVars);
+  return mkTrigger(q, nodes, keepAll, trOption, useNVars, isUser);
 }
 
 bool TriggerDatabase::mkTriggerTerms(Node q,
diff --git a/src/theory/quantifiers/ematching/trigger_database.h b/src/theory/quantifiers/ematching/trigger_database.h
index c3ad9b9b7..a0b140020 100644
--- a/src/theory/quantifiers/ematching/trigger_database.h
+++ b/src/theory/quantifiers/ematching/trigger_database.h
@@ -51,14 +51,16 @@ class TriggerDatabase : protected EnvObj
   /** mkTrigger method
    *
    * This makes an instance of a trigger object.
-   *  qe     : pointer to the quantifier engine;
-   *  q      : the quantified formula we are making a trigger for
-   *  nodes  : the nodes comprising the (multi-)trigger
-   *  keepAll: don't remove unneeded patterns;
-   *  trOption : policy for dealing with triggers that already exist
-   *             (see below)
-   *  useNVars : number of variables that should be bound by the trigger
-   *             typically, the number of quantified variables in q.
+   * @param qe Pointer to the quantifier engine;
+   * @param q The quantified formula we are making a trigger for
+   * @param nodes The nodes comprising the (multi-)trigger
+   * @param keepAll Don't remove unneeded patterns;
+   * @param trOption Policy for dealing with triggers that already exist (see
+   * below)
+   * @param useNVars Number of variables that should be bound by the trigger
+   * typically, the number of variables in q (0 defaults to the number of
+   * variables in q).
+   * @param isUser Whether this is a user trigger (for output trace).
    */
   enum
   {
@@ -70,13 +72,15 @@ class TriggerDatabase : protected EnvObj
                      const std::vector<Node>& nodes,
                      bool keepAll = true,
                      int trOption = TR_MAKE_NEW,
-                     size_t useNVars = 0);
+                     size_t useNVars = 0,
+                     bool isUser = false);
   /** single trigger version that calls the above function */
   Trigger* mkTrigger(Node q,
                      Node n,
                      bool keepAll = true,
                      int trOption = TR_MAKE_NEW,
-                     size_t useNVars = 0);
+                     size_t useNVars = 0,
+                     bool isUser = false);
 
   /** make trigger terms
    *
-- 
2.47.1

