From a9d5a44c6363c6393aede8153e892aedf8ba4198 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Fri, 18 Oct 2024 14:12:00 -0500
Subject: [PATCH 130/312] Expand
 ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV (#11288)

Introduces a new theory rewrite ProofRewriteRule::QUANT_MINISCOPE_FV and
proof rule ProofRule::QUANT_VAR_REORDERING for this purpose and adds
their Eunoia definitions.

Also refactors the rewriter a bit to ensure that proof reconstruction
was possible. In particular, we rectify some variable reordering done by
the rewriter to make reconstruction easier.

---------

Co-authored-by: Abdalrhman Mohamed <abdoo8080@outlook.com>
---
 include/cvc5/cvc5_proof_rule.h                |  27 +++++
 proofs/eo/cpc/programs/Nary.eo                |  13 ++
 proofs/eo/cpc/rules/Booleans.eo               |   5 +
 proofs/eo/cpc/rules/Quantifiers.eo            |  59 +++++++++
 src/api/cpp/cvc5_proof_rule_template.cpp      |   2 +
 src/proof/alf/alf_printer.cpp                 |   2 +
 src/rewriter/basic_rewrite_rcons.cpp          | 113 +++++++++++++++++-
 src/rewriter/basic_rewrite_rcons.h            |  10 ++
 src/theory/quantifiers/proof_checker.cpp      |  25 ++++
 .../quantifiers/quantifiers_rewriter.cpp      |  86 +++++++++++--
 src/theory/theory_rewriter.cpp                |   8 +-
 src/theory/theory_rewriter.h                  |   3 +-
 12 files changed, 339 insertions(+), 14 deletions(-)

diff --git a/include/cvc5/cvc5_proof_rule.h b/include/cvc5/cvc5_proof_rule.h
index 236e9e08c..7f4585de8 100644
--- a/include/cvc5/cvc5_proof_rule.h
+++ b/include/cvc5/cvc5_proof_rule.h
@@ -1350,6 +1350,20 @@ enum ENUM(ProofRule)
    * \endverbatim
    */
   EVALUE(ALPHA_EQUIV),
+  /**
+   * \verbatim embed:rst:leading-asterisk
+   * **Quantifiers -- Variable reordering**
+   *
+   * .. math::
+   *
+   *   \inferrule{-\mid (\forall X.\> F) = (\forall Y.\> F)}
+   *   {(\forall X.\> F) = (\forall Y.\> F)}
+   * 
+   * where :math:`Y` is a reordering of :math:`X`.
+   * 
+   * \endverbatim
+   */
+  EVALUE(QUANT_VAR_REORDERING),
   /**
    * \verbatim embed:rst:leading-asterisk
    * **Sets -- Singleton injectivity**
@@ -2452,6 +2466,19 @@ enum ENUM(ProofRewriteRule)
    * \endverbatim
    */
   EVALUE(QUANT_MINISCOPE),
+  /**
+   * \verbatim embed:rst:leading-asterisk
+   * **Quantifiers -- Miniscoping free variables**
+   *
+   * .. math::
+   *   \forall X.\> F_1 \vee \ldots \vee F_n = (\forall X_1.\> F_1) \vee \ldots \vee (\forall X_n.\> F_n)
+   * 
+   * where :math:`X = X_1 \ldots X_n`, and the right hand side does not have any
+   * free variable in :math:`X`.
+   *
+   * \endverbatim
+   */
+  EVALUE(QUANT_MINISCOPE_FV),
   /**
    * \verbatim embed:rst:leading-asterisk
    * **Quantifiers -- Macro connected free variable partitioning**
diff --git a/proofs/eo/cpc/programs/Nary.eo b/proofs/eo/cpc/programs/Nary.eo
index 9075d7f33..6b1423b14 100644
--- a/proofs/eo/cpc/programs/Nary.eo
+++ b/proofs/eo/cpc/programs/Nary.eo
@@ -30,6 +30,19 @@
     )
 )
 
+; define: $nary_is_eq_set
+; args:
+; - cons (-> L L L): The n-ary function symbol.
+; - nil L: The nil terminator of cons.
+; - c1 L: The first term, assumed to be a cons-list.
+; - c2 L: The second term, assumed to be a cons-list.
+; return: >
+;   true if c1 is a subset of c2 and c2 is a subset of c1.
+(define $nary_is_eq_set ((L Type :implicit) (cons (-> L L L)) (nil L) (c1 L) (c2 L))
+  (eo::ite ($nary_is_subset cons nil c1 c2)
+    ($nary_is_subset cons nil c2 c1)
+    false))
+
 ; program: $nary_remove
 ; args:
 ; - cons (-> L L L): The n-ary function symbol.
diff --git a/proofs/eo/cpc/rules/Booleans.eo b/proofs/eo/cpc/rules/Booleans.eo
index b038cb40a..3430d6da8 100644
--- a/proofs/eo/cpc/rules/Booleans.eo
+++ b/proofs/eo/cpc/rules/Booleans.eo
@@ -188,6 +188,11 @@
 ; - C2 Bool: The desired reordered form of C1.
 ; requires: Showing that C1 can be reordered to obtain C2.
 ; conclusion: The desired clause C2.
+; note: >
+;   The implementation here checks only that C1 is a subset of C2, making the
+;   rule sound. The internal proof checker in cvc5 ensures this rule is only
+;   applied when C1 and C2 have exactly the same literals when considered as
+;   a multiset.
 (declare-rule reordering ((C1 Bool) (C2 Bool))
     :premises (C1)
     :args (C2)
diff --git a/proofs/eo/cpc/rules/Quantifiers.eo b/proofs/eo/cpc/rules/Quantifiers.eo
index 72e22f95e..c78b88f07 100644
--- a/proofs/eo/cpc/rules/Quantifiers.eo
+++ b/proofs/eo/cpc/rules/Quantifiers.eo
@@ -80,3 +80,62 @@
   :requires ((($beta_reduce a @list.nil) b))
   :conclusion (= a b)
 )
+
+;;;;; ProofRule::QUANT_VAR_REORDERING
+
+; rule: quant_var_reordering
+; implements: ProofRule::QUANT_VAR_REORDERING
+; premises:
+; - C1: The clause to reorder.
+; args:
+; - C2 Bool: The desired reordered form of C1.
+; requires: Showing that C1 can be reordered to obtain C2.
+; conclusion: The desired clause C2.
+; note: >
+;   The implementation here does not check for duplication of variables in
+;   x and y. The internal proof checker in cvc5 ensures this rule is never
+;   applied with duplication of variables.
+(declare-rule quant_var_reordering ((x @List) (y @List) (F Bool))
+    :args ((= (forall x F) (forall y F)))
+    :requires ((($nary_is_eq_set @list @list.nil x y) true))
+    :conclusion (= (forall x F) (forall y F))
+)
+
+;;;;; ProofRewriteRule::QUANT_MINISCOPE_FV
+
+; program: $is_quant_miniscope_fv
+; args:
+; - x @List: The list of variables of the first formula we have yet to process
+; - F Bool: The body of the first formula in question.
+; - G Bool: The second formula in question.
+; return: >
+;    True if (forall x F) is equivalent to G based on miniscope reasoning with
+;    free variables.
+(program $is_quant_miniscope_fv ((x @List) (xs @List :list) (ys @List :list) (f Bool) (fs Bool :list) (g Bool) (gs Bool :list))
+  (@List Bool Bool) Bool
+  (
+  (($is_quant_miniscope_fv x (or f fs) (or f gs))                     (eo::requires ($contains_subterm_list f x) false 
+                                                                        ($is_quant_miniscope_fv x fs gs)))
+  (($is_quant_miniscope_fv x (or f fs) (or (forall @list.nil f) gs))  (eo::requires ($contains_subterm_list f x) false 
+                                                                        ($is_quant_miniscope_fv x fs gs)))
+  (($is_quant_miniscope_fv (@list x xs) (or f fs) (or (forall (@list x ys) f) gs))  
+                                                                      (eo::requires ($contains_subterm gs x) false
+                                                                        ($is_quant_miniscope_fv xs (or f fs) (or (forall ys f) gs))))
+  (($is_quant_miniscope_fv @list.nil false false)                     true)
+  (($is_quant_miniscope_fv x f g)                                     false)
+  )
+)
+
+; rule: quant-miniscope-fv
+; implements: ProofRewriteRule::QUANT_MINISCOPE_FV
+; args:
+; - eq Bool: The equality whose left hand side is a quantified formula.
+; requires: >
+;   The right hand side of the equality can be shown equivalent to the right
+;   hand side based on reasoning about the disjuncts of F that contain x.
+; conclusion: The given equality.
+(declare-rule quant-miniscope-fv ((x @List) (F Bool) (G Bool))
+  :args ((= (forall x F) G))
+  :requires ((($is_quant_miniscope_fv x F G) true))
+  :conclusion (= (forall x F) G)
+)
diff --git a/src/api/cpp/cvc5_proof_rule_template.cpp b/src/api/cpp/cvc5_proof_rule_template.cpp
index 4a63ba0c1..803d76ba3 100644
--- a/src/api/cpp/cvc5_proof_rule_template.cpp
+++ b/src/api/cpp/cvc5_proof_rule_template.cpp
@@ -128,6 +128,7 @@ const char* toString(ProofRule rule)
     case ProofRule::SKOLEMIZE: return "SKOLEMIZE";
     case ProofRule::INSTANTIATE: return "INSTANTIATE";
     case ProofRule::ALPHA_EQUIV: return "ALPHA_EQUIV";
+    case ProofRule::QUANT_VAR_REORDERING: return "QUANT_VAR_REORDERING";
     //================================================= Sets rules
     case ProofRule::SETS_SINGLETON_INJ: return "SETS_SINGLETON_INJ";
     case ProofRule::SETS_EXT: return "SETS_EXT";
@@ -236,6 +237,7 @@ const char* toString(cvc5::ProofRewriteRule rule)
     case ProofRewriteRule::QUANT_UNUSED_VARS: return "quant-unused-vars";
     case ProofRewriteRule::QUANT_MERGE_PRENEX: return "quant-merge-prenex";
     case ProofRewriteRule::QUANT_MINISCOPE: return "quant-miniscope";
+    case ProofRewriteRule::QUANT_MINISCOPE_FV: return "quant-miniscope-fv";
     case ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV:
       return "macro-quant-partition-connected-fv";
     case ProofRewriteRule::DT_INST: return "dt-inst";
diff --git a/src/proof/alf/alf_printer.cpp b/src/proof/alf/alf_printer.cpp
index 5337cece5..c0dd8da98 100644
--- a/src/proof/alf/alf_printer.cpp
+++ b/src/proof/alf/alf_printer.cpp
@@ -170,6 +170,7 @@ bool AlfPrinter::isHandled(const ProofNode* pfn) const
     case ProofRule::INSTANTIATE:
     case ProofRule::SKOLEMIZE:
     case ProofRule::ALPHA_EQUIV:
+    case ProofRule::QUANT_VAR_REORDERING:
     case ProofRule::ENCODE_EQ_INTRO:
     case ProofRule::HO_APP_ENCODE:
     case ProofRule::ACI_NORM:
@@ -244,6 +245,7 @@ bool AlfPrinter::isHandledTheoryRewrite(ProofRewriteRule id,
     case ProofRewriteRule::BETA_REDUCE:
     case ProofRewriteRule::ARITH_STRING_PRED_ENTAIL:
     case ProofRewriteRule::ARITH_STRING_PRED_SAFE_APPROX:
+    case ProofRewriteRule::QUANT_MINISCOPE_FV:
     case ProofRewriteRule::RE_LOOP_ELIM:
     case ProofRewriteRule::SETS_IS_EMPTY_EVAL:
     case ProofRewriteRule::STR_IN_RE_CONCAT_STAR_CHAR:
diff --git a/src/rewriter/basic_rewrite_rcons.cpp b/src/rewriter/basic_rewrite_rcons.cpp
index 9d369fb70..a9118d351 100644
--- a/src/rewriter/basic_rewrite_rcons.cpp
+++ b/src/rewriter/basic_rewrite_rcons.cpp
@@ -17,6 +17,7 @@
 #include "rewriter/basic_rewrite_rcons.h"
 
 #include "expr/nary_term_util.h"
+#include "expr/node_algorithm.h"
 #include "proof/conv_proof_generator.h"
 #include "proof/proof_checker.h"
 #include "proof/proof_node_algorithm.h"
@@ -192,6 +193,12 @@ void BasicRewriteRCons::ensureProofForTheoryRewrite(
         handledMacro = true;
       }
       break;
+    case ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV:
+      if (ensureProofMacroQuantPartitionConnectedFv(cdp, eq))
+      {
+        handledMacro = true;
+      }
+      break;
     default: break;
   }
   if (handledMacro)
@@ -432,7 +439,7 @@ bool BasicRewriteRCons::ensureProofMacroArithStringPredEntail(CDProof* cdp,
 bool BasicRewriteRCons::ensureProofMacroSubstrStripSymLength(CDProof* cdp,
                                                              const Node& eq)
 {
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   Trace("brc-macro") << "Expand substring strip for " << eq << std::endl;
   Assert(eq.getKind() == Kind::EQUAL);
   Node lhs = eq[0];
@@ -515,6 +522,110 @@ bool BasicRewriteRCons::ensureProofMacroSubstrStripSymLength(CDProof* cdp,
   return true;
 }
 
+bool BasicRewriteRCons::ensureProofMacroQuantPartitionConnectedFv(
+    CDProof* cdp, const Node& eq)
+{
+  NodeManager* nm = nodeManager();
+  Trace("brc-macro") << "Expand macro quant partition connected for " << eq
+                     << std::endl;
+  Node q = eq[0];
+  Assert(q.getKind() == Kind::FORALL);
+  Node origBody = q[1];
+  std::unordered_set<Node> obvs(q[0].begin(), q[0].end());
+  std::vector<Node> newBodyDisj;
+  Assert(eq[1].getKind() == Kind::OR);
+  std::vector<Node> newVars;
+  for (const Node& d : eq[1])
+  {
+    if (d.getKind() == Kind::FORALL)
+    {
+      // Corner case: if a nested quantified formula, it may have no relation
+      // to the original, in which case we treat it as a standalone literal.
+      // We use hasSubterm to check for this.
+      if (!expr::hasSubterm(origBody, d))
+      {
+        newBodyDisj.emplace_back(d[1]);
+        for (const Node& v : d[0])
+        {
+          if (std::find(newVars.begin(), newVars.end(), v) == newVars.end())
+          {
+            newVars.emplace_back(v);
+          }
+          else
+          {
+            // variable was repeated
+            Assert(false);
+            return false;
+          }
+        }
+        continue;
+      }
+    }
+    // handle the case where there are no variables from the original
+    newBodyDisj.emplace_back(d);
+  }
+  std::vector<Node> transEq;
+  // To prove (forall X F) = (forall X1 F1) or ... or (forall Xn Fn),
+  // we first remove variables and reorder to ensure that X = X1 ... Xn.
+  if (newVars.size() < q[0].getNumChildren())
+  {
+    theory::Rewriter* rr = d_env.getRewriter();
+    Node uq = rr->rewriteViaRule(ProofRewriteRule::QUANT_UNUSED_VARS, q);
+    if (uq.isNull())
+    {
+      return false;
+    }
+    Node eqqu = q.eqNode(uq);
+    if (!cdp->addTheoryRewriteStep(eqqu, ProofRewriteRule::QUANT_UNUSED_VARS))
+    {
+      Assert(false);
+      return false;
+    }
+    transEq.emplace_back(eqqu);
+    q = uq;
+  }
+  Node newVarList = nm->mkNode(Kind::BOUND_VAR_LIST, newVars);
+  if (newVarList != q[0])
+  {
+    Node rq = nm->mkNode(Kind::FORALL, newVarList, q[1]);
+    Node eqqr = q.eqNode(rq);
+    if (!cdp->addStep(eqqr, ProofRule::QUANT_VAR_REORDERING, {}, {eqqr}))
+    {
+      Assert(false);
+      return false;
+    }
+    transEq.emplace_back(eqqr);
+    q = rq;
+  }
+  Node newBody = nm->mkOr(newBodyDisj);
+  Node eqb = origBody.eqNode(newBody);
+  // We now prove
+  //   (forall X F) = (forall X F1 or ... or Fn)
+  if (!cdp->addStep(eqb, ProofRule::ACI_NORM, {}, {eqb}))
+  {
+    Assert(false);
+    return false;
+  }
+  Node newQuant = nm->mkNode(Kind::FORALL, q[0], newBody);
+  std::vector<Node> cargs;
+  ProofRule cr = expr::getCongRule(q, cargs);
+  Node eqq = q.eqNode(newQuant);
+  cdp->addStep(eqq, cr, {eqb}, cargs);
+  transEq.emplace_back(eqq);
+  Node eqq2 = newQuant.eqNode(eq[1]);
+  // Then prove
+  //   (forall X F1 or ... or Fn) = (forall X1 F1) or ... or (forall Xn Fn)
+  // via ProofRewriteRule::QUANT_MINISCOPE_FV.
+  if (!cdp->addTheoryRewriteStep(eqq2, ProofRewriteRule::QUANT_MINISCOPE_FV))
+  {
+    Assert(false);
+    return false;
+  }
+  transEq.emplace_back(eqq2);
+  cdp->addStep(eq, ProofRule::TRANS, transEq, {});
+  return true;
+}
+
 bool BasicRewriteRCons::ensureProofArithPolyNormRel(CDProof* cdp,
                                                     const Node& eq)
 {
diff --git a/src/rewriter/basic_rewrite_rcons.h b/src/rewriter/basic_rewrite_rcons.h
index 9e0567220..8316422a3 100644
--- a/src/rewriter/basic_rewrite_rcons.h
+++ b/src/rewriter/basic_rewrite_rcons.h
@@ -170,6 +170,16 @@ class BasicRewriteRCons : protected EnvObj
    * @return true if added a closed proof of eq to cdp.
    */
   bool ensureProofMacroSubstrStripSymLength(CDProof* cdp, const Node& eq);
+  /**
+   * Elaborate a rewrite eq that was proven by
+   * ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV.
+   *
+   * @param cdp The proof to add to.
+   * @param eq The rewrite proven by
+   * ProofRewriteRule::MACRO_QUANT_PARTITION_CONNECTED_FV.
+   * @return true if added a closed proof of eq to cdp.
+   */
+  bool ensureProofMacroQuantPartitionConnectedFv(CDProof* cdp, const Node& eq);
   /**
    * @param cdp The proof to add to.
    * @param eq The rewrite that can be proven by ProofRule::ARITH_POLY_NORM_REL.
diff --git a/src/theory/quantifiers/proof_checker.cpp b/src/theory/quantifiers/proof_checker.cpp
index c5254c19a..f120dd49b 100644
--- a/src/theory/quantifiers/proof_checker.cpp
+++ b/src/theory/quantifiers/proof_checker.cpp
@@ -38,6 +38,7 @@ void QuantifiersProofRuleChecker::registerTo(ProofChecker* pc)
   pc->registerChecker(ProofRule::SKOLEMIZE, this);
   pc->registerChecker(ProofRule::INSTANTIATE, this);
   pc->registerChecker(ProofRule::ALPHA_EQUIV, this);
+  pc->registerChecker(ProofRule::QUANT_VAR_REORDERING, this);
 }
 
 Node QuantifiersProofRuleChecker::checkInternal(
@@ -123,6 +124,30 @@ Node QuantifiersProofRuleChecker::checkInternal(
         vars.begin(), vars.end(), newVars.begin(), newVars.end());
     return args[0].eqNode(renamedBody);
   }
+  else if (id == ProofRule::QUANT_VAR_REORDERING)
+  {
+    Assert(children.empty());
+    Assert(args.size() == 1);
+    Node eq = args[0];
+    if (eq.getKind() != Kind::EQUAL || eq[0].getKind() != Kind::FORALL
+        || eq[1].getKind() != Kind::FORALL || eq[0][1] != eq[1][1])
+    {
+      return Node::null();
+    }
+    std::unordered_set<Node> varSet1(eq[0][0].begin(), eq[0][0].end());
+    std::unordered_set<Node> varSet2(eq[1][0].begin(), eq[1][0].end());
+    // cannot have repetition
+    if (varSet1.size() != eq[0].getNumChildren()
+        || varSet2.size() != eq[1].getNumChildren())
+    {
+      return Node::null();
+    }
+    if (varSet1 != varSet2)
+    {
+      return Node::null();
+    }
+    return eq;
+  }
 
   // no rule
   return Node::null();
diff --git a/src/theory/quantifiers/quantifiers_rewriter.cpp b/src/theory/quantifiers/quantifiers_rewriter.cpp
index 6f17f418c..c0a9d0c95 100644
--- a/src/theory/quantifiers/quantifiers_rewriter.cpp
+++ b/src/theory/quantifiers/quantifiers_rewriter.cpp
@@ -192,10 +192,68 @@ Node QuantifiersRewriter::rewriteViaRule(ProofRewriteRule id, const Node& n)
       std::vector<Node> vars(n[0].begin(), n[0].end());
       Node body = n[1];
       Node nret = computeSplit(vars, body, qa);
-      if (nret != n)
+      if (!nret.isNull())
       {
-        return nret;
+        // only do this rule if it is a proper split; otherwise it will be
+        // subsumed by QUANT_UNUSED_VARS.
+        if (nret.getKind() == Kind::OR)
+        {
+          return nret;
+        }
+      }
+    }
+    break;
+    case ProofRewriteRule::QUANT_MINISCOPE_FV:
+    {
+      if (n.getKind() != Kind::FORALL || n[1].getKind() != Kind::OR)
+      {
+        return Node::null();
+      }
+      size_t nvars = n[0].getNumChildren();
+      std::vector<Node> disj;
+      std::unordered_set<Node> varsUsed;
+      size_t varIndex = 0;
+      for (const Node& d : n[1])
+      {
+        // Note that we may apply to a nested quantified formula, in which
+        // case some variables in fvs may not be bound by this quantified
+        // formula.
+        std::unordered_set<Node> fvs;
+        expr::getFreeVariables(d, fvs);
+        size_t prevVarIndex = varIndex;
+        while (varIndex < nvars && fvs.find(n[0][varIndex]) != fvs.end())
+        {
+          varIndex++;
+        }
+        std::vector<Node> dvs(n[0].begin() + prevVarIndex,
+                              n[0].begin() + varIndex);
+        if (dvs.empty())
+        {
+          disj.emplace_back(d);
+        }
+        else
+        {
+          Node bvl = d_nm->mkNode(Kind::BOUND_VAR_LIST, dvs);
+          disj.emplace_back(d_nm->mkNode(Kind::FORALL, bvl, d));
+        }
+      }
+      // must consume all variables
+      if (varIndex != nvars)
+      {
+        return Node::null();
+      }
+      Node ret = d_nm->mkOr(disj);
+      // go back and ensure all variables are bound
+      std::unordered_set<Node> fvs;
+      expr::getFreeVariables(ret, fvs);
+      for (const Node& v : n[0])
+      {
+        if (fvs.find(v) != fvs.end())
+        {
+          return Node::null();
+        }
       }
+      return ret;
     }
     break;
     default: break;
@@ -1686,19 +1744,29 @@ Node QuantifiersRewriter::computeSplit(std::vector<Node>& args,
         }
         Trace("clause-split-debug") << std::endl;
       }
-      Node bvl = nodeManager()->mkNode(Kind::BOUND_VAR_LIST, eqc_to_var[eqc]);
+      std::vector<Node>& evars = eqc_to_var[eqc];
+      // for the sake of proofs, we provide the variables in the order
+      // they appear in the original quantified formula
+      std::vector<Node> ovars;
+      for (const Node& v : args)
+      {
+        if (std::find(evars.begin(), evars.end(), v) != evars.end())
+        {
+          ovars.emplace_back(v);
+        }
+      }
+      Node bvl = nodeManager()->mkNode(Kind::BOUND_VAR_LIST, ovars);
       Node bd = it->second.size() == 1 ? it->second[0]
                                        : nm->mkNode(Kind::OR, it->second);
       Node fa = nm->mkNode(Kind::FORALL, bvl, bd);
       lits.push_back(fa);
     }
     Assert(!lits.empty());
-    Node nf =
-        lits.size() == 1 ? lits[0] : nodeManager()->mkNode(Kind::OR, lits);
+    Node nf = nodeManager()->mkOr(lits);
     Trace("clause-split-debug") << "Made node : " << nf << std::endl;
     return nf;
   }
-  return mkForAll(args, body, qa);
+  return Node::null();
 }
 
 Node QuantifiersRewriter::mkForAll(const std::vector<Node>& args,
@@ -1818,7 +1886,11 @@ Node QuantifiersRewriter::computeMiniscoping(Node q,
     if (miniscopeFv)
     {
       //splitting subsumes free variable miniscoping, apply it with higher priority
-      return computeSplit( args, body, qa );
+      Node ret = computeSplit(args, body, qa);
+      if (!ret.isNull())
+      {
+        return ret;
+      }
     }
   }
   else if (body.getKind() == Kind::NOT)
diff --git a/src/theory/theory_rewriter.cpp b/src/theory/theory_rewriter.cpp
index bdafe8440..5c755b796 100644
--- a/src/theory/theory_rewriter.cpp
+++ b/src/theory/theory_rewriter.cpp
@@ -99,7 +99,7 @@ ProofRewriteRule TheoryRewriter::findRule(const Node& a,
                                           const Node& b,
                                           TheoryRewriteCtx ctx)
 {
-  std::unordered_set<ProofRewriteRule>& rules = d_pfTheoryRewrites[ctx];
+  std::vector<ProofRewriteRule>& rules = d_pfTheoryRewrites[ctx];
   for (ProofRewriteRule r : rules)
   {
     if (rewriteViaRule(r, a) == b)
@@ -113,12 +113,12 @@ ProofRewriteRule TheoryRewriter::findRule(const Node& a,
 void TheoryRewriter::registerProofRewriteRule(ProofRewriteRule id,
                                               TheoryRewriteCtx ctx)
 {
-  std::unordered_set<ProofRewriteRule>& rules = d_pfTheoryRewrites[ctx];
-  rules.insert(id);
+  std::vector<ProofRewriteRule>& rules = d_pfTheoryRewrites[ctx];
+  rules.push_back(id);
   // theory rewrites marked DSL_SUBCALL are also tried at PRE_DSL effort.
   if (ctx == TheoryRewriteCtx::DSL_SUBCALL)
   {
-    d_pfTheoryRewrites[TheoryRewriteCtx::PRE_DSL].insert(id);
+    d_pfTheoryRewrites[TheoryRewriteCtx::PRE_DSL].push_back(id);
   }
 }
 
diff --git a/src/theory/theory_rewriter.h b/src/theory/theory_rewriter.h
index 61dc27ca0..0b98258c1 100644
--- a/src/theory/theory_rewriter.h
+++ b/src/theory/theory_rewriter.h
@@ -230,8 +230,7 @@ class TheoryRewriter
    * The proof rewrite rules implemented by this rewriter, for each context.
    * This caches the calls to registerProofRewriteRule.
    */
-  std::map<TheoryRewriteCtx, std::unordered_set<ProofRewriteRule>>
-      d_pfTheoryRewrites;
+  std::map<TheoryRewriteCtx, std::vector<ProofRewriteRule>> d_pfTheoryRewrites;
   /** Get a pointer to the node manager */
   NodeManager* nodeManager() const;
 };
-- 
2.47.1

