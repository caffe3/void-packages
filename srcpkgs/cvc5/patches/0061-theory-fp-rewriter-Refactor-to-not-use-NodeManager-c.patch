From 1d6b06059b89922264c14fab83c84386ca69426a Mon Sep 17 00:00:00 2001
From: Aina Niemetz <aina.niemetz@gmail.com>
Date: Wed, 18 Sep 2024 12:20:30 -0700
Subject: [PATCH 061/312] theory fp rewriter: Refactor to not use
 NodeManager::currentNM(). (#11212)

---
 src/theory/fp/theory_fp_rewriter.cpp | 2391 +++++++++++++-------------
 src/theory/fp/theory_fp_rewriter.h   |    2 +-
 2 files changed, 1225 insertions(+), 1168 deletions(-)

diff --git a/src/theory/fp/theory_fp_rewriter.cpp b/src/theory/fp/theory_fp_rewriter.cpp
index dea4b9b89..7e5111822 100644
--- a/src/theory/fp/theory_fp_rewriter.cpp
+++ b/src/theory/fp/theory_fp_rewriter.cpp
@@ -48,344 +48,365 @@ namespace theory {
 namespace fp {
 
 namespace rewrite {
-  /** Rewrite rules **/
-  template <RewriteFunction first, RewriteFunction second>
-  RewriteResponse then (TNode node, bool isPreRewrite) {
-    RewriteResponse result(first(node, isPreRewrite));
+/** Rewrite rules **/
+template <RewriteFunction first, RewriteFunction second>
+RewriteResponse then(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  RewriteResponse result(first(nm, node, isPreRewrite));
 
-    if (result.d_status == REWRITE_DONE)
-    {
-      return second(result.d_node, isPreRewrite);
-    }
-    else
-    {
-      return result;
-    }
+  if (result.d_status == REWRITE_DONE)
+  {
+    return second(nm, result.d_node, isPreRewrite);
   }
-
-  RewriteResponse notFP(TNode node, bool isPreRewrite)
+  else
   {
-    Unreachable() << "non floating-point kind (" << node.getKind()
-                  << ") in floating point rewrite?";
+    return result;
   }
+}
+
+RewriteResponse notFP(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Unreachable() << "non floating-point kind (" << node.getKind()
+                << ") in floating point rewrite?";
+}
+
+RewriteResponse identity(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  return RewriteResponse(REWRITE_DONE, node);
+}
 
-  RewriteResponse identity(TNode node, bool isPreRewrite)
+RewriteResponse type(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Unreachable() << "sort kind (" << node.getKind() << ") found in expression?";
+}
+
+RewriteResponse removeDoubleNegation(NodeManager* nm,
+                                     TNode node,
+                                     bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_NEG);
+  if (node[0].getKind() == Kind::FLOATINGPOINT_NEG)
   {
-    return RewriteResponse(REWRITE_DONE, node);
+    return RewriteResponse(REWRITE_AGAIN, node[0][0]);
   }
 
-  RewriteResponse type(TNode node, bool isPreRewrite)
+  return RewriteResponse(REWRITE_DONE, node);
+}
+
+RewriteResponse compactAbs(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_ABS);
+  if (node[0].getKind() == Kind::FLOATINGPOINT_NEG
+      || node[0].getKind() == Kind::FLOATINGPOINT_ABS)
   {
-    Unreachable() << "sort kind (" << node.getKind()
-                  << ") found in expression?";
+    Node ret = nm->mkNode(Kind::FLOATINGPOINT_ABS, node[0][0]);
+    return RewriteResponse(REWRITE_AGAIN, ret);
   }
 
-  RewriteResponse removeDoubleNegation(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_NEG);
-    if (node[0].getKind() == Kind::FLOATINGPOINT_NEG)
-    {
-      return RewriteResponse(REWRITE_AGAIN, node[0][0]);
-    }
+  return RewriteResponse(REWRITE_DONE, node);
+}
 
-    return RewriteResponse(REWRITE_DONE, node);
-  }
+RewriteResponse convertSubtractionToAddition(NodeManager* nm,
+                                             TNode node,
+                                             bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_SUB);
+  Node negation = nm->mkNode(Kind::FLOATINGPOINT_NEG, node[2]);
+  Node addition =
+      nm->mkNode(Kind::FLOATINGPOINT_ADD, node[0], node[1], negation);
+  return RewriteResponse(REWRITE_DONE, addition);
+}
+
+RewriteResponse breakChain(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(isPreRewrite);  // Should be run first
+
+  Kind k = node.getKind();
+  Assert(k == Kind::FLOATINGPOINT_EQ || k == Kind::FLOATINGPOINT_GEQ
+         || k == Kind::FLOATINGPOINT_LEQ || k == Kind::FLOATINGPOINT_GT
+         || k == Kind::FLOATINGPOINT_LT);
 
-  RewriteResponse compactAbs(TNode node, bool isPreRewrite)
+  size_t children = node.getNumChildren();
+  if (children > 2)
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_ABS);
-    if (node[0].getKind() == Kind::FLOATINGPOINT_NEG
-        || node[0].getKind() == Kind::FLOATINGPOINT_ABS)
+    NodeBuilder conjunction(Kind::AND);
+
+    for (size_t i = 0; i < children - 1; ++i)
     {
-      Node ret =
-          NodeManager::currentNM()->mkNode(Kind::FLOATINGPOINT_ABS, node[0][0]);
-      return RewriteResponse(REWRITE_AGAIN, ret);
+      for (size_t j = i + 1; j < children; ++j)
+      {
+        conjunction << nm->mkNode(k, node[i], node[j]);
+      }
     }
-
-    return RewriteResponse(REWRITE_DONE, node);
+    return RewriteResponse(REWRITE_AGAIN_FULL, conjunction);
   }
-
-  RewriteResponse convertSubtractionToAddition(TNode node, bool isPreRewrite)
+  else
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_SUB);
-    Node negation =
-        NodeManager::currentNM()->mkNode(Kind::FLOATINGPOINT_NEG, node[2]);
-    Node addition = NodeManager::currentNM()->mkNode(
-        Kind::FLOATINGPOINT_ADD, node[0], node[1], negation);
-    return RewriteResponse(REWRITE_DONE, addition);
+    return RewriteResponse(REWRITE_DONE, node);
   }
+}
 
-  RewriteResponse breakChain (TNode node, bool isPreRewrite) {
-    Assert(isPreRewrite);  // Should be run first
+/* Implies (fp.eq x x) --> (not (isNaN x))
+ */
 
-    Kind k = node.getKind();
-    Assert(k == Kind::FLOATINGPOINT_EQ || k == Kind::FLOATINGPOINT_GEQ
-           || k == Kind::FLOATINGPOINT_LEQ || k == Kind::FLOATINGPOINT_GT
-           || k == Kind::FLOATINGPOINT_LT);
+RewriteResponse ieeeEqToEq(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_EQ);
+  return RewriteResponse(
+      REWRITE_DONE,
+      nm->mkNode(
+          Kind::AND,
+          nm->mkNode(
+              Kind::AND,
+              nm->mkNode(Kind::NOT,
+                         nm->mkNode(Kind::FLOATINGPOINT_IS_NAN, node[0])),
+              nm->mkNode(Kind::NOT,
+                         nm->mkNode(Kind::FLOATINGPOINT_IS_NAN, node[1]))),
+          nm->mkNode(
+              Kind::OR,
+              nm->mkNode(Kind::EQUAL, node[0], node[1]),
+              nm->mkNode(Kind::AND,
+                         nm->mkNode(Kind::FLOATINGPOINT_IS_ZERO, node[0]),
+                         nm->mkNode(Kind::FLOATINGPOINT_IS_ZERO, node[1])))));
+}
 
-    size_t children = node.getNumChildren();
-    if (children > 2) {
-      NodeBuilder conjunction(Kind::AND);
+RewriteResponse geqToleq(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_GEQ);
+  return RewriteResponse(REWRITE_DONE,
+                         nm->mkNode(Kind::FLOATINGPOINT_LEQ, node[1], node[0]));
+}
 
-      for (size_t i = 0; i < children - 1; ++i) {
-	for (size_t j = i + 1; j < children; ++j) {
-	  conjunction << NodeManager::currentNM()->mkNode(k, node[i], node[j]);
-	}
-      }
-      return RewriteResponse(REWRITE_AGAIN_FULL, conjunction);
+RewriteResponse gtTolt(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_GT);
+  return RewriteResponse(REWRITE_DONE,
+                         nm->mkNode(Kind::FLOATINGPOINT_LT, node[1], node[0]));
+}
 
-    } else {
-      return RewriteResponse(REWRITE_DONE, node);
-    }
-  }
+RewriteResponse removed(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Unreachable() << "kind (" << node.getKind() << ") should have been removed?";
+}
 
+RewriteResponse variable(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  // We should only get floating point and rounding mode variables to rewrite.
+  TypeNode tn = node.getType(true);
+  Assert(tn.isFloatingPoint() || tn.isRoundingMode());
 
-  /* Implies (fp.eq x x) --> (not (isNaN x))
-   */
+  // Not that we do anything with them...
+  return RewriteResponse(REWRITE_DONE, node);
+}
 
-  RewriteResponse ieeeEqToEq(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_EQ);
-    NodeManager *nm = NodeManager::currentNM();
+RewriteResponse equal(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::EQUAL);
 
-    return RewriteResponse(
-        REWRITE_DONE,
-        nm->mkNode(
-            Kind::AND,
-            nm->mkNode(
-                Kind::AND,
-                nm->mkNode(Kind::NOT,
-                           nm->mkNode(Kind::FLOATINGPOINT_IS_NAN, node[0])),
-                nm->mkNode(Kind::NOT,
-                           nm->mkNode(Kind::FLOATINGPOINT_IS_NAN, node[1]))),
-            nm->mkNode(
-                Kind::OR,
-                nm->mkNode(Kind::EQUAL, node[0], node[1]),
-                nm->mkNode(Kind::AND,
-                           nm->mkNode(Kind::FLOATINGPOINT_IS_ZERO, node[0]),
-                           nm->mkNode(Kind::FLOATINGPOINT_IS_ZERO, node[1])))));
-  }
+  // We should only get equalities of floating point or rounding mode types.
+  TypeNode tn = node[0].getType(true);
 
-  RewriteResponse geqToleq(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_GEQ);
-    return RewriteResponse(REWRITE_DONE,
-                           NodeManager::currentNM()->mkNode(
-                               Kind::FLOATINGPOINT_LEQ, node[1], node[0]));
-  }
+  Assert(tn.isFloatingPoint() || tn.isRoundingMode());
+  Assert(tn == node[1].getType(true));  // Should be ensured by the typing rules
 
-  RewriteResponse gtTolt(TNode node, bool isPreRewrite)
+  if (node[0] == node[1])
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_GT);
-    return RewriteResponse(REWRITE_DONE,
-                           NodeManager::currentNM()->mkNode(
-                               Kind::FLOATINGPOINT_LT, node[1], node[0]));
+    return RewriteResponse(REWRITE_DONE, nm->mkConst(true));
   }
-
-  RewriteResponse removed(TNode node, bool isPreRewrite)
+  else if (!isPreRewrite && (node[0] > node[1]))
   {
-    Unreachable() << "kind (" << node.getKind()
-                  << ") should have been removed?";
+    Node normal = nm->mkNode(Kind::EQUAL, node[1], node[0]);
+    return RewriteResponse(REWRITE_DONE, normal);
   }
-
-  RewriteResponse variable(TNode node, bool isPreRewrite)
+  else
   {
-    // We should only get floating point and rounding mode variables to rewrite.
-    TypeNode tn = node.getType(true);
-    Assert(tn.isFloatingPoint() || tn.isRoundingMode());
-
-    // Not that we do anything with them...
     return RewriteResponse(REWRITE_DONE, node);
   }
+}
 
-  RewriteResponse equal (TNode node, bool isPreRewrite) {
-    Assert(node.getKind() == Kind::EQUAL);
-
-    // We should only get equalities of floating point or rounding mode types.
-    TypeNode tn = node[0].getType(true);
-
-    Assert(tn.isFloatingPoint() || tn.isRoundingMode());
-    Assert(tn
-           == node[1].getType(true));  // Should be ensured by the typing rules
-
-    if (node[0] == node[1]) {
-      return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(true));
-    } else if (!isPreRewrite && (node[0] > node[1])) {
-      Node normal =
-          NodeManager::currentNM()->mkNode(Kind::EQUAL, node[1], node[0]);
-      return RewriteResponse(REWRITE_DONE, normal);
-    } else {
-      return RewriteResponse(REWRITE_DONE, node);
-    }
-  }
-
-
-  // Note these cannot be assumed to be symmetric for +0/-0, thus no symmetry reorder
-  RewriteResponse compactMinMax (TNode node, bool isPreRewrite) {
+// Note these cannot be assumed to be symmetric for +0/-0, thus no symmetry
+// reorder
+RewriteResponse compactMinMax(NodeManager* nm, TNode node, bool isPreRewrite)
+{
 #ifdef CVC5_ASSERTIONS
-    Kind k = node.getKind();
-    Assert((k == Kind::FLOATINGPOINT_MIN) || (k == Kind::FLOATINGPOINT_MAX)
-           || (k == Kind::FLOATINGPOINT_MIN_TOTAL)
-           || (k == Kind::FLOATINGPOINT_MAX_TOTAL));
+  Kind k = node.getKind();
+  Assert((k == Kind::FLOATINGPOINT_MIN) || (k == Kind::FLOATINGPOINT_MAX)
+         || (k == Kind::FLOATINGPOINT_MIN_TOTAL)
+         || (k == Kind::FLOATINGPOINT_MAX_TOTAL));
 #endif
-    if (node[0] == node[1]) {
-      return RewriteResponse(REWRITE_AGAIN, node[0]);
-    } else {
-      return RewriteResponse(REWRITE_DONE, node);
-    }
+  if (node[0] == node[1])
+  {
+    return RewriteResponse(REWRITE_AGAIN, node[0]);
   }
-
-
-  RewriteResponse reorderFPEquality (TNode node, bool isPreRewrite) {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_EQ);
-    Assert(!isPreRewrite);  // Likely redundant in pre-rewrite
-
-    if (node[0] > node[1]) {
-      Node normal = NodeManager::currentNM()->mkNode(
-          Kind::FLOATINGPOINT_EQ, node[1], node[0]);
-      return RewriteResponse(REWRITE_DONE, normal);
-    } else {
-      return RewriteResponse(REWRITE_DONE, node);
-    } 
+  else
+  {
+    return RewriteResponse(REWRITE_DONE, node);
   }
+}
 
-  RewriteResponse reorderBinaryOperation (TNode node, bool isPreRewrite) {
-    Kind k = node.getKind();
-    Assert((k == Kind::FLOATINGPOINT_ADD) || (k == Kind::FLOATINGPOINT_MULT));
-    Assert(!isPreRewrite);  // Likely redundant in pre-rewrite
+RewriteResponse reorderFPEquality(NodeManager* nm,
+                                  TNode node,
+                                  bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_EQ);
+  Assert(!isPreRewrite);  // Likely redundant in pre-rewrite
 
-    if (node[1] > node[2]) {
-      Node normal = NodeManager::currentNM()->mkNode(k,node[0],node[2],node[1]);
-      return RewriteResponse(REWRITE_DONE, normal);
-    } else {
-      return RewriteResponse(REWRITE_DONE, node);
-    } 
+  if (node[0] > node[1])
+  {
+    Node normal = nm->mkNode(Kind::FLOATINGPOINT_EQ, node[1], node[0]);
+    return RewriteResponse(REWRITE_DONE, normal);
+  }
+  else
+  {
+    return RewriteResponse(REWRITE_DONE, node);
   }
+}
 
-  RewriteResponse reorderFMA (TNode node, bool isPreRewrite) {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_FMA);
-    Assert(!isPreRewrite);  // Likely redundant in pre-rewrite
+RewriteResponse reorderBinaryOperation(NodeManager* nm,
+                                       TNode node,
+                                       bool isPreRewrite)
+{
+  Kind k = node.getKind();
+  Assert((k == Kind::FLOATINGPOINT_ADD) || (k == Kind::FLOATINGPOINT_MULT));
+  Assert(!isPreRewrite);  // Likely redundant in pre-rewrite
 
-    if (node[1] > node[2]) {
-      Node normal = NodeManager::currentNM()->mkNode(
-          Kind::FLOATINGPOINT_FMA, {node[0], node[2], node[1], node[3]});
-      return RewriteResponse(REWRITE_DONE, normal);
-    } else {
-      return RewriteResponse(REWRITE_DONE, node);
-    } 
+  if (node[1] > node[2])
+  {
+    Node normal = nm->mkNode(k, node[0], node[2], node[1]);
+    return RewriteResponse(REWRITE_DONE, normal);
   }
+  else
+  {
+    return RewriteResponse(REWRITE_DONE, node);
+  }
+}
 
-  RewriteResponse removeSignOperations (TNode node, bool isPreRewrite) {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_IS_NORMAL
-           || node.getKind() == Kind::FLOATINGPOINT_IS_SUBNORMAL
-           || node.getKind() == Kind::FLOATINGPOINT_IS_ZERO
-           || node.getKind() == Kind::FLOATINGPOINT_IS_INF
-           || node.getKind() == Kind::FLOATINGPOINT_IS_NAN);
-    Assert(node.getNumChildren() == 1);
-
-    Kind childKind(node[0].getKind());
+RewriteResponse reorderFMA(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_FMA);
+  Assert(!isPreRewrite);  // Likely redundant in pre-rewrite
 
-    if ((childKind == Kind::FLOATINGPOINT_NEG)
-        || (childKind == Kind::FLOATINGPOINT_ABS))
-    {
-      Node rewritten = NodeManager::currentNM()->mkNode(node.getKind(),node[0][0]);
-      return RewriteResponse(REWRITE_AGAIN_FULL, rewritten);
-    }
-    else
-    {
-      return RewriteResponse(REWRITE_DONE, node);
-    }
+  if (node[1] > node[2])
+  {
+    Node normal = nm->mkNode(Kind::FLOATINGPOINT_FMA,
+                             {node[0], node[2], node[1], node[3]});
+    return RewriteResponse(REWRITE_DONE, normal);
+  }
+  else
+  {
+    return RewriteResponse(REWRITE_DONE, node);
   }
+}
 
-  RewriteResponse compactRemainder (TNode node, bool isPreRewrite) {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_REM);
-    Assert(!isPreRewrite);  // status assumes parts have been rewritten
+RewriteResponse removeSignOperations(NodeManager* nm,
+                                     TNode node,
+                                     bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_IS_NORMAL
+         || node.getKind() == Kind::FLOATINGPOINT_IS_SUBNORMAL
+         || node.getKind() == Kind::FLOATINGPOINT_IS_ZERO
+         || node.getKind() == Kind::FLOATINGPOINT_IS_INF
+         || node.getKind() == Kind::FLOATINGPOINT_IS_NAN);
+  Assert(node.getNumChildren() == 1);
 
-    Node working = node;
+  Kind childKind(node[0].getKind());
 
-    // (fp.rem (fp.rem X Y) Y) == (fp.rem X Y)
-    if (working[0].getKind() == Kind::FLOATINGPOINT_REM
-        &&  // short-cut matters!
-        working[0][1] == working[1])
-    {
-      working = working[0];
-    }
+  if ((childKind == Kind::FLOATINGPOINT_NEG)
+      || (childKind == Kind::FLOATINGPOINT_ABS))
+  {
+    Node rewritten = nm->mkNode(node.getKind(), node[0][0]);
+    return RewriteResponse(REWRITE_AGAIN_FULL, rewritten);
+  }
+  else
+  {
+    return RewriteResponse(REWRITE_DONE, node);
+  }
+}
 
-    // Sign of the RHS does not matter
-    if (working[1].getKind() == Kind::FLOATINGPOINT_NEG
-        || working[1].getKind() == Kind::FLOATINGPOINT_ABS)
-    {
-      working[1] = working[1][0];
-    }
+RewriteResponse compactRemainder(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_REM);
+  Assert(!isPreRewrite);  // status assumes parts have been rewritten
 
-    // Lift negation out of the LHS so it can be cancelled out
-    if (working[0].getKind() == Kind::FLOATINGPOINT_NEG)
-    {
-      NodeManager * nm = NodeManager::currentNM();
-      working = nm->mkNode(
-          Kind::FLOATINGPOINT_NEG,
-          nm->mkNode(Kind::FLOATINGPOINT_REM, working[0][0], working[1]));
-      // in contrast to other rewrites here, this requires rewrite again full
-      return RewriteResponse(REWRITE_AGAIN_FULL, working);
-    }
+  Node working = node;
 
-    return RewriteResponse(REWRITE_DONE, working);
+  // (fp.rem (fp.rem X Y) Y) == (fp.rem X Y)
+  if (working[0].getKind() == Kind::FLOATINGPOINT_REM &&  // short-cut matters!
+      working[0][1] == working[1])
+  {
+    working = working[0];
   }
 
-  RewriteResponse leqId(TNode node, bool isPreRewrite)
+  // Sign of the RHS does not matter
+  if (working[1].getKind() == Kind::FLOATINGPOINT_NEG
+      || working[1].getKind() == Kind::FLOATINGPOINT_ABS)
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_LEQ);
-
-    if (node[0] == node[1])
-    {
-      NodeManager *nm = NodeManager::currentNM();
-      return RewriteResponse(
-          isPreRewrite ? REWRITE_DONE : REWRITE_AGAIN_FULL,
-          nm->mkNode(Kind::NOT,
-                     nm->mkNode(Kind::FLOATINGPOINT_IS_NAN, node[0])));
-    }
-    return RewriteResponse(REWRITE_DONE, node);
+    working[1] = working[1][0];
   }
 
-  RewriteResponse ltId(TNode node, bool isPreRewrite)
+  // Lift negation out of the LHS so it can be cancelled out
+  if (working[0].getKind() == Kind::FLOATINGPOINT_NEG)
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_LT);
+    working = nm->mkNode(
+        Kind::FLOATINGPOINT_NEG,
+        nm->mkNode(Kind::FLOATINGPOINT_REM, working[0][0], working[1]));
+    // in contrast to other rewrites here, this requires rewrite again full
+    return RewriteResponse(REWRITE_AGAIN_FULL, working);
+  }
 
-    if (node[0] == node[1])
-    {
-      return RewriteResponse(REWRITE_DONE,
-                             NodeManager::currentNM()->mkConst(false));
-    }
-    return RewriteResponse(REWRITE_DONE, node);
+  return RewriteResponse(REWRITE_DONE, working);
+}
+
+RewriteResponse leqId(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_LEQ);
+
+  if (node[0] == node[1])
+  {
+    return RewriteResponse(
+        isPreRewrite ? REWRITE_DONE : REWRITE_AGAIN_FULL,
+        nm->mkNode(Kind::NOT, nm->mkNode(Kind::FLOATINGPOINT_IS_NAN, node[0])));
   }
+  return RewriteResponse(REWRITE_DONE, node);
+}
+
+RewriteResponse ltId(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_LT);
 
-  RewriteResponse toFPSignedBV(TNode node, bool isPreRewrite)
+  if (node[0] == node[1])
   {
-    Assert(!isPreRewrite);
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_SBV);
+    return RewriteResponse(REWRITE_DONE, nm->mkConst(false));
+  }
+  return RewriteResponse(REWRITE_DONE, node);
+}
 
-    /* symFPU does not allow conversions from signed bit-vector of size 1 */
-    if (node[1].getType().getBitVectorSize() == 1)
-    {
-      NodeManager* nm = NodeManager::currentNM();
-      Node op = nm->mkConst(FloatingPointToFPUnsignedBitVector(
-          node.getOperator().getConst<FloatingPointToFPSignedBitVector>()));
-      Node fromubv = nm->mkNode(op, node[0], node[1]);
-      return RewriteResponse(
-          REWRITE_AGAIN_FULL,
-          nm->mkNode(Kind::ITE,
-                     node[1].eqNode(bv::utils::mkOne(1)),
-                     nm->mkNode(Kind::FLOATINGPOINT_NEG, fromubv),
-                     fromubv));
-    }
-    return RewriteResponse(REWRITE_DONE, node);
+RewriteResponse toFPSignedBV(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(!isPreRewrite);
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_SBV);
+
+  /* symFPU does not allow conversions from signed bit-vector of size 1 */
+  if (node[1].getType().getBitVectorSize() == 1)
+  {
+    Node op = nm->mkConst(FloatingPointToFPUnsignedBitVector(
+        node.getOperator().getConst<FloatingPointToFPSignedBitVector>()));
+    Node fromubv = nm->mkNode(op, node[0], node[1]);
+    return RewriteResponse(
+        REWRITE_AGAIN_FULL,
+        nm->mkNode(Kind::ITE,
+                   node[1].eqNode(bv::utils::mkOne(1)),
+                   nm->mkNode(Kind::FLOATINGPOINT_NEG, fromubv),
+                   fromubv));
   }
+  return RewriteResponse(REWRITE_DONE, node);
+}
 
-  };  // namespace rewrite
+};  // namespace rewrite
 
 namespace constantFold {
 
-RewriteResponse fpLiteral(TNode node, bool isPreRewrite)
+RewriteResponse fpLiteral(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_FP);
 
@@ -394,35 +415,33 @@ RewriteResponse fpLiteral(TNode node, bool isPreRewrite)
   bv = bv.concat(node[2].getConst<BitVector>());
 
   // +1 to support the hidden bit
-  Node lit = NodeManager::currentNM()->mkConst(
-      FloatingPoint(node[1].getConst<BitVector>().getSize(),
-                    node[2].getConst<BitVector>().getSize() + 1,
-                    bv));
+  Node lit =
+      nm->mkConst(FloatingPoint(node[1].getConst<BitVector>().getSize(),
+                                node[2].getConst<BitVector>().getSize() + 1,
+                                bv));
 
   return RewriteResponse(REWRITE_DONE, lit);
 }
 
-RewriteResponse abs(TNode node, bool isPreRewrite)
+RewriteResponse abs(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_ABS);
   Assert(node.getNumChildren() == 1);
 
-  return RewriteResponse(REWRITE_DONE,
-                         NodeManager::currentNM()->mkConst(
-                             node[0].getConst<FloatingPoint>().absolute()));
+  return RewriteResponse(
+      REWRITE_DONE, nm->mkConst(node[0].getConst<FloatingPoint>().absolute()));
 }
 
-RewriteResponse neg(TNode node, bool isPreRewrite)
+RewriteResponse neg(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_NEG);
   Assert(node.getNumChildren() == 1);
 
-  return RewriteResponse(REWRITE_DONE,
-                         NodeManager::currentNM()->mkConst(
-                             node[0].getConst<FloatingPoint>().negate()));
+  return RewriteResponse(
+      REWRITE_DONE, nm->mkConst(node[0].getConst<FloatingPoint>().negate()));
 }
 
-RewriteResponse add(TNode node, bool isPreRewrite)
+RewriteResponse add(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_ADD);
   Assert(node.getNumChildren() == 3);
@@ -433,11 +452,10 @@ RewriteResponse add(TNode node, bool isPreRewrite)
 
   Assert(arg1.getSize() == arg2.getSize());
 
-  return RewriteResponse(REWRITE_DONE,
-                         NodeManager::currentNM()->mkConst(arg1.add(rm, arg2)));
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1.add(rm, arg2)));
 }
 
-RewriteResponse mult(TNode node, bool isPreRewrite)
+RewriteResponse mult(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_MULT);
   Assert(node.getNumChildren() == 3);
@@ -448,11 +466,10 @@ RewriteResponse mult(TNode node, bool isPreRewrite)
 
   Assert(arg1.getSize() == arg2.getSize());
 
-  return RewriteResponse(
-      REWRITE_DONE, NodeManager::currentNM()->mkConst(arg1.mult(rm, arg2)));
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1.mult(rm, arg2)));
 }
 
-RewriteResponse fma(TNode node, bool isPreRewrite)
+RewriteResponse fma(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_FMA);
   Assert(node.getNumChildren() == 4);
@@ -465,12 +482,10 @@ RewriteResponse fma(TNode node, bool isPreRewrite)
   Assert(arg1.getSize() == arg2.getSize());
   Assert(arg1.getSize() == arg3.getSize());
 
-  return RewriteResponse(
-      REWRITE_DONE,
-      NodeManager::currentNM()->mkConst(arg1.fma(rm, arg2, arg3)));
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1.fma(rm, arg2, arg3)));
 }
 
-RewriteResponse div(TNode node, bool isPreRewrite)
+RewriteResponse div(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_DIV);
   Assert(node.getNumChildren() == 3);
@@ -481,11 +496,10 @@ RewriteResponse div(TNode node, bool isPreRewrite)
 
   Assert(arg1.getSize() == arg2.getSize());
 
-  return RewriteResponse(REWRITE_DONE,
-                         NodeManager::currentNM()->mkConst(arg1.div(rm, arg2)));
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1.div(rm, arg2)));
 }
 
-RewriteResponse sqrt(TNode node, bool isPreRewrite)
+RewriteResponse sqrt(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_SQRT);
   Assert(node.getNumChildren() == 2);
@@ -493,11 +507,10 @@ RewriteResponse sqrt(TNode node, bool isPreRewrite)
   RoundingMode rm(node[0].getConst<RoundingMode>());
   FloatingPoint arg(node[1].getConst<FloatingPoint>());
 
-  return RewriteResponse(REWRITE_DONE,
-                         NodeManager::currentNM()->mkConst(arg.sqrt(rm)));
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg.sqrt(rm)));
 }
 
-RewriteResponse rti(TNode node, bool isPreRewrite)
+RewriteResponse rti(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_RTI);
   Assert(node.getNumChildren() == 2);
@@ -505,11 +518,10 @@ RewriteResponse rti(TNode node, bool isPreRewrite)
   RoundingMode rm(node[0].getConst<RoundingMode>());
   FloatingPoint arg(node[1].getConst<FloatingPoint>());
 
-  return RewriteResponse(REWRITE_DONE,
-                         NodeManager::currentNM()->mkConst(arg.rti(rm)));
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg.rti(rm)));
 }
 
-RewriteResponse rem(TNode node, bool isPreRewrite)
+RewriteResponse rem(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_REM);
   Assert(node.getNumChildren() == 2);
@@ -519,11 +531,10 @@ RewriteResponse rem(TNode node, bool isPreRewrite)
 
   Assert(arg1.getSize() == arg2.getSize());
 
-  return RewriteResponse(REWRITE_DONE,
-                         NodeManager::currentNM()->mkConst(arg1.rem(arg2)));
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1.rem(arg2)));
 }
 
-RewriteResponse min(TNode node, bool isPreRewrite)
+RewriteResponse min(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_MIN);
   Assert(node.getNumChildren() == 2);
@@ -537,7 +548,7 @@ RewriteResponse min(TNode node, bool isPreRewrite)
 
   if (res.second)
   {
-    Node lit = NodeManager::currentNM()->mkConst(res.first);
+    Node lit = nm->mkConst(res.first);
     return RewriteResponse(REWRITE_DONE, lit);
   }
   else
@@ -547,7 +558,7 @@ RewriteResponse min(TNode node, bool isPreRewrite)
   }
 }
 
-RewriteResponse max(TNode node, bool isPreRewrite)
+RewriteResponse max(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_MAX);
   Assert(node.getNumChildren() == 2);
@@ -561,7 +572,7 @@ RewriteResponse max(TNode node, bool isPreRewrite)
 
   if (res.second)
   {
-    Node lit = NodeManager::currentNM()->mkConst(res.first);
+    Node lit = nm->mkConst(res.first);
     return RewriteResponse(REWRITE_DONE, lit);
   }
   else
@@ -571,7 +582,7 @@ RewriteResponse max(TNode node, bool isPreRewrite)
   }
 }
 
-RewriteResponse minTotal(TNode node, bool isPreRewrite)
+RewriteResponse minTotal(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_MIN_TOTAL);
   Assert(node.getNumChildren() == 3);
@@ -587,7 +598,7 @@ RewriteResponse minTotal(TNode node, bool isPreRewrite)
     BitVector arg3(node[2].getConst<BitVector>());
 
     FloatingPoint folded(arg1.minTotal(arg2, arg3.isBitSet(0)));
-    Node lit = NodeManager::currentNM()->mkConst(folded);
+    Node lit = nm->mkConst(folded);
     return RewriteResponse(REWRITE_DONE, lit);
   }
   else
@@ -596,7 +607,7 @@ RewriteResponse minTotal(TNode node, bool isPreRewrite)
 
     if (res.second)
     {
-      Node lit = NodeManager::currentNM()->mkConst(res.first);
+      Node lit = nm->mkConst(res.first);
       return RewriteResponse(REWRITE_DONE, lit);
     }
     else
@@ -607,7 +618,7 @@ RewriteResponse minTotal(TNode node, bool isPreRewrite)
   }
 }
 
-RewriteResponse maxTotal(TNode node, bool isPreRewrite)
+RewriteResponse maxTotal(NodeManager* nm, TNode node, bool isPreRewrite)
 {
   Assert(node.getKind() == Kind::FLOATINGPOINT_MAX_TOTAL);
   Assert(node.getNumChildren() == 3);
@@ -623,7 +634,7 @@ RewriteResponse maxTotal(TNode node, bool isPreRewrite)
     BitVector arg3(node[2].getConst<BitVector>());
 
     FloatingPoint folded(arg1.maxTotal(arg2, arg3.isBitSet(0)));
-    Node lit = NodeManager::currentNM()->mkConst(folded);
+    Node lit = nm->mkConst(folded);
     return RewriteResponse(REWRITE_DONE, lit);
   }
   else
@@ -632,7 +643,7 @@ RewriteResponse maxTotal(TNode node, bool isPreRewrite)
 
     if (res.second)
     {
-      Node lit = NodeManager::currentNM()->mkConst(res.first);
+      Node lit = nm->mkConst(res.first);
       return RewriteResponse(REWRITE_DONE, lit);
     }
     else
@@ -643,1008 +654,1054 @@ RewriteResponse maxTotal(TNode node, bool isPreRewrite)
   }
 }
 
-  RewriteResponse equal (TNode node, bool isPreRewrite) {
-    Assert(node.getKind() == Kind::EQUAL);
-
-    // We should only get equalities of floating point or rounding mode types.
-    TypeNode tn = node[0].getType(true);
-
-    if (tn.isFloatingPoint()) {
-      FloatingPoint arg1(node[0].getConst<FloatingPoint>());
-      FloatingPoint arg2(node[1].getConst<FloatingPoint>());
-
-      Assert(arg1.getSize() == arg2.getSize());
-
-      return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(arg1 == arg2));
-
-    } else if (tn.isRoundingMode()) {
-      RoundingMode arg1(node[0].getConst<RoundingMode>());
-      RoundingMode arg2(node[1].getConst<RoundingMode>());
-    
-      return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(arg1 == arg2));
+RewriteResponse equal(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::EQUAL);
 
-    }
-    Unreachable() << "Equality of unknown type";
-  }
+  // We should only get equalities of floating point or rounding mode types.
+  TypeNode tn = node[0].getType(true);
 
-  RewriteResponse leq(TNode node, bool isPreRewrite)
+  if (tn.isFloatingPoint())
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_LEQ);
-    Assert(node.getNumChildren() == 2);
-
     FloatingPoint arg1(node[0].getConst<FloatingPoint>());
     FloatingPoint arg2(node[1].getConst<FloatingPoint>());
 
     Assert(arg1.getSize() == arg2.getSize());
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(arg1 <= arg2));
+    return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1 == arg2));
   }
-
-  RewriteResponse lt(TNode node, bool isPreRewrite)
+  else if (tn.isRoundingMode())
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_LT);
-    Assert(node.getNumChildren() == 2);
+    RoundingMode arg1(node[0].getConst<RoundingMode>());
+    RoundingMode arg2(node[1].getConst<RoundingMode>());
 
-    FloatingPoint arg1(node[0].getConst<FloatingPoint>());
-    FloatingPoint arg2(node[1].getConst<FloatingPoint>());
+    return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1 == arg2));
+  }
+  Unreachable() << "Equality of unknown type";
+}
 
-    Assert(arg1.getSize() == arg2.getSize());
+RewriteResponse leq(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_LEQ);
+  Assert(node.getNumChildren() == 2);
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(arg1 < arg2));
-  }
+  FloatingPoint arg1(node[0].getConst<FloatingPoint>());
+  FloatingPoint arg2(node[1].getConst<FloatingPoint>());
 
-  RewriteResponse isNormal(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_IS_NORMAL);
-    Assert(node.getNumChildren() == 1);
+  Assert(arg1.getSize() == arg2.getSize());
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(node[0].getConst<FloatingPoint>().isNormal()));
-  }
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1 <= arg2));
+}
 
-  RewriteResponse isSubnormal(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_IS_SUBNORMAL);
-    Assert(node.getNumChildren() == 1);
+RewriteResponse lt(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_LT);
+  Assert(node.getNumChildren() == 2);
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(node[0].getConst<FloatingPoint>().isSubnormal()));
-  }
+  FloatingPoint arg1(node[0].getConst<FloatingPoint>());
+  FloatingPoint arg2(node[1].getConst<FloatingPoint>());
 
-  RewriteResponse isZero(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_IS_ZERO);
-    Assert(node.getNumChildren() == 1);
+  Assert(arg1.getSize() == arg2.getSize());
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(node[0].getConst<FloatingPoint>().isZero()));
-  }
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(arg1 < arg2));
+}
 
-  RewriteResponse isInfinite(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_IS_INF);
-    Assert(node.getNumChildren() == 1);
+RewriteResponse isNormal(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_IS_NORMAL);
+  Assert(node.getNumChildren() == 1);
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(node[0].getConst<FloatingPoint>().isInfinite()));
-  }
+  return RewriteResponse(
+      REWRITE_DONE, nm->mkConst(node[0].getConst<FloatingPoint>().isNormal()));
+}
 
-  RewriteResponse isNaN(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_IS_NAN);
-    Assert(node.getNumChildren() == 1);
+RewriteResponse isSubnormal(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_IS_SUBNORMAL);
+  Assert(node.getNumChildren() == 1);
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(node[0].getConst<FloatingPoint>().isNaN()));
-  }
+  return RewriteResponse(
+      REWRITE_DONE,
+      nm->mkConst(node[0].getConst<FloatingPoint>().isSubnormal()));
+}
 
-  RewriteResponse isNegative(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_IS_NEG);
-    Assert(node.getNumChildren() == 1);
+RewriteResponse isZero(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_IS_ZERO);
+  Assert(node.getNumChildren() == 1);
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(node[0].getConst<FloatingPoint>().isNegative()));
-  }
+  return RewriteResponse(
+      REWRITE_DONE, nm->mkConst(node[0].getConst<FloatingPoint>().isZero()));
+}
 
-  RewriteResponse isPositive(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_IS_POS);
-    Assert(node.getNumChildren() == 1);
+RewriteResponse isInfinite(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_IS_INF);
+  Assert(node.getNumChildren() == 1);
 
-    return RewriteResponse(REWRITE_DONE, NodeManager::currentNM()->mkConst(node[0].getConst<FloatingPoint>().isPositive()));
-  }
+  return RewriteResponse(
+      REWRITE_DONE,
+      nm->mkConst(node[0].getConst<FloatingPoint>().isInfinite()));
+}
 
-  RewriteResponse convertFromIEEEBitVectorLiteral(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV);
+RewriteResponse isNaN(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_IS_NAN);
+  Assert(node.getNumChildren() == 1);
 
-    TNode op = node.getOperator();
-    const FloatingPointToFPIEEEBitVector &param = op.getConst<FloatingPointToFPIEEEBitVector>();
-    const BitVector &bv = node[0].getConst<BitVector>();
+  return RewriteResponse(
+      REWRITE_DONE, nm->mkConst(node[0].getConst<FloatingPoint>().isNaN()));
+}
 
-    Node lit = NodeManager::currentNM()->mkConst(
-        FloatingPoint(param.getSize().exponentWidth(),
-                      param.getSize().significandWidth(),
-                      bv));
+RewriteResponse isNegative(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_IS_NEG);
+  Assert(node.getNumChildren() == 1);
 
-    return RewriteResponse(REWRITE_DONE, lit);
-  }
+  return RewriteResponse(
+      REWRITE_DONE,
+      nm->mkConst(node[0].getConst<FloatingPoint>().isNegative()));
+}
 
-  RewriteResponse constantConvert(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_FP);
-    Assert(node.getNumChildren() == 2);
+RewriteResponse isPositive(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_IS_POS);
+  Assert(node.getNumChildren() == 1);
 
-    RoundingMode rm(node[0].getConst<RoundingMode>());
-    FloatingPoint arg1(node[1].getConst<FloatingPoint>());
-    FloatingPointToFPFloatingPoint info = node.getOperator().getConst<FloatingPointToFPFloatingPoint>();
+  return RewriteResponse(
+      REWRITE_DONE,
+      nm->mkConst(node[0].getConst<FloatingPoint>().isPositive()));
+}
 
-    return RewriteResponse(
-        REWRITE_DONE,
-        NodeManager::currentNM()->mkConst(arg1.convert(info.getSize(), rm)));
-  }
+RewriteResponse convertFromIEEEBitVectorLiteral(NodeManager* nm,
+                                                TNode node,
+                                                bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV);
 
-  RewriteResponse convertFromRealLiteral(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_REAL);
+  TNode op = node.getOperator();
+  const FloatingPointToFPIEEEBitVector& param =
+      op.getConst<FloatingPointToFPIEEEBitVector>();
+  const BitVector& bv = node[0].getConst<BitVector>();
 
-    TNode op = node.getOperator();
-    const FloatingPointSize& size =
-        op.getConst<FloatingPointToFPReal>().getSize();
+  Node lit = nm->mkConst(FloatingPoint(
+      param.getSize().exponentWidth(), param.getSize().significandWidth(), bv));
 
-    RoundingMode rm(node[0].getConst<RoundingMode>());
-    Rational arg(node[1].getConst<Rational>());
+  return RewriteResponse(REWRITE_DONE, lit);
+}
 
-    FloatingPoint res(size, rm, arg);
+RewriteResponse constantConvert(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_FP);
+  Assert(node.getNumChildren() == 2);
 
-    Node lit = NodeManager::currentNM()->mkConst(res);
+  RoundingMode rm(node[0].getConst<RoundingMode>());
+  FloatingPoint arg1(node[1].getConst<FloatingPoint>());
+  FloatingPointToFPFloatingPoint info =
+      node.getOperator().getConst<FloatingPointToFPFloatingPoint>();
 
-    return RewriteResponse(REWRITE_DONE, lit);
-  }
+  return RewriteResponse(REWRITE_DONE,
+                         nm->mkConst(arg1.convert(info.getSize(), rm)));
+}
 
-  RewriteResponse convertFromSBV(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_SBV);
+RewriteResponse convertFromRealLiteral(NodeManager* nm,
+                                       TNode node,
+                                       bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_REAL);
+
+  TNode op = node.getOperator();
+  const FloatingPointSize& size =
+      op.getConst<FloatingPointToFPReal>().getSize();
 
-    TNode op = node.getOperator();
-    const FloatingPointSize& size =
-        op.getConst<FloatingPointToFPSignedBitVector>().getSize();
+  RoundingMode rm(node[0].getConst<RoundingMode>());
+  Rational arg(node[1].getConst<Rational>());
+
+  FloatingPoint res(size, rm, arg);
+
+  Node lit = nm->mkConst(res);
+
+  return RewriteResponse(REWRITE_DONE, lit);
+}
+
+RewriteResponse convertFromSBV(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_SBV);
 
-    RoundingMode rm(node[0].getConst<RoundingMode>());
-    BitVector sbv(node[1].getConst<BitVector>());
+  TNode op = node.getOperator();
+  const FloatingPointSize& size =
+      op.getConst<FloatingPointToFPSignedBitVector>().getSize();
 
-    NodeManager* nm = NodeManager::currentNM();
+  RoundingMode rm(node[0].getConst<RoundingMode>());
+  BitVector sbv(node[1].getConst<BitVector>());
 
-    /* symFPU does not allow conversions from signed bit-vector of size 1 */
-    if (sbv.getSize() == 1)
+  /* symFPU does not allow conversions from signed bit-vector of size 1 */
+  if (sbv.getSize() == 1)
+  {
+    FloatingPoint fromubv(size, rm, sbv, false);
+    if (sbv.isBitSet(0))
     {
-      FloatingPoint fromubv(size, rm, sbv, false);
-      if (sbv.isBitSet(0))
-      {
-        return RewriteResponse(REWRITE_DONE, nm->mkConst(fromubv.negate()));
-      }
-      return RewriteResponse(REWRITE_DONE, nm->mkConst(fromubv));
+      return RewriteResponse(REWRITE_DONE, nm->mkConst(fromubv.negate()));
     }
-
-    return RewriteResponse(REWRITE_DONE,
-                           nm->mkConst(FloatingPoint(size, rm, sbv, true)));
+    return RewriteResponse(REWRITE_DONE, nm->mkConst(fromubv));
   }
 
-  RewriteResponse convertFromUBV(TNode node, bool isPreRewrite)
+  return RewriteResponse(REWRITE_DONE,
+                         nm->mkConst(FloatingPoint(size, rm, sbv, true)));
+}
+
+RewriteResponse convertFromUBV(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_UBV);
+
+  TNode op = node.getOperator();
+  const FloatingPointSize& size =
+      op.getConst<FloatingPointToFPUnsignedBitVector>().getSize();
+
+  RoundingMode rm(node[0].getConst<RoundingMode>());
+  BitVector arg(node[1].getConst<BitVector>());
+
+  FloatingPoint res(size, rm, arg, false);
+
+  Node lit = nm->mkConst(res);
+
+  return RewriteResponse(REWRITE_DONE, lit);
+}
+
+RewriteResponse convertToUBV(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_UBV);
+
+  TNode op = node.getOperator();
+  const BitVectorSize& size = op.getConst<FloatingPointToUBV>().d_bv_size;
+
+  RoundingMode rm(node[0].getConst<RoundingMode>());
+  FloatingPoint arg(node[1].getConst<FloatingPoint>());
+
+  FloatingPoint::PartialBitVector res(arg.convertToBV(size, rm, false));
+
+  if (res.second)
+  {
+    Node lit = nm->mkConst(res.first);
+    return RewriteResponse(REWRITE_DONE, lit);
+  }
+  else
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_FP_FROM_UBV);
+    // Can't constant fold the underspecified case
+    return RewriteResponse(REWRITE_DONE, node);
+  }
+}
 
-    TNode op = node.getOperator();
-    const FloatingPointSize& size =
-        op.getConst<FloatingPointToFPUnsignedBitVector>().getSize();
+RewriteResponse convertToSBV(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_SBV);
 
-    RoundingMode rm(node[0].getConst<RoundingMode>());
-    BitVector arg(node[1].getConst<BitVector>());
+  TNode op = node.getOperator();
+  const BitVectorSize& size = op.getConst<FloatingPointToSBV>().d_bv_size;
 
-    FloatingPoint res(size, rm, arg, false);
+  RoundingMode rm(node[0].getConst<RoundingMode>());
+  FloatingPoint arg(node[1].getConst<FloatingPoint>());
 
-    Node lit = NodeManager::currentNM()->mkConst(res);
+  FloatingPoint::PartialBitVector res(arg.convertToBV(size, rm, true));
 
+  if (res.second)
+  {
+    Node lit = nm->mkConst(res.first);
     return RewriteResponse(REWRITE_DONE, lit);
   }
+  else
+  {
+    // Can't constant fold the underspecified case
+    return RewriteResponse(REWRITE_DONE, node);
+  }
+}
+
+RewriteResponse convertToReal(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_REAL);
 
-  RewriteResponse convertToUBV(TNode node, bool isPreRewrite)
+  FloatingPoint arg(node[0].getConst<FloatingPoint>());
+
+  FloatingPoint::PartialRational res(arg.convertToRational());
+
+  if (res.second)
+  {
+    Node lit = nm->mkConstReal(res.first);
+    return RewriteResponse(REWRITE_DONE, lit);
+  }
+  else
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_UBV);
+    // Can't constant fold the underspecified case
+    return RewriteResponse(REWRITE_DONE, node);
+  }
+}
 
-    TNode op = node.getOperator();
-    const BitVectorSize& size = op.getConst<FloatingPointToUBV>().d_bv_size;
+RewriteResponse convertToUBVTotal(NodeManager* nm,
+                                  TNode node,
+                                  bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_UBV_TOTAL);
+
+  TNode op = node.getOperator();
+  const BitVectorSize& size = op.getConst<FloatingPointToUBVTotal>().d_bv_size;
+
+  RoundingMode rm(node[0].getConst<RoundingMode>());
+  FloatingPoint arg(node[1].getConst<FloatingPoint>());
 
-    RoundingMode rm(node[0].getConst<RoundingMode>());
-    FloatingPoint arg(node[1].getConst<FloatingPoint>());
+  // Can be called with the third argument non-constant
+  if (node[2].getMetaKind() == kind::metakind::CONSTANT)
+  {
+    BitVector partialValue(node[2].getConst<BitVector>());
 
+    BitVector folded(arg.convertToBVTotal(size, rm, false, partialValue));
+    Node lit = nm->mkConst(folded);
+    return RewriteResponse(REWRITE_DONE, lit);
+  }
+  else
+  {
     FloatingPoint::PartialBitVector res(arg.convertToBV(size, rm, false));
 
-    if (res.second) {
-      Node lit = NodeManager::currentNM()->mkConst(res.first);
+    if (res.second)
+    {
+      Node lit = nm->mkConst(res.first);
       return RewriteResponse(REWRITE_DONE, lit);
-    } else {
+    }
+    else
+    {
       // Can't constant fold the underspecified case
       return RewriteResponse(REWRITE_DONE, node);
     }
   }
+}
 
-  RewriteResponse convertToSBV(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_SBV);
+RewriteResponse convertToSBVTotal(NodeManager* nm,
+                                  TNode node,
+                                  bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_SBV_TOTAL);
 
-    TNode op = node.getOperator();
-    const BitVectorSize& size = op.getConst<FloatingPointToSBV>().d_bv_size;
+  TNode op = node.getOperator();
+  const BitVectorSize& size = op.getConst<FloatingPointToSBVTotal>().d_bv_size;
 
-    RoundingMode rm(node[0].getConst<RoundingMode>());
-    FloatingPoint arg(node[1].getConst<FloatingPoint>());
+  RoundingMode rm(node[0].getConst<RoundingMode>());
+  FloatingPoint arg(node[1].getConst<FloatingPoint>());
 
+  // Can be called with the third argument non-constant
+  if (node[2].getMetaKind() == kind::metakind::CONSTANT)
+  {
+    BitVector partialValue(node[2].getConst<BitVector>());
+
+    BitVector folded(arg.convertToBVTotal(size, rm, true, partialValue));
+    Node lit = nm->mkConst(folded);
+    return RewriteResponse(REWRITE_DONE, lit);
+  }
+  else
+  {
     FloatingPoint::PartialBitVector res(arg.convertToBV(size, rm, true));
 
-    if (res.second) {
-      Node lit = NodeManager::currentNM()->mkConst(res.first);
+    if (res.second)
+    {
+      Node lit = nm->mkConst(res.first);
       return RewriteResponse(REWRITE_DONE, lit);
-    } else {
+    }
+    else
+    {
       // Can't constant fold the underspecified case
       return RewriteResponse(REWRITE_DONE, node);
     }
   }
+}
 
-  RewriteResponse convertToReal(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_REAL);
+RewriteResponse convertToRealTotal(NodeManager* nm,
+                                   TNode node,
+                                   bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_TO_REAL_TOTAL);
+
+  FloatingPoint arg(node[0].getConst<FloatingPoint>());
 
-    FloatingPoint arg(node[0].getConst<FloatingPoint>());
+  // Can be called with the third argument non-constant
+  if (node[1].getMetaKind() == kind::metakind::CONSTANT)
+  {
+    Rational partialValue(node[1].getConst<Rational>());
 
+    Rational folded(arg.convertToRationalTotal(partialValue));
+    Node lit = nm->mkConstReal(folded);
+    return RewriteResponse(REWRITE_DONE, lit);
+  }
+  else
+  {
     FloatingPoint::PartialRational res(arg.convertToRational());
 
-    if (res.second) {
-      Node lit = NodeManager::currentNM()->mkConstReal(res.first);
+    if (res.second)
+    {
+      Node lit = nm->mkConstReal(res.first);
       return RewriteResponse(REWRITE_DONE, lit);
-    } else {
+    }
+    else
+    {
       // Can't constant fold the underspecified case
       return RewriteResponse(REWRITE_DONE, node);
     }
   }
+}
 
-  RewriteResponse convertToUBVTotal(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_UBV_TOTAL);
-
-    TNode op = node.getOperator();
-    const BitVectorSize& size =
-        op.getConst<FloatingPointToUBVTotal>().d_bv_size;
-
-    RoundingMode rm(node[0].getConst<RoundingMode>());
-    FloatingPoint arg(node[1].getConst<FloatingPoint>());
-
-    // Can be called with the third argument non-constant
-    if (node[2].getMetaKind() == kind::metakind::CONSTANT) {
-      BitVector partialValue(node[2].getConst<BitVector>());
-
-      BitVector folded(arg.convertToBVTotal(size, rm, false, partialValue));
-      Node lit = NodeManager::currentNM()->mkConst(folded);
-      return RewriteResponse(REWRITE_DONE, lit);
+RewriteResponse componentFlag(NodeManager* nm, TNode node, bool isPreRewrite)
+{
+  Kind k = node.getKind();
 
-    } else {
-      FloatingPoint::PartialBitVector res(arg.convertToBV(size, rm, false));
+  Assert((k == Kind::FLOATINGPOINT_COMPONENT_NAN)
+         || (k == Kind::FLOATINGPOINT_COMPONENT_INF)
+         || (k == Kind::FLOATINGPOINT_COMPONENT_ZERO)
+         || (k == Kind::FLOATINGPOINT_COMPONENT_SIGN));
 
-      if (res.second) {
-	Node lit = NodeManager::currentNM()->mkConst(res.first);
-	return RewriteResponse(REWRITE_DONE, lit);
-      } else {
-	// Can't constant fold the underspecified case
-	return RewriteResponse(REWRITE_DONE, node);
-      }
-    }
-  }
+  FloatingPoint arg0(node[0].getConst<FloatingPoint>());
 
-  RewriteResponse convertToSBVTotal(TNode node, bool isPreRewrite)
+  bool result;
+  switch (k)
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_SBV_TOTAL);
-
-    TNode op = node.getOperator();
-    const BitVectorSize& size =
-        op.getConst<FloatingPointToSBVTotal>().d_bv_size;
-
-    RoundingMode rm(node[0].getConst<RoundingMode>());
-    FloatingPoint arg(node[1].getConst<FloatingPoint>());
+    case Kind::FLOATINGPOINT_COMPONENT_NAN: result = arg0.isNaN(); break;
+    case Kind::FLOATINGPOINT_COMPONENT_INF: result = arg0.isInfinite(); break;
+    case Kind::FLOATINGPOINT_COMPONENT_ZERO: result = arg0.isZero(); break;
+    case Kind::FLOATINGPOINT_COMPONENT_SIGN: result = arg0.getSign(); break;
+    default: Unreachable() << "Unknown kind used in componentFlag"; break;
+  }
 
-    // Can be called with the third argument non-constant
-    if (node[2].getMetaKind() == kind::metakind::CONSTANT) {
-      BitVector partialValue(node[2].getConst<BitVector>());
+  BitVector res(1U, (result) ? 1U : 0U);
 
-      BitVector folded(arg.convertToBVTotal(size, rm, true, partialValue));
-      Node lit = NodeManager::currentNM()->mkConst(folded);
-      return RewriteResponse(REWRITE_DONE, lit);
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(res));
+}
 
-    } else {
-      FloatingPoint::PartialBitVector res(arg.convertToBV(size, rm, true));
+RewriteResponse componentExponent(NodeManager* nm,
+                                  TNode node,
+                                  bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_COMPONENT_EXPONENT);
 
-      if (res.second) {
-	Node lit = NodeManager::currentNM()->mkConst(res.first);
-	return RewriteResponse(REWRITE_DONE, lit);
-      } else {
-	// Can't constant fold the underspecified case
-	return RewriteResponse(REWRITE_DONE, node);
-      }
-    }
-  }
+  FloatingPoint arg0(node[0].getConst<FloatingPoint>());
 
-  RewriteResponse convertToRealTotal(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_TO_REAL_TOTAL);
+  // \todo Add a proper interface for this sort of thing to FloatingPoint #1915
+  return RewriteResponse(REWRITE_DONE,
+                         nm->mkConst((BitVector)arg0.getExponent()));
+}
 
-    FloatingPoint arg(node[0].getConst<FloatingPoint>());
+RewriteResponse componentSignificand(NodeManager* nm,
+                                     TNode node,
+                                     bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND);
 
-    // Can be called with the third argument non-constant
-    if (node[1].getMetaKind() == kind::metakind::CONSTANT) {
-      Rational partialValue(node[1].getConst<Rational>());
+  FloatingPoint arg0(node[0].getConst<FloatingPoint>());
 
-      Rational folded(arg.convertToRationalTotal(partialValue));
-      Node lit = NodeManager::currentNM()->mkConstReal(folded);
-      return RewriteResponse(REWRITE_DONE, lit);
+  return RewriteResponse(REWRITE_DONE,
+                         nm->mkConst((BitVector)arg0.getSignificand()));
+}
 
-    } else {
-      FloatingPoint::PartialRational res(arg.convertToRational());
+RewriteResponse roundingModeBitBlast(NodeManager* nm,
+                                     TNode node,
+                                     bool isPreRewrite)
+{
+  Assert(node.getKind() == Kind::ROUNDINGMODE_BITBLAST);
 
-      if (res.second) {
-        Node lit = NodeManager::currentNM()->mkConstReal(res.first);
-        return RewriteResponse(REWRITE_DONE, lit);
-      } else {
-	// Can't constant fold the underspecified case
-	return RewriteResponse(REWRITE_DONE, node);
-      }
-    }
-  }
+  BitVector value;
 
-  RewriteResponse componentFlag(TNode node, bool isPreRewrite)
+  /* \todo fix the numbering of rounding modes so this doesn't need
+   * to call symfpu at all and remove the dependency on fp_converter.h #1915 */
+  RoundingMode arg0(node[0].getConst<RoundingMode>());
+  switch (arg0)
   {
-    Kind k = node.getKind();
+    case RoundingMode::ROUND_NEAREST_TIES_TO_EVEN:
+      value = symfpuSymbolic::traits::RNE().getConst<BitVector>();
+      break;
 
-    Assert((k == Kind::FLOATINGPOINT_COMPONENT_NAN)
-           || (k == Kind::FLOATINGPOINT_COMPONENT_INF)
-           || (k == Kind::FLOATINGPOINT_COMPONENT_ZERO)
-           || (k == Kind::FLOATINGPOINT_COMPONENT_SIGN));
+    case RoundingMode::ROUND_NEAREST_TIES_TO_AWAY:
+      value = symfpuSymbolic::traits::RNA().getConst<BitVector>();
+      break;
 
-    FloatingPoint arg0(node[0].getConst<FloatingPoint>());
+    case RoundingMode::ROUND_TOWARD_POSITIVE:
+      value = symfpuSymbolic::traits::RTP().getConst<BitVector>();
+      break;
 
-    bool result;
-    switch (k)
-    {
-      case Kind::FLOATINGPOINT_COMPONENT_NAN: result = arg0.isNaN(); break;
-      case Kind::FLOATINGPOINT_COMPONENT_INF: result = arg0.isInfinite(); break;
-      case Kind::FLOATINGPOINT_COMPONENT_ZERO: result = arg0.isZero(); break;
-      case Kind::FLOATINGPOINT_COMPONENT_SIGN: result = arg0.getSign(); break;
-      default: Unreachable() << "Unknown kind used in componentFlag"; break;
-    }
+    case RoundingMode::ROUND_TOWARD_NEGATIVE:
+      value = symfpuSymbolic::traits::RTN().getConst<BitVector>();
+      break;
 
-    BitVector res(1U, (result) ? 1U : 0U);
+    case RoundingMode::ROUND_TOWARD_ZERO:
+      value = symfpuSymbolic::traits::RTZ().getConst<BitVector>();
+      break;
 
-    return RewriteResponse(REWRITE_DONE,
-                           NodeManager::currentNM()->mkConst(res));
+    default:
+      Unreachable() << "Unknown rounding mode in roundingModeBitBlast";
+      break;
   }
+  return RewriteResponse(REWRITE_DONE, nm->mkConst(value));
+}
 
-  RewriteResponse componentExponent(TNode node, bool isPreRewrite)
-  {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_COMPONENT_EXPONENT);
-
-    FloatingPoint arg0(node[0].getConst<FloatingPoint>());
+};  // namespace constantFold
 
-    // \todo Add a proper interface for this sort of thing to FloatingPoint #1915
-    return RewriteResponse(
-        REWRITE_DONE,
-        NodeManager::currentNM()->mkConst((BitVector)arg0.getExponent())
-    );
+/**
+ * Initialize the rewriter.
+ */
+TheoryFpRewriter::TheoryFpRewriter(NodeManager* nm, context::UserContext* u)
+    : TheoryRewriter(nm), d_fpExpDef()
+{
+  /* Set up the pre-rewrite dispatch table */
+  for (uint32_t i = 0; i < static_cast<uint32_t>(Kind::LAST_KIND); ++i)
+  {
+    d_preRewriteTable[i] = rewrite::notFP;
   }
 
-  RewriteResponse componentSignificand(TNode node, bool isPreRewrite)
+  /******** Constants ********/
+  /* No rewriting possible for constants */
+  d_preRewriteTable[static_cast<uint32_t>(Kind::CONST_FLOATINGPOINT)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::CONST_ROUNDINGMODE)] =
+      rewrite::identity;
+
+  /******** Sorts(?) ********/
+  /* These kinds should only appear in types */
+  // d_preRewriteTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_TYPE)] =
+  // rewrite::type;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TYPE)] =
+      rewrite::type;
+
+  /******** Operations ********/
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FP)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ABS)] =
+      rewrite::compactAbs;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_NEG)] =
+      rewrite::removeDoubleNegation;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ADD)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SUB)] =
+      rewrite::convertSubtractionToAddition;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MULT)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_DIV)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FMA)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SQRT)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_REM)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_RTI)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN)] =
+      rewrite::compactMinMax;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX)] =
+      rewrite::compactMinMax;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN_TOTAL)] =
+      rewrite::compactMinMax;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX_TOTAL)] =
+      rewrite::compactMinMax;
+
+  /******** Comparisons ********/
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_EQ)] =
+      rewrite::then<rewrite::breakChain, rewrite::ieeeEqToEq>;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LEQ)] =
+      rewrite::then<rewrite::breakChain, rewrite::leqId>;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LT)] =
+      rewrite::then<rewrite::breakChain, rewrite::ltId>;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_GEQ)] =
+      rewrite::then<rewrite::breakChain, rewrite::geqToleq>;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_GT)] =
+      rewrite::then<rewrite::breakChain, rewrite::gtTolt>;
+
+  /******** Classifications ********/
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NORMAL)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_SUBNORMAL)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_ZERO)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_INF)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NAN)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NEG)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_POS)] =
+      rewrite::identity;
+
+  /******** Conversions ********/
+  d_preRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV)] = rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_FP_FROM_FP)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_REAL)] = rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_FP_FROM_SBV)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_FP_FROM_UBV)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_REAL)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV_TOTAL)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV_TOTAL)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_REAL_TOTAL)] =
+      rewrite::identity;
+
+  /******** Equality ********/
+
+  d_preRewriteTable[static_cast<uint32_t>(Kind::EQUAL)] = rewrite::equal;
+
+  /******** Components for bit-blasting ********/
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_COMPONENT_NAN)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_COMPONENT_INF)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_COMPONENT_ZERO)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_COMPONENT_SIGN)] =
+      rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_EXPONENT)] = rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND)] = rewrite::identity;
+  d_preRewriteTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_BITBLAST)] =
+      rewrite::identity;
+
+  /* Set up the post-rewrite dispatch table */
+  for (uint32_t i = 0; i < static_cast<uint32_t>(Kind::LAST_KIND); ++i)
   {
-    Assert(node.getKind() == Kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND);
-
-    FloatingPoint arg0(node[0].getConst<FloatingPoint>());
-
-    return RewriteResponse(
-        REWRITE_DONE,
-        NodeManager::currentNM()->mkConst((BitVector)arg0.getSignificand())
-    );
+    d_postRewriteTable[i] = rewrite::notFP;
   }
 
-  RewriteResponse roundingModeBitBlast(TNode node, bool isPreRewrite)
+  /******** Constants ********/
+  /* No rewriting possible for constants */
+  d_postRewriteTable[static_cast<uint32_t>(Kind::CONST_FLOATINGPOINT)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::CONST_ROUNDINGMODE)] =
+      rewrite::identity;
+
+  /******** Sorts(?) ********/
+  /* These kinds should only appear in types */
+  // d_postRewriteTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_TYPE)] =
+  // rewrite::type;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TYPE)] =
+      rewrite::type;
+
+  /******** Operations ********/
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FP)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ABS)] =
+      rewrite::compactAbs;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_NEG)] =
+      rewrite::removeDoubleNegation;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ADD)] =
+      rewrite::reorderBinaryOperation;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SUB)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MULT)] =
+      rewrite::reorderBinaryOperation;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_DIV)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FMA)] =
+      rewrite::reorderFMA;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SQRT)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_REM)] =
+      rewrite::compactRemainder;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_RTI)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN)] =
+      rewrite::compactMinMax;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX)] =
+      rewrite::compactMinMax;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN_TOTAL)] =
+      rewrite::compactMinMax;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX_TOTAL)] =
+      rewrite::compactMinMax;
+
+  /******** Comparisons ********/
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_EQ)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LEQ)] =
+      rewrite::leqId;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LT)] =
+      rewrite::ltId;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_GEQ)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_GT)] =
+      rewrite::identity;
+
+  /******** Classifications ********/
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NORMAL)] =
+      rewrite::removeSignOperations;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_SUBNORMAL)] =
+      rewrite::removeSignOperations;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_ZERO)] =
+      rewrite::removeSignOperations;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_INF)] =
+      rewrite::removeSignOperations;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NAN)] =
+      rewrite::removeSignOperations;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NEG)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_POS)] =
+      rewrite::identity;
+
+  /******** Conversions ********/
+  d_postRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV)] = rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_FP_FROM_FP)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_REAL)] = rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_SBV)] = rewrite::toFPSignedBV;
+  d_postRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_UBV)] = rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_REAL)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV_TOTAL)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV_TOTAL)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_REAL_TOTAL)] =
+      rewrite::identity;
+
+  /******** Variables ********/
+  d_postRewriteTable[static_cast<uint32_t>(Kind::VARIABLE)] = rewrite::variable;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::BOUND_VARIABLE)] =
+      rewrite::variable;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::SKOLEM)] = rewrite::variable;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::INST_CONSTANT)] =
+      rewrite::variable;
+
+  d_postRewriteTable[static_cast<uint32_t>(Kind::EQUAL)] = rewrite::equal;
+
+  /******** Components for bit-blasting ********/
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_COMPONENT_NAN)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_COMPONENT_INF)] =
+      rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_ZERO)] = rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_SIGN)] = rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_EXPONENT)] = rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND)] = rewrite::identity;
+  d_postRewriteTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_BITBLAST)] =
+      rewrite::identity;
+
+  /* Set up the post-rewrite constant fold table */
+  for (uint32_t i = 0; i < static_cast<uint32_t>(Kind::LAST_KIND); ++i)
   {
-    Assert(node.getKind() == Kind::ROUNDINGMODE_BITBLAST);
-
-    BitVector value;
-
-    /* \todo fix the numbering of rounding modes so this doesn't need
-     * to call symfpu at all and remove the dependency on fp_converter.h #1915 */
-    RoundingMode arg0(node[0].getConst<RoundingMode>());
-    switch (arg0)
-    {
-      case RoundingMode::ROUND_NEAREST_TIES_TO_EVEN:
-        value = symfpuSymbolic::traits::RNE().getConst<BitVector>();
-        break;
-
-      case RoundingMode::ROUND_NEAREST_TIES_TO_AWAY:
-        value = symfpuSymbolic::traits::RNA().getConst<BitVector>();
-        break;
-
-      case RoundingMode::ROUND_TOWARD_POSITIVE:
-        value = symfpuSymbolic::traits::RTP().getConst<BitVector>();
-        break;
+    // Note that this is identity, not notFP
+    // Constant folding is called after post-rewrite
+    // So may have to deal with cases of things being
+    // re-written to non-floating-point sorts (i.e. true).
+    d_constantFoldTable[i] = rewrite::identity;
+  }
 
-      case RoundingMode::ROUND_TOWARD_NEGATIVE:
-        value = symfpuSymbolic::traits::RTN().getConst<BitVector>();
-        break;
+  /******** Constants ********/
+  /* Already folded! */
+  d_constantFoldTable[static_cast<uint32_t>(Kind::CONST_FLOATINGPOINT)] =
+      rewrite::identity;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::CONST_ROUNDINGMODE)] =
+      rewrite::identity;
+
+  /******** Sorts(?) ********/
+  /* These kinds should only appear in types */
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TYPE)] =
+      rewrite::type;
+
+  /******** Operations ********/
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FP)] =
+      constantFold::fpLiteral;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ABS)] =
+      constantFold::abs;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_NEG)] =
+      constantFold::neg;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ADD)] =
+      constantFold::add;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MULT)] =
+      constantFold::mult;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_DIV)] =
+      constantFold::div;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FMA)] =
+      constantFold::fma;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SQRT)] =
+      constantFold::sqrt;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_REM)] =
+      constantFold::rem;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_RTI)] =
+      constantFold::rti;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN)] =
+      constantFold::min;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX)] =
+      constantFold::max;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN_TOTAL)] =
+      constantFold::minTotal;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX_TOTAL)] =
+      constantFold::maxTotal;
+
+  /******** Comparisons ********/
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LEQ)] =
+      constantFold::leq;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LT)] =
+      constantFold::lt;
+
+  /******** Classifications ********/
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NORMAL)] =
+      constantFold::isNormal;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_SUBNORMAL)] =
+      constantFold::isSubnormal;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_ZERO)] =
+      constantFold::isZero;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_INF)] =
+      constantFold::isInfinite;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NAN)] =
+      constantFold::isNaN;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NEG)] =
+      constantFold::isNegative;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_POS)] =
+      constantFold::isPositive;
+
+  /******** Conversions ********/
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV)] =
+      constantFold::convertFromIEEEBitVectorLiteral;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_FP)] = constantFold::constantConvert;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_REAL)] =
+      constantFold::convertFromRealLiteral;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_SBV)] = constantFold::convertFromSBV;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_FP_FROM_UBV)] = constantFold::convertFromUBV;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV)] =
+      constantFold::convertToUBV;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV)] =
+      constantFold::convertToSBV;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_REAL)] =
+      constantFold::convertToReal;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV_TOTAL)] =
+      constantFold::convertToUBVTotal;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV_TOTAL)] =
+      constantFold::convertToSBVTotal;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_TO_REAL_TOTAL)] = constantFold::convertToRealTotal;
+
+  /******** Variables ********/
+  d_constantFoldTable[static_cast<uint32_t>(Kind::VARIABLE)] =
+      rewrite::variable;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::BOUND_VARIABLE)] =
+      rewrite::variable;
+
+  d_constantFoldTable[static_cast<uint32_t>(Kind::EQUAL)] = constantFold::equal;
+
+  /******** Components for bit-blasting ********/
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_NAN)] = constantFold::componentFlag;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_INF)] = constantFold::componentFlag;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_ZERO)] = constantFold::componentFlag;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_SIGN)] = constantFold::componentFlag;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_EXPONENT)] =
+      constantFold::componentExponent;
+  d_constantFoldTable[static_cast<uint32_t>(
+      Kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND)] =
+      constantFold::componentSignificand;
+  d_constantFoldTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_BITBLAST)] =
+      constantFold::roundingModeBitBlast;
+}
 
-      case RoundingMode::ROUND_TOWARD_ZERO:
-        value = symfpuSymbolic::traits::RTZ().getConst<BitVector>();
-        break;
+/**
+ * Rewrite a node into the normal form for the theory of fp
+ * in pre-order (really topological order)---meaning that the
+ * children may not be in the normal form.  This is an optimization
+ * for theories with cancelling terms (e.g., 0 * (big-nasty-expression)
+ * in arithmetic rewrites to 0 without the need to look at the big
+ * nasty expression).  Since it's only an optimization, the
+ * implementation here can do nothing.
+ */
 
-      default:
-        Unreachable() << "Unknown rounding mode in roundingModeBitBlast";
-        break;
-    }
-    return RewriteResponse(REWRITE_DONE,
-                           NodeManager::currentNM()->mkConst(value));
+RewriteResponse TheoryFpRewriter::preRewrite(TNode node)
+{
+  Trace("fp-rewrite") << "TheoryFpRewriter::preRewrite(): " << node
+                      << std::endl;
+  RewriteResponse res =
+      d_preRewriteTable[static_cast<uint32_t>(node.getKind())](
+          d_nm, node, true);
+  if (res.d_node != node)
+  {
+    Trace("fp-rewrite") << "TheoryFpRewriter::preRewrite(): before " << node
+                        << std::endl;
+    Trace("fp-rewrite") << "TheoryFpRewriter::preRewrite(): after  "
+                        << res.d_node << std::endl;
   }
+  return res;
+}
 
-  };  // namespace constantFold
+/**
+ * Rewrite a node into the normal form for the theory of fp.
+ * Called in post-order (really reverse-topological order) when
+ * traversing the expression DAG during rewriting.  This is the
+ * main function of the rewriter, and because of the ordering,
+ * it can assume its children are all rewritten already.
+ *
+ * This function can return one of three rewrite response codes
+ * along with the rewritten node:
+ *
+ *   REWRITE_DONE indicates that no more rewriting is needed.
+ *   REWRITE_AGAIN means that the top-level expression should be
+ *     rewritten again, but that its children are in final form.
+ *   REWRITE_AGAIN_FULL means that the entire returned expression
+ *     should be rewritten again (top-down with preRewrite(), then
+ *     bottom-up with postRewrite()).
+ *
+ * Even if this function returns REWRITE_DONE, if the returned
+ * expression belongs to a different theory, it will be fully
+ * rewritten by that theory's rewriter.
+ */
 
-  /**
-   * Initialize the rewriter.
-   */
-  TheoryFpRewriter::TheoryFpRewriter(NodeManager* nm, context::UserContext* u)
-      : TheoryRewriter(nm), d_fpExpDef()
+RewriteResponse TheoryFpRewriter::postRewrite(TNode node)
+{
+  Trace("fp-rewrite") << "TheoryFpRewriter::postRewrite(): " << node
+                      << std::endl;
+  RewriteResponse res =
+      d_postRewriteTable[static_cast<uint32_t>(node.getKind())](
+          d_nm, node, false);
+  if (res.d_node != node)
   {
-    /* Set up the pre-rewrite dispatch table */
-    for (uint32_t i = 0; i < static_cast<uint32_t>(Kind::LAST_KIND); ++i)
-    {
-      d_preRewriteTable[i] = rewrite::notFP;
-    }
-
-    /******** Constants ********/
-    /* No rewriting possible for constants */
-    d_preRewriteTable[static_cast<uint32_t>(Kind::CONST_FLOATINGPOINT)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::CONST_ROUNDINGMODE)] =
-        rewrite::identity;
-
-    /******** Sorts(?) ********/
-    /* These kinds should only appear in types */
-    // d_preRewriteTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_TYPE)] =
-    // rewrite::type;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TYPE)] =
-        rewrite::type;
-
-    /******** Operations ********/
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FP)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ABS)] =
-        rewrite::compactAbs;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_NEG)] =
-        rewrite::removeDoubleNegation;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ADD)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SUB)] =
-        rewrite::convertSubtractionToAddition;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MULT)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_DIV)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FMA)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SQRT)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_REM)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_RTI)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN)] =
-        rewrite::compactMinMax;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX)] =
-        rewrite::compactMinMax;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN_TOTAL)] =
-        rewrite::compactMinMax;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX_TOTAL)] =
-        rewrite::compactMinMax;
-
-    /******** Comparisons ********/
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_EQ)] =
-        rewrite::then<rewrite::breakChain, rewrite::ieeeEqToEq>;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LEQ)] =
-        rewrite::then<rewrite::breakChain, rewrite::leqId>;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LT)] =
-        rewrite::then<rewrite::breakChain, rewrite::ltId>;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_GEQ)] =
-        rewrite::then<rewrite::breakChain, rewrite::geqToleq>;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_GT)] =
-        rewrite::then<rewrite::breakChain, rewrite::gtTolt>;
-
-    /******** Classifications ********/
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NORMAL)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_SUBNORMAL)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_ZERO)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_INF)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NAN)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NEG)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_POS)] =
-        rewrite::identity;
-
-    /******** Conversions ********/
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_FP)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_REAL)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_SBV)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_UBV)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_REAL)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV_TOTAL)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV_TOTAL)] =
-        rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_REAL_TOTAL)] = rewrite::identity;
-
-    /******** Equality ********/
-
-    d_preRewriteTable[static_cast<uint32_t>(Kind::EQUAL)] = rewrite::equal;
-
-    /******** Components for bit-blasting ********/
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_NAN)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_INF)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_ZERO)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_SIGN)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_EXPONENT)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND)] = rewrite::identity;
-    d_preRewriteTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_BITBLAST)] =
-        rewrite::identity;
-
-    /* Set up the post-rewrite dispatch table */
-    for (uint32_t i = 0; i < static_cast<uint32_t>(Kind::LAST_KIND); ++i)
-    {
-      d_postRewriteTable[i] = rewrite::notFP;
-    }
-
-    /******** Constants ********/
-    /* No rewriting possible for constants */
-    d_postRewriteTable[static_cast<uint32_t>(Kind::CONST_FLOATINGPOINT)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::CONST_ROUNDINGMODE)] =
-        rewrite::identity;
-
-    /******** Sorts(?) ********/
-    /* These kinds should only appear in types */
-    // d_postRewriteTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_TYPE)] =
-    // rewrite::type;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TYPE)] =
-        rewrite::type;
-
-    /******** Operations ********/
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FP)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ABS)] =
-        rewrite::compactAbs;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_NEG)] =
-        rewrite::removeDoubleNegation;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ADD)] =
-        rewrite::reorderBinaryOperation;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SUB)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MULT)] =
-        rewrite::reorderBinaryOperation;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_DIV)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FMA)] =
-        rewrite::reorderFMA;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SQRT)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_REM)] =
-        rewrite::compactRemainder;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_RTI)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN)] =
-        rewrite::compactMinMax;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX)] =
-        rewrite::compactMinMax;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN_TOTAL)] =
-        rewrite::compactMinMax;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX_TOTAL)] =
-        rewrite::compactMinMax;
-
-    /******** Comparisons ********/
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_EQ)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LEQ)] =
-        rewrite::leqId;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LT)] =
-        rewrite::ltId;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_GEQ)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_GT)] =
-        rewrite::identity;
-
-    /******** Classifications ********/
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NORMAL)] =
-        rewrite::removeSignOperations;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_IS_SUBNORMAL)] = rewrite::removeSignOperations;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_ZERO)] =
-        rewrite::removeSignOperations;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_INF)] =
-        rewrite::removeSignOperations;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NAN)] =
-        rewrite::removeSignOperations;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NEG)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_POS)] =
-        rewrite::identity;
-
-    /******** Conversions ********/
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_FP)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_REAL)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_SBV)] = rewrite::toFPSignedBV;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_UBV)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_REAL)] =
-        rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_UBV_TOTAL)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_SBV_TOTAL)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_REAL_TOTAL)] = rewrite::identity;
-
-    /******** Variables ********/
-    d_postRewriteTable[static_cast<uint32_t>(Kind::VARIABLE)] =
-        rewrite::variable;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::BOUND_VARIABLE)] =
-        rewrite::variable;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::SKOLEM)] = rewrite::variable;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::INST_CONSTANT)] =
-        rewrite::variable;
-
-    d_postRewriteTable[static_cast<uint32_t>(Kind::EQUAL)] = rewrite::equal;
-
-    /******** Components for bit-blasting ********/
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_NAN)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_INF)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_ZERO)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_SIGN)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_EXPONENT)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND)] = rewrite::identity;
-    d_postRewriteTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_BITBLAST)] =
-        rewrite::identity;
-
-    /* Set up the post-rewrite constant fold table */
-    for (uint32_t i = 0; i < static_cast<uint32_t>(Kind::LAST_KIND); ++i)
-    {
-      // Note that this is identity, not notFP
-      // Constant folding is called after post-rewrite
-      // So may have to deal with cases of things being
-      // re-written to non-floating-point sorts (i.e. true).
-      d_constantFoldTable[i] = rewrite::identity;
-    }
-
-    /******** Constants ********/
-    /* Already folded! */
-    d_constantFoldTable[static_cast<uint32_t>(Kind::CONST_FLOATINGPOINT)] =
-        rewrite::identity;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::CONST_ROUNDINGMODE)] =
-        rewrite::identity;
-
-    /******** Sorts(?) ********/
-    /* These kinds should only appear in types */
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TYPE)] =
-        rewrite::type;
-
-    /******** Operations ********/
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FP)] =
-        constantFold::fpLiteral;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ABS)] =
-        constantFold::abs;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_NEG)] =
-        constantFold::neg;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_ADD)] =
-        constantFold::add;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MULT)] =
-        constantFold::mult;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_DIV)] =
-        constantFold::div;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_FMA)] =
-        constantFold::fma;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_SQRT)] =
-        constantFold::sqrt;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_REM)] =
-        constantFold::rem;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_RTI)] =
-        constantFold::rti;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN)] =
-        constantFold::min;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX)] =
-        constantFold::max;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MIN_TOTAL)] =
-        constantFold::minTotal;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_MAX_TOTAL)] =
-        constantFold::maxTotal;
-
-    /******** Comparisons ********/
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LEQ)] =
-        constantFold::leq;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_LT)] =
-        constantFold::lt;
-
-    /******** Classifications ********/
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NORMAL)] =
-        constantFold::isNormal;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_IS_SUBNORMAL)] = constantFold::isSubnormal;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_ZERO)] =
-        constantFold::isZero;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_INF)] =
-        constantFold::isInfinite;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NAN)] =
-        constantFold::isNaN;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_NEG)] =
-        constantFold::isNegative;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_IS_POS)] =
-        constantFold::isPositive;
-
-    /******** Conversions ********/
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV)] =
-        constantFold::convertFromIEEEBitVectorLiteral;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_FP)] = constantFold::constantConvert;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_REAL)] =
-        constantFold::convertFromRealLiteral;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_SBV)] = constantFold::convertFromSBV;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_FP_FROM_UBV)] = constantFold::convertFromUBV;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_UBV)] =
-        constantFold::convertToUBV;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_SBV)] =
-        constantFold::convertToSBV;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::FLOATINGPOINT_TO_REAL)] =
-        constantFold::convertToReal;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_UBV_TOTAL)] = constantFold::convertToUBVTotal;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_SBV_TOTAL)] = constantFold::convertToSBVTotal;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_TO_REAL_TOTAL)] = constantFold::convertToRealTotal;
-
-    /******** Variables ********/
-    d_constantFoldTable[static_cast<uint32_t>(Kind::VARIABLE)] =
-        rewrite::variable;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::BOUND_VARIABLE)] =
-        rewrite::variable;
-
-    d_constantFoldTable[static_cast<uint32_t>(Kind::EQUAL)] =
-        constantFold::equal;
-
-    /******** Components for bit-blasting ********/
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_NAN)] = constantFold::componentFlag;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_INF)] = constantFold::componentFlag;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_ZERO)] = constantFold::componentFlag;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_SIGN)] = constantFold::componentFlag;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_EXPONENT)] =
-        constantFold::componentExponent;
-    d_constantFoldTable[static_cast<uint32_t>(
-        Kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND)] =
-        constantFold::componentSignificand;
-    d_constantFoldTable[static_cast<uint32_t>(Kind::ROUNDINGMODE_BITBLAST)] =
-        constantFold::roundingModeBitBlast;
-}
-
-  /**
-   * Rewrite a node into the normal form for the theory of fp
-   * in pre-order (really topological order)---meaning that the
-   * children may not be in the normal form.  This is an optimization
-   * for theories with cancelling terms (e.g., 0 * (big-nasty-expression)
-   * in arithmetic rewrites to 0 without the need to look at the big
-   * nasty expression).  Since it's only an optimization, the
-   * implementation here can do nothing.
-   */
-
-  RewriteResponse TheoryFpRewriter::preRewrite(TNode node) {
-    Trace("fp-rewrite") << "TheoryFpRewriter::preRewrite(): " << node << std::endl;
-    RewriteResponse res =
-        d_preRewriteTable[static_cast<uint32_t>(node.getKind())](node, true);
-    if (res.d_node != node)
-    {
-      Trace("fp-rewrite") << "TheoryFpRewriter::preRewrite(): before " << node << std::endl;
-      Trace("fp-rewrite") << "TheoryFpRewriter::preRewrite(): after  "
-                          << res.d_node << std::endl;
-    }
-    return res;
+    Trace("fp-rewrite") << "TheoryFpRewriter::postRewrite(): before " << node
+                        << std::endl;
+    Trace("fp-rewrite") << "TheoryFpRewriter::postRewrite(): after  "
+                        << res.d_node << std::endl;
   }
 
-
-  /**
-   * Rewrite a node into the normal form for the theory of fp.
-   * Called in post-order (really reverse-topological order) when
-   * traversing the expression DAG during rewriting.  This is the
-   * main function of the rewriter, and because of the ordering,
-   * it can assume its children are all rewritten already.
-   *
-   * This function can return one of three rewrite response codes
-   * along with the rewritten node:
-   *
-   *   REWRITE_DONE indicates that no more rewriting is needed.
-   *   REWRITE_AGAIN means that the top-level expression should be
-   *     rewritten again, but that its children are in final form.
-   *   REWRITE_AGAIN_FULL means that the entire returned expression
-   *     should be rewritten again (top-down with preRewrite(), then
-   *     bottom-up with postRewrite()).
-   *
-   * Even if this function returns REWRITE_DONE, if the returned
-   * expression belongs to a different theory, it will be fully
-   * rewritten by that theory's rewriter.
-   */
-
-  RewriteResponse TheoryFpRewriter::postRewrite(TNode node) {
-    Trace("fp-rewrite") << "TheoryFpRewriter::postRewrite(): " << node << std::endl;
-    RewriteResponse res =
-        d_postRewriteTable[static_cast<uint32_t>(node.getKind())](node, false);
-    if (res.d_node != node)
-    {
-      Trace("fp-rewrite") << "TheoryFpRewriter::postRewrite(): before " << node << std::endl;
-      Trace("fp-rewrite") << "TheoryFpRewriter::postRewrite(): after  "
-                          << res.d_node << std::endl;
-    }
-
-    if (res.d_status == REWRITE_DONE)
+  if (res.d_status == REWRITE_DONE)
+  {
+    bool allChildrenConst = true;
+    bool apartFromRoundingMode = false;
+    bool apartFromPartiallyDefinedArgument = false;
+    for (Node::const_iterator i = res.d_node.begin(); i != res.d_node.end();
+         ++i)
     {
-      bool allChildrenConst = true;
-      bool apartFromRoundingMode = false;
-      bool apartFromPartiallyDefinedArgument = false;
-      for (Node::const_iterator i = res.d_node.begin(); i != res.d_node.end();
-           ++i)
+      if ((*i).getMetaKind() != kind::metakind::CONSTANT)
       {
-        if ((*i).getMetaKind() != kind::metakind::CONSTANT) {
-	  if ((*i).getType().isRoundingMode() && !apartFromRoundingMode) {
-	    apartFromRoundingMode = true;
-          }
-          else if ((res.d_node.getKind() == Kind::FLOATINGPOINT_MIN_TOTAL
-                    || res.d_node.getKind() == Kind::FLOATINGPOINT_MAX_TOTAL
-                    || res.d_node.getKind() == Kind::FLOATINGPOINT_TO_UBV_TOTAL
-                    || res.d_node.getKind() == Kind::FLOATINGPOINT_TO_SBV_TOTAL
-                    || res.d_node.getKind()
-                           == Kind::FLOATINGPOINT_TO_REAL_TOTAL)
-                   && ((*i).getType().isBitVector() || (*i).getType().isReal())
-                   && !apartFromPartiallyDefinedArgument)
-          {
-            apartFromPartiallyDefinedArgument = true;
-          }
-          else
-          {
-            allChildrenConst = false;
-	    break;
-          }
+        if ((*i).getType().isRoundingMode() && !apartFromRoundingMode)
+        {
+          apartFromRoundingMode = true;
         }
-      }
-
-      if (allChildrenConst)
-      {
-        RewriteStatus rs = REWRITE_DONE;  // This is a bit messy because
-        Node rn = res.d_node;             // RewriteResponse is too functional..
-
-        if (apartFromRoundingMode)
+        else if ((res.d_node.getKind() == Kind::FLOATINGPOINT_MIN_TOTAL
+                  || res.d_node.getKind() == Kind::FLOATINGPOINT_MAX_TOTAL
+                  || res.d_node.getKind() == Kind::FLOATINGPOINT_TO_UBV_TOTAL
+                  || res.d_node.getKind() == Kind::FLOATINGPOINT_TO_SBV_TOTAL
+                  || res.d_node.getKind() == Kind::FLOATINGPOINT_TO_REAL_TOTAL)
+                 && ((*i).getType().isBitVector() || (*i).getType().isReal())
+                 && !apartFromPartiallyDefinedArgument)
         {
-          if (!(res.d_node.getKind() == Kind::EQUAL)
-              &&  // Avoid infinite recursion...
-              !(res.d_node.getKind() == Kind::ROUNDINGMODE_BITBLAST))
-          {
-            // Don't eliminate the bit-blast
-            // We are close to being able to constant fold this
-            // and in many cases the rounding mode really doesn't matter.
-            // So we can try brute forcing our way through them.
-
-            NodeManager* nm = NodeManager::currentNM();
-
-            Node rne(nm->mkConst(RoundingMode::ROUND_NEAREST_TIES_TO_EVEN));
-            Node rna(nm->mkConst(RoundingMode::ROUND_NEAREST_TIES_TO_AWAY));
-            Node rtz(nm->mkConst(RoundingMode::ROUND_TOWARD_POSITIVE));
-            Node rtn(nm->mkConst(RoundingMode::ROUND_TOWARD_NEGATIVE));
-            Node rtp(nm->mkConst(RoundingMode::ROUND_TOWARD_ZERO));
-
-            TNode rm(res.d_node[0]);
-
-            Node w_rne(res.d_node.substitute(rm, TNode(rne)));
-            Node w_rna(res.d_node.substitute(rm, TNode(rna)));
-            Node w_rtz(res.d_node.substitute(rm, TNode(rtz)));
-            Node w_rtn(res.d_node.substitute(rm, TNode(rtn)));
-            Node w_rtp(res.d_node.substitute(rm, TNode(rtp)));
-
-            rs = REWRITE_AGAIN_FULL;
-            rn = nm->mkNode(
-                Kind::ITE,
-                nm->mkNode(Kind::EQUAL, rm, rne),
-                w_rne,
-                nm->mkNode(
-                    Kind::ITE,
-                    nm->mkNode(Kind::EQUAL, rm, rna),
-                    w_rna,
-                    nm->mkNode(Kind::ITE,
-                               nm->mkNode(Kind::EQUAL, rm, rtz),
-                               w_rtz,
-                               nm->mkNode(Kind::ITE,
-                                          nm->mkNode(Kind::EQUAL, rm, rtn),
-                                          w_rtn,
-                                          w_rtp))));
-          }
+          apartFromPartiallyDefinedArgument = true;
         }
         else
         {
-          RewriteResponse tmp =
-              d_constantFoldTable[static_cast<uint32_t>(res.d_node.getKind())](
-                  res.d_node, false);
-          rs = tmp.d_status;
-          rn = tmp.d_node;
+          allChildrenConst = false;
+          break;
         }
+      }
+    }
 
-        RewriteResponse constRes(rs, rn);
+    if (allChildrenConst)
+    {
+      RewriteStatus rs = REWRITE_DONE;  // This is a bit messy because
+      Node rn = res.d_node;             // RewriteResponse is too functional..
 
-        if (constRes.d_node != res.d_node)
+      if (apartFromRoundingMode)
+      {
+        if (!(res.d_node.getKind() == Kind::EQUAL)
+            &&  // Avoid infinite recursion...
+            !(res.d_node.getKind() == Kind::ROUNDINGMODE_BITBLAST))
         {
-          Trace("fp-rewrite")
-              << "TheoryFpRewriter::postRewrite(): before constant fold "
-              << res.d_node << std::endl;
-          Trace("fp-rewrite")
-              << "TheoryFpRewriter::postRewrite(): after constant fold "
-              << constRes.d_node << std::endl;
+          // Don't eliminate the bit-blast
+          // We are close to being able to constant fold this
+          // and in many cases the rounding mode really doesn't matter.
+          // So we can try brute forcing our way through them.
+
+          Node rne(d_nm->mkConst(RoundingMode::ROUND_NEAREST_TIES_TO_EVEN));
+          Node rna(d_nm->mkConst(RoundingMode::ROUND_NEAREST_TIES_TO_AWAY));
+          Node rtz(d_nm->mkConst(RoundingMode::ROUND_TOWARD_POSITIVE));
+          Node rtn(d_nm->mkConst(RoundingMode::ROUND_TOWARD_NEGATIVE));
+          Node rtp(d_nm->mkConst(RoundingMode::ROUND_TOWARD_ZERO));
+
+          TNode rm(res.d_node[0]);
+
+          Node w_rne(res.d_node.substitute(rm, TNode(rne)));
+          Node w_rna(res.d_node.substitute(rm, TNode(rna)));
+          Node w_rtz(res.d_node.substitute(rm, TNode(rtz)));
+          Node w_rtn(res.d_node.substitute(rm, TNode(rtn)));
+          Node w_rtp(res.d_node.substitute(rm, TNode(rtp)));
+
+          rs = REWRITE_AGAIN_FULL;
+          rn = d_nm->mkNode(
+              Kind::ITE,
+              d_nm->mkNode(Kind::EQUAL, rm, rne),
+              w_rne,
+              d_nm->mkNode(
+                  Kind::ITE,
+                  d_nm->mkNode(Kind::EQUAL, rm, rna),
+                  w_rna,
+                  d_nm->mkNode(Kind::ITE,
+                               d_nm->mkNode(Kind::EQUAL, rm, rtz),
+                               w_rtz,
+                               d_nm->mkNode(Kind::ITE,
+                                            d_nm->mkNode(Kind::EQUAL, rm, rtn),
+                                            w_rtn,
+                                            w_rtp))));
         }
+      }
+      else
+      {
+        RewriteResponse tmp =
+            d_constantFoldTable[static_cast<uint32_t>(res.d_node.getKind())](
+                d_nm, res.d_node, false);
+        rs = tmp.d_status;
+        rn = tmp.d_node;
+      }
+
+      RewriteResponse constRes(rs, rn);
 
-        return constRes;
+      if (constRes.d_node != res.d_node)
+      {
+        Trace("fp-rewrite")
+            << "TheoryFpRewriter::postRewrite(): before constant fold "
+            << res.d_node << std::endl;
+        Trace("fp-rewrite")
+            << "TheoryFpRewriter::postRewrite(): after constant fold "
+            << constRes.d_node << std::endl;
       }
-    }
 
-    return res;
-  }
-  TrustNode TheoryFpRewriter::expandDefinition(Node node)
-  {
-    return d_fpExpDef.expandDefinition(node);
+      return constRes;
+    }
   }
 
-  }  // namespace fp
-  }  // namespace theory
-  }  // namespace cvc5::internal
+  return res;
+}
+TrustNode TheoryFpRewriter::expandDefinition(Node node)
+{
+  return d_fpExpDef.expandDefinition(node);
+}
+
+}  // namespace fp
+}  // namespace theory
+}  // namespace cvc5::internal
diff --git a/src/theory/fp/theory_fp_rewriter.h b/src/theory/fp/theory_fp_rewriter.h
index 0a1615776..81f845e43 100644
--- a/src/theory/fp/theory_fp_rewriter.h
+++ b/src/theory/fp/theory_fp_rewriter.h
@@ -28,7 +28,7 @@ namespace cvc5::internal {
 namespace theory {
 namespace fp {
 
-typedef RewriteResponse (*RewriteFunction) (TNode, bool);
+typedef RewriteResponse (*RewriteFunction)(NodeManager* nm, TNode, bool);
 
 class TheoryFpRewriter : public TheoryRewriter
 {
-- 
2.47.1

