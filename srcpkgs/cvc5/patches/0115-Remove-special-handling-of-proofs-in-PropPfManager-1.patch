From 4198c44b0810cc12d861937fadcee83ab9a8a143 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Wed, 9 Oct 2024 09:05:26 -0500
Subject: [PATCH 115/312] Remove special handling of proofs in PropPfManager
 (#11254)

We have decided that SAT solvers should be responsible for managing
their proofs internally.

Thus, there is no need for custom handling in the PropPfManager.

This PR deletes the custom code that was necessary for generating proofs
given the limitations of older versions of CaDiCaL.

After this PR, we should revisit proof support in the CaDiCaL solver
based on various prop proof modes (e.g. drat, lrat, sat-external-prove).
---
 src/options/proof_options.toml                |   7 +-
 src/prop/cadical.cpp                          |  24 +-
 src/prop/cadical.h                            |   9 +-
 src/prop/minisat/minisat.cpp                  |   6 -
 src/prop/minisat/minisat.h                    |   3 -
 src/prop/prop_engine.cpp                      |   6 +-
 src/prop/prop_proof_manager.cpp               | 316 ++----------------
 src/prop/prop_proof_manager.h                 |  58 +---
 src/prop/sat_solver.h                         |  11 -
 src/prop/sat_solver_factory.cpp               |  10 +-
 src/prop/sat_solver_factory.h                 |   6 +-
 src/smt/set_defaults.cpp                      |   7 +-
 .../cli/regress0/prop/cadical_bug4.smt2       |   2 +
 13 files changed, 44 insertions(+), 421 deletions(-)

diff --git a/src/options/proof_options.toml b/src/options/proof_options.toml
index 9013c1315..c7ff2cd00 100644
--- a/src/options/proof_options.toml
+++ b/src/options/proof_options.toml
@@ -229,17 +229,14 @@ name   = "Proof"
   long       = "prop-proof-mode=MODE"
   type       = "PropProofMode"
   default    = "PROOF"
-  help       = "modes for proof granularity"
-  help_mode  = "Modes for proof granularity."
+  help       = "modes for the type of proof generated by the SAT solver"
+  help_mode  = "Modes for the type of proof generated by the SAT solver."
 [[option.mode.PROOF]]
   name = "proof"
   help = "A proof computed by the SAT solver."
 [[option.mode.SAT_EXTERNAL_PROVE]]
   name = "sat-external-prove"
   help = "A proof containing a step that will be proven externally."
-[[option.mode.SKETCH]]
-  name = "sketch"
-  help = "A sketch given by the SAT solver."
 
 [[option]]
   name       = "proofAllowTrust"
diff --git a/src/prop/cadical.cpp b/src/prop/cadical.cpp
index 8fe0a032d..172b9d2a1 100644
--- a/src/prop/cadical.cpp
+++ b/src/prop/cadical.cpp
@@ -997,15 +997,13 @@ class ClauseLearner : public CaDiCaL::Learner
 
 CadicalSolver::CadicalSolver(Env& env,
                              StatisticsRegistry& registry,
-                             const std::string& name,
-                             bool logProofs)
+                             const std::string& name)
     : EnvObj(env),
       d_solver(new CaDiCaL::Solver()),
       d_context(nullptr),
       // Note: CaDiCaL variables start with index 1 rather than 0 since negated
       //       literals are represented as the negation of the index.
       d_nextVarIdx(1),
-      d_logProofs(logProofs),
       d_inSatMode(false),
       d_statistics(registry, name)
 {
@@ -1033,7 +1031,12 @@ void CadicalSolver::init()
   d_solver->add(-toCadicalVar(d_false));
   d_solver->add(0);
 
-  if (d_logProofs)
+  bool logProofs = false;
+  // TODO (wishue #154): determine how to initialize the proofs for CaDiCaL
+  // here based on d_env.isSatProofProducing and options().proof.propProofMode.
+  // The latter should be extended to include modes DRAT and LRAT based on
+  // what is available here.
+  if (logProofs)
   {
     d_pfFile = options().driver.filename + ".drat_proof.txt";
     if (!options().proof.dratBinaryFormat)
@@ -1311,22 +1314,13 @@ std::vector<Node> CadicalSolver::getOrderHeap() const { return {}; }
 
 std::shared_ptr<ProofNode> CadicalSolver::getProof()
 {
+  // NOTE: we could return a DRAT_REFUTATION or LRAT_REFUTATION proof node
+  // consisting of a single step, referencing the files for the DIMACS + proof.
   // do not throw an exception, since we test whether the proof is available
   // by comparing it to nullptr.
   return nullptr;
 }
 
-std::pair<ProofRule, std::vector<Node>> CadicalSolver::getProofSketch()
-{
-  Assert(d_logProofs);
-  d_solver->flush_proof_trace();
-  std::vector<Node> args = {nodeManager()->mkConst(String(d_pfFile))};
-  // The proof is DRAT_REFUTATION whose premises is all inputs + theory lemmas.
-  // The DRAT file is an argument to the file proof.
-  return std::pair<ProofRule, std::vector<Node>>(ProofRule::DRAT_REFUTATION,
-                                                 args);
-}
-
 /* -------------------------------------------------------------------------- */
 }  // namespace prop
 }  // namespace cvc5::internal
diff --git a/src/prop/cadical.h b/src/prop/cadical.h
index e159128e9..8b6ebd608 100644
--- a/src/prop/cadical.h
+++ b/src/prop/cadical.h
@@ -92,9 +92,6 @@ class CadicalSolver : public CDCLTSatSolver, protected EnvObj
   /** Get proof, unimplemented by this solver. */
   std::shared_ptr<ProofNode> getProof() override;
 
-  /** Get proof sketch. */
-  std::pair<ProofRule, std::vector<Node>> getProofSketch() override;
-
  private:
   /**
    * Constructor.
@@ -103,12 +100,10 @@ class CadicalSolver : public CDCLTSatSolver, protected EnvObj
    * @param env       The associated environment.
    * @param registry  The associated statistics registry.
    * @param name      The name of the SAT solver.
-   * @param logProofs Whether to log proofs
    */
   CadicalSolver(Env& env,
                 StatisticsRegistry& registry,
-                const std::string& name = "",
-                bool logProofs = false);
+                const std::string& name = "");
 
   /**
    * Initialize SAT solver instance.
@@ -145,8 +140,6 @@ class CadicalSolver : public CDCLTSatSolver, protected EnvObj
   std::vector<SatLiteral> d_assumptions;
 
   unsigned d_nextVarIdx;
-  /** Whether we are logging proofs */
-  bool d_logProofs;
   /** The proof file */
   std::string d_pfFile;
   /**
diff --git a/src/prop/minisat/minisat.cpp b/src/prop/minisat/minisat.cpp
index 7a78d3b30..77d8b8056 100644
--- a/src/prop/minisat/minisat.cpp
+++ b/src/prop/minisat/minisat.cpp
@@ -314,12 +314,6 @@ std::shared_ptr<ProofNode> MinisatSatSolver::getProof()
   return d_minisat->getProof();
 }
 
-std::pair<ProofRule, std::vector<Node>> MinisatSatSolver::getProofSketch()
-{
-  Unimplemented() << "getProofSketch for Minisat not supported";
-  return std::pair<ProofRule, std::vector<Node>>();
-}
-
 /** Incremental interface */
 
 uint32_t MinisatSatSolver::getAssertionLevel() const
diff --git a/src/prop/minisat/minisat.h b/src/prop/minisat/minisat.h
index 0bfdc7f13..699b949a2 100644
--- a/src/prop/minisat/minisat.h
+++ b/src/prop/minisat/minisat.h
@@ -107,9 +107,6 @@ class MinisatSatSolver : public CDCLTSatSolver, protected EnvObj
   /** Retrieve the refutation proof of this SAT solver. */
   std::shared_ptr<ProofNode> getProof() override;
 
-  /** Get proof sketch, unimplemented in this solver. */
-  std::pair<ProofRule, std::vector<Node>> getProofSketch() override;
-
  private:
 
   /** The SatSolver used */
diff --git a/src/prop/prop_engine.cpp b/src/prop/prop_engine.cpp
index 89bbfc132..74b964741 100644
--- a/src/prop/prop_engine.cpp
+++ b/src/prop/prop_engine.cpp
@@ -90,12 +90,8 @@ PropEngine::PropEngine(Env& env, TheoryEngine* te)
   }
   else
   {
-    // log DRAT proofs if the mode is SKETCH.
-    bool logProofs =
-        (env.isSatProofProducing()
-         && options().proof.propProofMode == options::PropProofMode::SKETCH);
     d_satSolver = SatSolverFactory::createCadicalCDCLT(
-        d_env, statisticsRegistry(), env.getResourceManager(), "", logProofs);
+        d_env, statisticsRegistry(), env.getResourceManager(), "");
   }
 
   // CNF stream and theory proxy required pointers to each other, make the
diff --git a/src/prop/prop_proof_manager.cpp b/src/prop/prop_proof_manager.cpp
index 5e8da5c83..15d654748 100644
--- a/src/prop/prop_proof_manager.cpp
+++ b/src/prop/prop_proof_manager.cpp
@@ -28,6 +28,7 @@
 #include "prop/sat_solver.h"
 #include "prop/sat_solver_factory.h"
 #include "smt/env.h"
+#include "smt/logic_exception.h"
 #include "util/resource_manager.h"
 #include "util/string.h"
 
@@ -179,177 +180,27 @@ theory::InferenceId PropPfManager::getInferenceIdFor(const Node& lem,
   }
   return theory::InferenceId::NONE;
 }
-
-std::vector<Node> PropPfManager::getMinimizedAssumptions()
-{
-  std::vector<Node> minAssumptions;
-  std::vector<SatLiteral> unsatAssumptions;
-  d_satSolver->getUnsatAssumptions(unsatAssumptions);
-  for (const Node& nc : d_assumptions)
-  {
-    if (nc.isConst())
-    {
-      if (nc.getConst<bool>())
-      {
-        // never include true
-        continue;
-      }
-      minAssumptions.clear();
-      minAssumptions.push_back(nc);
-      return minAssumptions;
-    }
-    else if (d_pfCnfStream.hasLiteral(nc))
-    {
-      SatLiteral il = d_pfCnfStream.getLiteral(nc);
-      if (std::find(unsatAssumptions.begin(), unsatAssumptions.end(), il)
-          == unsatAssumptions.end())
-      {
-        continue;
-      }
-    }
-    else
-    {
-      Assert(false) << "Missing literal for assumption " << nc;
-    }
-    minAssumptions.push_back(nc);
-  }
-  return minAssumptions;
-}
-
-std::vector<Node> PropPfManager::getUnsatCoreClauses(std::ostream* outDimacs)
+std::vector<Node> PropPfManager::getUnsatCoreClauses()
 {
   std::vector<Node> uc;
   // if it has a proof
   std::shared_ptr<ProofNode> satPf = d_satSolver->getProof();
-  if (satPf != nullptr)
-  {
-    // then, get the proof *without* connecting the CNF
-    expr::getFreeAssumptions(satPf.get(), uc);
-    if (outDimacs != nullptr)
-    {
-      std::vector<Node> auxUnits = computeAuxiliaryUnits(uc);
-      d_pfCnfStream.dumpDimacs(*outDimacs, uc, auxUnits);
-      // include the auxiliary units if any
-      uc.insert(uc.end(), auxUnits.begin(), auxUnits.end());
-    }
-    return uc;
-  }
-  // otherwise we need to compute it
-  // as a minor optimization, we use only minimized assumptions
-  std::vector<Node> minAssumptions = getMinimizedAssumptions();
-  std::unordered_set<Node> cset(minAssumptions.begin(), minAssumptions.end());
-  std::vector<Node> inputs = getInputClauses();
-  std::vector<Node> lemmas = getLemmaClauses();
-  cset.insert(inputs.begin(), inputs.end());
-  cset.insert(lemmas.begin(), lemmas.end());
-  if (!reproveUnsatCore(cset, uc, outDimacs))
-  {
-    // otherwise, must include all
-    return getLemmaClauses();
-  }
+  // Note that we currently assume that the proof is the standard way of
+  // communicating the unsat core of theory lemmas. If no proofs are
+  // available, then a trust step (e.g. SAT_REFUTATION) with free assumptions
+  // F1 ... Fn can be used to indicate that F1 ... Fn is the unsat core
+  if (satPf == nullptr)
+  {
+    std::stringstream ss;
+    ss << "ERROR: cannot get unsat core clauses when SAT solver is not proof "
+          "producing.";
+    throw LogicException(ss.str());
+  }
+  // then, get the proof *without* connecting the CNF
+  expr::getFreeAssumptions(satPf.get(), uc);
   return uc;
 }
 
-bool PropPfManager::reproveUnsatCore(const std::unordered_set<Node>& cset,
-                                     std::vector<Node>& uc,
-                                     std::ostream* outDimacs)
-{
-  std::unique_ptr<CDCLTSatSolver> csm(SatSolverFactory::createCadical(
-      d_env, statisticsRegistry(), d_env.getResourceManager(), ""));
-  NullRegistrar nreg;
-  context::Context nctx;
-  CnfStream csms(d_env, csm.get(), &nreg, &nctx);
-  Trace("cnf-input-min") << "Get literals..." << std::endl;
-  std::vector<SatLiteral> csma;
-  std::map<SatLiteral, Node> litToNode;
-  std::map<SatLiteral, Node> litToNodeAbs;
-  NodeManager* nm = nodeManager();
-  TypeNode bt = nm->booleanType();
-  TypeNode ft = nm->mkFunctionType({bt}, bt);
-  SkolemManager* skm = nm->getSkolemManager();
-  // Function used to ensure that subformulas are not treated by CNF below.
-  Node litOf = skm->mkDummySkolem("litOf", ft);
-  for (const Node& c : cset)
-  {
-    Node ca = c;
-    std::vector<SatLiteral> satClause;
-    std::vector<Node> lits;
-    if (c.getKind() == Kind::OR)
-    {
-      lits.insert(lits.end(), c.begin(), c.end());
-    }
-    else
-    {
-      lits.push_back(c);
-    }
-    // For each literal l in the current clause, if it has Boolean
-    // substructure, we replace it with (litOf l), which will be treated as a
-    // literal. We do this since we require that the clause be treated
-    // verbatim by the SAT solver, otherwise the unsat core will not include
-    // the necessary clauses (e.g. it will skip those corresponding to CNF
-    // conversion).
-    std::vector<Node> cls;
-    bool childChanged = false;
-    for (const Node& cl : lits)
-    {
-      bool negated = cl.getKind() == Kind::NOT;
-      Node cla = negated ? cl[0] : cl;
-      if (d_env.theoryOf(cla) == theory::THEORY_BOOL && !cla.isVar())
-      {
-        Node k = nm->mkNode(Kind::APPLY_UF, {litOf, cla});
-        cls.push_back(negated ? k.notNode() : k);
-        childChanged = true;
-      }
-      else
-      {
-        cls.push_back(cl);
-      }
-    }
-    if (childChanged)
-    {
-      ca = nm->mkOr(cls);
-    }
-    Trace("cnf-input-min-assert") << "Assert: " << ca << std::endl;
-    csms.ensureLiteral(ca);
-    SatLiteral lit = csms.getLiteral(ca);
-    csma.emplace_back(lit);
-    litToNode[lit] = c;
-    litToNodeAbs[lit] = ca;
-  }
-  Trace("cnf-input-min") << "Solve under " << csma.size() << " assumptions..."
-                         << std::endl;
-  SatValue res = csm->solve(csma);
-  bool success = false;
-  if (res == SAT_VALUE_FALSE)
-  {
-    // we successfully reproved the input
-    Trace("cnf-input-min") << "...got unsat" << std::endl;
-    std::vector<SatLiteral> uassumptions;
-    csm->getUnsatAssumptions(uassumptions);
-    Trace("cnf-input-min") << "...#unsat assumptions=" << uassumptions.size()
-                           << std::endl;
-    std::vector<Node> aclauses;
-    for (const SatLiteral& lit : uassumptions)
-    {
-      Assert(litToNode.find(lit) != litToNode.end());
-      Trace("cnf-input-min-result")
-          << "assert: " << litToNode[lit] << std::endl;
-      uc.emplace_back(litToNode[lit]);
-      aclauses.emplace_back(litToNodeAbs[lit]);
-    }
-    if (outDimacs)
-    {
-      // dump using the CNF stream we created above
-      csms.dumpDimacs(*outDimacs, aclauses);
-    }
-    success = true;
-  }
-  // should never happen, if it does, we revert to the entire input
-  Trace("cnf-input-min") << "...got sat" << std::endl;
-  Assert(success) << "Failed to minimize DIMACS";
-  return success;
-}
-
 std::vector<std::shared_ptr<ProofNode>> PropPfManager::getProofLeaves(
     modes::ProofComponent pc)
 {
@@ -389,19 +240,8 @@ std::shared_ptr<ProofNode> PropPfManager::getProof(bool connectCnf)
   // get the proof based on the proof mode
   options::PropProofMode pmode = options().proof.propProofMode;
   std::shared_ptr<ProofNode> conflictProof;
-  if (pmode == options::PropProofMode::PROOF)
-  {
-    // take proof from SAT solver as is
-    conflictProof = d_satSolver->getProof();
-  }
-  else
-  {
-    // set up a proof and get the internal proof
-    CDProof cdp(d_env);
-    getProofInternal(&cdp);
-    Node falsen = nodeManager()->mkConst(false);
-    conflictProof = cdp.getProofFor(falsen);
-  }
+  // take proof from SAT solver as is
+  conflictProof = d_satSolver->getProof();
 
   Assert(conflictProof);
   if (TraceIsOn("sat-proof"))
@@ -425,7 +265,8 @@ std::shared_ptr<ProofNode> PropPfManager::getProof(bool connectCnf)
     return conflictProof;
   }
   // Must clone if we are using the original proof, since we don't want to
-  // modify the original SAT proof.
+  // modify the original SAT proof. Note that other propProofMode settings
+  // may also require cloning here.
   if (pmode == options::PropProofMode::PROOF)
   {
     conflictProof = conflictProof->clone();
@@ -502,125 +343,6 @@ Node PropPfManager::normalizeAndRegister(TNode clauseNode,
 
 LazyCDProof* PropPfManager::getCnfProof() { return &d_proof; }
 
-void PropPfManager::getProofInternal(CDProof* cdp)
-{
-  // This method is called when the SAT solver did not generate a fully self
-  // contained ProofNode proving false. This method adds a step to cdp
-  // based on a set of computed assumptions, possibly relying on the internal
-  // proof.
-  NodeManager* nm = nodeManager();
-  Node falsen = nm->mkConst(false);
-  std::vector<Node> clauses;
-  // deduplicate assumptions
-  Trace("cnf-input") << "#assumptions=" << d_assumptions.size() << std::endl;
-  std::vector<Node> minAssumptions = getMinimizedAssumptions();
-  if (minAssumptions.size() == 1 && minAssumptions[0] == falsen)
-  {
-    // if false exists, no proof is necessary
-    return;
-  }
-  std::unordered_set<Node> cset(minAssumptions.begin(), minAssumptions.end());
-  Trace("cnf-input") << "#assumptions (min)=" << cset.size() << std::endl;
-  std::vector<Node> inputs = getInputClauses();
-  Trace("cnf-input") << "#input=" << inputs.size() << std::endl;
-  std::vector<Node> lemmas = getLemmaClauses();
-  Trace("cnf-input") << "#lemmas=" << lemmas.size() << std::endl;
-  cset.insert(inputs.begin(), inputs.end());
-  cset.insert(lemmas.begin(), lemmas.end());
-
-  // Otherwise, we will dump a DIMACS. The proof further depends on the
-  // mode, which we handle below.
-  std::stringstream dinputFile;
-  dinputFile << options().driver.filename << ".drat_input.cnf";
-  // the stream which stores the DIMACS of the computed clauses
-  std::fstream dout(dinputFile.str(), std::ios::out);
-  options::PropProofMode pmode = options().proof.propProofMode;
-  // minimize only if SAT_EXTERNAL_PROVE and satProofMinDimacs is true.
-  bool minimal = (pmode == options::PropProofMode::SAT_EXTERNAL_PROVE
-                  && options().proof.satProofMinDimacs);
-  // go back and minimize assumptions if minimal is true
-  bool computedClauses = false;
-  if (minimal)
-  {
-    // get the unsat core clauses
-    std::shared_ptr<ProofNode> satPf = d_satSolver->getProof();
-    if (satPf != nullptr)
-    {
-      clauses = getUnsatCoreClauses(&dout);
-      computedClauses = true;
-    }
-    else if (reproveUnsatCore(cset, clauses, &dout))
-    {
-      computedClauses = true;
-    }
-    else
-    {
-      // failed to reprove
-    }
-  }
-  // if we did not minimize, just include all
-  if (!computedClauses)
-  {
-    // if no minimization is necessary, just include all
-    clauses.insert(clauses.end(), cset.begin(), cset.end());
-    std::vector<Node> auxUnits = computeAuxiliaryUnits(clauses);
-    d_pfCnfStream.dumpDimacs(dout, clauses, auxUnits);
-    // include the auxiliary units if any
-    clauses.insert(clauses.end(), auxUnits.begin(), auxUnits.end());
-  }
-  // construct the proof
-  std::vector<Node> args;
-  Node dfile = nm->mkConst(String(dinputFile.str()));
-  args.push_back(dfile);
-  ProofRule r = ProofRule::UNKNOWN;
-  if (pmode == options::PropProofMode::SKETCH)
-  {
-    // if sketch, get the rule and arguments from the SAT solver.
-    std::pair<ProofRule, std::vector<Node>> sk = d_satSolver->getProofSketch();
-    r = sk.first;
-    args.insert(args.end(), sk.second.begin(), sk.second.end());
-  }
-  else if (pmode == options::PropProofMode::SAT_EXTERNAL_PROVE)
-  {
-    // if SAT_EXTERNAL_PROVE, the rule is fixed and there are no additional
-    // arguments.
-    r = ProofRule::SAT_EXTERNAL_PROVE;
-  }
-  else
-  {
-    Assert(false) << "Unknown proof mode " << pmode;
-  }
-  // use the rule, clauses and arguments we computed above
-  cdp->addStep(falsen, r, clauses, args);
-}
-
-std::vector<Node> PropPfManager::computeAuxiliaryUnits(
-    const std::vector<Node>& clauses)
-{
-  std::vector<Node> auxUnits;
-  for (const Node& c : clauses)
-  {
-    if (c.getKind() != Kind::OR)
-    {
-      continue;
-    }
-    // Determine if any OR child occurs as a top level clause. If so, it may
-    // be relevant to include this as a unit clause.
-    for (const Node& l : c)
-    {
-      const Node& atom = l.getKind() == Kind::NOT ? l[0] : l;
-      if (atom.getKind() == Kind::OR
-          && std::find(clauses.begin(), clauses.end(), atom) != clauses.end()
-          && std::find(auxUnits.begin(), auxUnits.end(), atom)
-                 == auxUnits.end())
-      {
-        auxUnits.push_back(atom);
-      }
-    }
-  }
-  return auxUnits;
-}
-
 std::vector<Node> PropPfManager::getInputClauses()
 {
   std::vector<Node> cls;
diff --git a/src/prop/prop_proof_manager.h b/src/prop/prop_proof_manager.h
index 22c64436c..b22dc0d3c 100644
--- a/src/prop/prop_proof_manager.h
+++ b/src/prop/prop_proof_manager.h
@@ -189,65 +189,11 @@ class PropPfManager : protected EnvObj
   std::vector<Node> getLemmaClauses();
   /**
    * Return theory lemmas used for showing unsat. If the SAT solver has a proof,
-   * we examine its leaves. Otherwise, we recompute the unsat core lemmas
-   * using the method reproveUnsatCore.
+   * we examine its leaves. Otherwise, we throw an exception.
    *
-   * @param outDimacs If provided, we write the DIMACS output of uc to this
-   * stream
    * @return the unsat core of lemmas.
    */
-  std::vector<Node> getUnsatCoreClauses(std::ostream* outDimacs = nullptr);
-  /**
-   * Get minimized assumptions. Returns a vector of nodes which is a
-   * subset of the assumptions (d_assumptions) that appear in the unsat
-   * core. This should be called only when the unsat core is available (after
-   * an unsatisfiable check-sat).
-   */
-  std::vector<Node> getMinimizedAssumptions();
-  /**
-   * Calculate a subset of cset that is propositionally unsatisfiable.
-   * If sucessful, return true and store this in uc.
-   *
-   * @param cset The set of formulas to compute an unsat core for
-   * @param uc The set of formulas returned as the unsat core
-   * @param outDimacs If provided, we write a DIMACS representation of uc to
-   * this stream
-   */
-  bool reproveUnsatCore(const std::unordered_set<Node>& cset,
-                        std::vector<Node>& uc,
-                        std::ostream* outDimacs = nullptr);
-  /**
-   * Add a proof of false to cdp whose free assumptions are a subset of the
-   * clauses (after CNF conversion), which is a union of:
-   * (1) assumptions (d_assumptions),
-   * (2) input clauses (d_inputClauses),
-   * (3) lemma clauses (d_lemmaClauses).
-   * The choice of what to add to cdp is dependent on the prop-proof-mode.
-   *
-   * @param cdp The proof object to add the refutation proof to.
-   */
-  void getProofInternal(CDProof* cdp);
-  /**
-   * Get auxilary units. Computes top-level formulas in clauses that
-   * also occur as literals which we call "auxiliary units". In particular,
-   * consider the set of propositionally unsatisfiable clauses:
-   *
-   * (or ~(or A B) ~C)
-   * (or A B)
-   * C
-   *
-   * Here, we return (or A B) as an auxilary unit clause.
-   *
-   * Note that in the above example, it is ambiguous whether to interpret the
-   * second clause (or A B) as a unit clause or as a clause with literals
-   * A and B. To ensure that we generate an unsatisfiable DIMACS, we include
-   * both in a proof output. In particular, Any OR-term that occurs as a literal
-   * of another clause is included in the return vector.
-   *
-   * @param clauses The clauses
-   * @return the auxiliary units for the set of clauses.
-   */
-  std::vector<Node> computeAuxiliaryUnits(const std::vector<Node>& clauses);
+  std::vector<Node> getUnsatCoreClauses();
   /** The proofs of this proof manager, which are saved once requested (note the
    * cache is for both the request of the full proof (true) or not (false)).
    *
diff --git a/src/prop/sat_solver.h b/src/prop/sat_solver.h
index 6017e1c1b..ebc5720eb 100644
--- a/src/prop/sat_solver.h
+++ b/src/prop/sat_solver.h
@@ -176,17 +176,6 @@ class CDCLTSatSolver : public SatSolver
    */
   virtual std::shared_ptr<ProofNode> getProof() = 0;
 
-  /**
-   * Get proof sketch, which is used if option prop-proof-mode is SKETCH.
-   * Get a rule r and additional arguments args such that the final proof
-   * will be:
-   *   (r :premises (c1..cn) :args (F args))
-   * where F is a string corresponding to the file name of a DIMACs file
-   * for an unsat core of derived clauses (input or theory lemma) c1...cn.
-   * @return The above rule and arguments packaged as a std::pair.
-   */
-  virtual std::pair<ProofRule, std::vector<Node>> getProofSketch() = 0;
-
 }; /* class CDCLTSatSolver */
 
 inline std::ostream& operator <<(std::ostream& out, prop::SatLiteral lit) {
diff --git a/src/prop/sat_solver_factory.cpp b/src/prop/sat_solver_factory.cpp
index 466fd84e8..055ff931b 100644
--- a/src/prop/sat_solver_factory.cpp
+++ b/src/prop/sat_solver_factory.cpp
@@ -50,10 +50,9 @@ SatSolver* SatSolverFactory::createCryptoMinisat(StatisticsRegistry& registry,
 CDCLTSatSolver* SatSolverFactory::createCadical(Env& env,
                                                 StatisticsRegistry& registry,
                                                 ResourceManager* resmgr,
-                                                const std::string& name,
-                                                bool logProofs)
+                                                const std::string& name)
 {
-  CadicalSolver* res = new CadicalSolver(env, registry, name, logProofs);
+  CadicalSolver* res = new CadicalSolver(env, registry, name);
   res->init();
   res->setResourceLimit(resmgr);
   return res;
@@ -63,10 +62,9 @@ CDCLTSatSolver* SatSolverFactory::createCadicalCDCLT(
     Env& env,
     StatisticsRegistry& registry,
     ResourceManager* resmgr,
-    const std::string& name,
-    bool logProofs)
+    const std::string& name)
 {
-  CadicalSolver* res = new CadicalSolver(env, registry, name, logProofs);
+  CadicalSolver* res = new CadicalSolver(env, registry, name);
   res->setResourceLimit(resmgr);
   return res;
 }
diff --git a/src/prop/sat_solver_factory.h b/src/prop/sat_solver_factory.h
index 447f8d988..9410fb1cf 100644
--- a/src/prop/sat_solver_factory.h
+++ b/src/prop/sat_solver_factory.h
@@ -38,14 +38,12 @@ class SatSolverFactory
   static CDCLTSatSolver* createCadical(Env& env,
                                        StatisticsRegistry& registry,
                                        ResourceManager* resmgr,
-                                       const std::string& name = "",
-                                       bool logProofs = false);
+                                       const std::string& name = "");
 
   static CDCLTSatSolver* createCadicalCDCLT(Env& env,
                                             StatisticsRegistry& registry,
                                             ResourceManager* resmgr,
-                                            const std::string& name = "",
-                                            bool logProofs = false);
+                                            const std::string& name = "");
 
   static SatSolver* createCryptoMinisat(StatisticsRegistry& registry,
                                         ResourceManager* resmgr,
diff --git a/src/smt/set_defaults.cpp b/src/smt/set_defaults.cpp
index 353d97922..e5dc56bb1 100644
--- a/src/smt/set_defaults.cpp
+++ b/src/smt/set_defaults.cpp
@@ -1065,11 +1065,8 @@ bool SetDefaults::incompatibleWithProofs(Options& opts,
   }
   else if (opts.prop.satSolver == options::SatSolverMode::MINISAT)
   {
-    if (opts.proof.propProofMode == options::PropProofMode::SKETCH)
-    {
-      reason << "(DRAT) proof sketch not supported in minisat";
-      return true;
-    }
+    // TODO (wishue #154): throw logic exception for modes e.g. DRAT or LRAT
+    // not supported by Minisat.
   }
   if (options().theory.lemmaInprocess != options::LemmaInprocessMode::NONE)
   {
diff --git a/test/regress/cli/regress0/prop/cadical_bug4.smt2 b/test/regress/cli/regress0/prop/cadical_bug4.smt2
index 176d966bc..8ea0bf6d1 100644
--- a/test/regress/cli/regress0/prop/cadical_bug4.smt2
+++ b/test/regress/cli/regress0/prop/cadical_bug4.smt2
@@ -1,4 +1,6 @@
 ; COMMAND-LINE: -i --sat-solver=cadical
+; DISABLE-TESTER: cpc
+; DISABLE-TESTER: alethe
 (set-logic QF_LIA)
 (declare-fun s () Int)
 (push)
-- 
2.47.1

