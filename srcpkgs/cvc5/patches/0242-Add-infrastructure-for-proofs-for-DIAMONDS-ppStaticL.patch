From 3f41c2ab0896c8bea20536d75bf1d2765e8766e3 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Thu, 12 Dec 2024 18:54:48 -0600
Subject: [PATCH 242/312] Add infrastructure for proofs for DIAMONDS
 ppStaticLearn (#11409)

Moves the code and adds initial proof support (as a new trust id).

Proof reconstruction is ready on my development branch and will be added
on a followup PR.
---
 src/CMakeLists.txt                         |   2 +
 src/proof/trust_id.cpp                     |   1 +
 src/proof/trust_id.h                       |   2 +
 src/theory/uf/diamonds_proof_generator.cpp | 182 +++++++++++++++++++++
 src/theory/uf/diamonds_proof_generator.h   |  60 +++++++
 src/theory/uf/theory_uf.cpp                | 118 +------------
 src/theory/uf/theory_uf.h                  |   3 +
 7 files changed, 253 insertions(+), 115 deletions(-)
 create mode 100644 src/theory/uf/diamonds_proof_generator.cpp
 create mode 100644 src/theory/uf/diamonds_proof_generator.h

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 9679a76d6..c56a74fa8 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1263,6 +1263,8 @@ libcvc5_add_sources(
   theory/uf/cardinality_extension.h
   theory/uf/conversions_solver.cpp
   theory/uf/conversions_solver.h
+  theory/uf/diamonds_proof_generator.cpp
+  theory/uf/diamonds_proof_generator.h
   theory/uf/equality_engine.cpp
   theory/uf/equality_engine.h
   theory/uf/equality_engine_iterator.cpp
diff --git a/src/proof/trust_id.cpp b/src/proof/trust_id.cpp
index 01306f84c..ddefef08d 100644
--- a/src/proof/trust_id.cpp
+++ b/src/proof/trust_id.cpp
@@ -84,6 +84,7 @@ const char* toString(TrustId id)
     case TrustId::ARITH_NL_COMPARE_LIT_TRANSFORM:
       return "ARITH_NL_COMPARE_LIT_TRANSFORM";
     case TrustId::ARITH_DIO_LEMMA: return "ARITH_DIO_LEMMA";
+    case TrustId::DIAMONDS: return "DIAMONDS";
     case TrustId::EXT_THEORY_REWRITE: return "EXT_THEORY_REWRITE";
     case TrustId::REWRITE_NO_ELABORATE: return "REWRITE_NO_ELABORATE";
     case TrustId::FLATTENING_REWRITE: return "FLATTENING_REWRITE";
diff --git a/src/proof/trust_id.h b/src/proof/trust_id.h
index 6f29b9bb9..4763a85c4 100644
--- a/src/proof/trust_id.h
+++ b/src/proof/trust_id.h
@@ -149,6 +149,8 @@ enum class TrustId : uint32_t
   ARITH_NL_COMPARE_LIT_TRANSFORM,
   /** A lemma from the DIO solver */
   ARITH_DIO_LEMMA,
+  /** Diamonds preprocessing in TheoryUf::ppStaticLearn */
+  DIAMONDS,
   /** An extended theory rewrite */
   EXT_THEORY_REWRITE,
   /** A rewrite whose proof could not be elaborated */
diff --git a/src/theory/uf/diamonds_proof_generator.cpp b/src/theory/uf/diamonds_proof_generator.cpp
new file mode 100644
index 000000000..9eec970ba
--- /dev/null
+++ b/src/theory/uf/diamonds_proof_generator.cpp
@@ -0,0 +1,182 @@
+/******************************************************************************
+ * Top contributors (to current version):
+ *   Andrew Reynolds
+ *
+ * This file is part of the cvc5 project.
+ *
+ * Copyright (c) 2009-2024 by the authors listed in the file AUTHORS
+ * in the top-level source directory and their institutional affiliations.
+ * All rights reserved.  See the file COPYING in the top-level source
+ * directory for licensing information.
+ * ****************************************************************************
+ *
+ * Diamonds proof generator utility.
+ */
+
+#include "theory/uf/diamonds_proof_generator.h"
+
+#include "proof/proof.h"
+
+namespace cvc5::internal {
+
+DiamondsProofGenerator::DiamondsProofGenerator(Env& env) : EnvObj(env) {}
+
+DiamondsProofGenerator::~DiamondsProofGenerator() {}
+
+void DiamondsProofGenerator::ppStaticLearn(TNode n,
+                                           std::vector<TrustNode>& learned)
+{
+  std::vector<TNode> workList;
+  workList.push_back(n);
+  std::unordered_set<TNode> processed;
+
+  while (!workList.empty())
+  {
+    n = workList.back();
+
+    if (n.isClosure())
+    {
+      // unsafe to go under quantifiers; we might pull bound vars out of scope!
+      processed.insert(n);
+      workList.pop_back();
+      continue;
+    }
+
+    bool unprocessedChildren = false;
+    for (TNode::iterator i = n.begin(), iend = n.end(); i != iend; ++i)
+    {
+      if (processed.find(*i) == processed.end())
+      {
+        // unprocessed child
+        workList.push_back(*i);
+        unprocessedChildren = true;
+      }
+    }
+
+    if (unprocessedChildren)
+    {
+      continue;
+    }
+
+    workList.pop_back();
+    // has node n been processed in the meantime ?
+    if (processed.find(n) != processed.end())
+    {
+      continue;
+    }
+    processed.insert(n);
+
+    // == DIAMONDS ==
+
+    Trace("diamonds") << "===================== looking at" << std::endl
+                      << n << std::endl;
+
+    // binary OR of binary ANDs of EQUALities
+    if (n.getKind() == Kind::OR && n.getNumChildren() == 2
+        && n[0].getKind() == Kind::AND && n[0].getNumChildren() == 2
+        && n[1].getKind() == Kind::AND && n[1].getNumChildren() == 2
+        && (n[0][0].getKind() == Kind::EQUAL)
+        && (n[0][1].getKind() == Kind::EQUAL)
+        && (n[1][0].getKind() == Kind::EQUAL)
+        && (n[1][1].getKind() == Kind::EQUAL))
+    {
+      // now we have (a = b && c = d) || (e = f && g = h)
+
+      Trace("diamonds") << "has form of a diamond!" << std::endl;
+
+      TNode a = n[0][0][0], b = n[0][0][1], c = n[0][1][0], d = n[0][1][1],
+            e = n[1][0][0], f = n[1][0][1], g = n[1][1][0], h = n[1][1][1];
+
+      // test that one of {a, b} = one of {c, d}, and make "b" the
+      // shared node (i.e. put in the form (a = b && b = d))
+      // note we don't actually care about the shared ones, so the
+      // "swaps" below are one-sided, ignoring b and c
+      if (a == c)
+      {
+        a = b;
+      }
+      else if (a == d)
+      {
+        a = b;
+        d = c;
+      }
+      else if (b == c)
+      {
+        // nothing to do
+      }
+      else if (b == d)
+      {
+        d = c;
+      }
+      else
+      {
+        // condition not satisfied
+        Trace("diamonds") << "+ A fails" << std::endl;
+        continue;
+      }
+
+      Trace("diamonds") << "+ A holds" << std::endl;
+
+      // same: one of {e, f} = one of {g, h}, and make "f" the
+      // shared node (i.e. put in the form (e = f && f = h))
+      if (e == g)
+      {
+        e = f;
+      }
+      else if (e == h)
+      {
+        e = f;
+        h = g;
+      }
+      else if (f == g)
+      {
+        // nothing to do
+      }
+      else if (f == h)
+      {
+        h = g;
+      }
+      else
+      {
+        // condition not satisfied
+        Trace("diamonds") << "+ B fails" << std::endl;
+        continue;
+      }
+
+      Trace("diamonds") << "+ B holds" << std::endl;
+
+      // now we have (a = b && b = d) || (e = f && f = h)
+      // test that {a, d} == {e, h}
+      if ((a == e && d == h) || (a == h && d == e))
+      {
+        // learn: n implies a == d
+        Trace("diamonds") << "+ C holds" << std::endl;
+        Node newEquality = a.eqNode(d);
+        Trace("diamonds") << "  ==> " << newEquality << std::endl;
+        Node lem = n.impNode(newEquality);
+        TrustNode trn = TrustNode::mkTrustLemma(lem, this);
+        learned.emplace_back(trn);
+      }
+      else
+      {
+        Trace("diamonds") << "+ C fails" << std::endl;
+      }
+    }
+  }
+}
+
+std::shared_ptr<ProofNode> DiamondsProofGenerator::getProofFor(Node fact)
+{
+  Trace("valid-witness") << "Prove " << fact << std::endl;
+  // proofs not yet supported
+  CDProof cdp(d_env);
+  cdp.addTrustedStep(fact, TrustId::DIAMONDS, {}, {});
+  return cdp.getProofFor(fact);
+}
+
+std::string DiamondsProofGenerator::identify() const
+{
+  return "DiamondsProofGenerator";
+}
+
+}  // namespace cvc5::internal
diff --git a/src/theory/uf/diamonds_proof_generator.h b/src/theory/uf/diamonds_proof_generator.h
new file mode 100644
index 000000000..b16bb355a
--- /dev/null
+++ b/src/theory/uf/diamonds_proof_generator.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ * Top contributors (to current version):
+ *   Andrew Reynolds
+ *
+ * This file is part of the cvc5 project.
+ *
+ * Copyright (c) 2009-2024 by the authors listed in the file AUTHORS
+ * in the top-level source directory and their institutional affiliations.
+ * All rights reserved.  See the file COPYING in the top-level source
+ * directory for licensing information.
+ * ****************************************************************************
+ *
+ * Diamonds proof generator utility.
+ */
+
+#include "cvc5_private.h"
+
+#ifndef CVC5__THEORY__UF__DIAMONDS_PROOF_GENERATOR_H
+#define CVC5__THEORY__UF__DIAMONDS_PROOF_GENERATOR_H
+
+#include "proof/method_id.h"
+#include "proof/proof_generator.h"
+#include "proof/trust_node.h"
+#include "smt/env_obj.h"
+
+namespace cvc5::internal {
+
+class ProofNode;
+class ProofNodeManager;
+
+/**
+ * Proof generator implementing the "diamonds" preprocessing step, performed
+ * by TheoryUF.
+ */
+class DiamondsProofGenerator : protected EnvObj, public ProofGenerator
+{
+ public:
+  /**
+   * @param env Reference to the environment
+   */
+  DiamondsProofGenerator(Env& env);
+  virtual ~DiamondsProofGenerator();
+  /**
+   * Performs ppStaticLearn for theory UF.
+   * @param n The asserted formula.
+   * @param learned A list of lemmas to add to, if applicable.
+   */
+  void ppStaticLearn(TNode n, std::vector<TrustNode>& learned);
+  /**
+   * Get proof for fact. Called on fact that were added to learned by
+   * the above method.
+   */
+  std::shared_ptr<ProofNode> getProofFor(Node fact) override;
+  /** identify */
+  std::string identify() const override;
+};
+
+}  // namespace cvc5::internal
+
+#endif /* CVC5__PROOF__DIAMONDS_PROOF_GENERATOR_H */
diff --git a/src/theory/uf/theory_uf.cpp b/src/theory/uf/theory_uf.cpp
index 09da10d76..579d1c157 100644
--- a/src/theory/uf/theory_uf.cpp
+++ b/src/theory/uf/theory_uf.cpp
@@ -50,6 +50,7 @@ TheoryUF::TheoryUF(Env& env,
       d_thss(nullptr),
       d_lambdaLift(new LambdaLift(env)),
       d_ho(nullptr),
+      d_dpfgen(env),
       d_functionsTerms(context()),
       d_symb(env, instanceName),
       d_rewriter(nodeManager(), env.getRewriter()),
@@ -434,121 +435,8 @@ void TheoryUF::ppStaticLearn(TNode n, std::vector<TrustNode>& learned)
 {
   //TimerStat::CodeTimer codeTimer(d_staticLearningTimer);
 
-  vector<TNode> workList;
-  workList.push_back(n);
-  std::unordered_set<TNode> processed;
-
-  while(!workList.empty()) {
-    n = workList.back();
-
-    if (n.isClosure())
-    {
-      // unsafe to go under quantifiers; we might pull bound vars out of scope!
-      processed.insert(n);
-      workList.pop_back();
-      continue;
-    }
-
-    bool unprocessedChildren = false;
-    for(TNode::iterator i = n.begin(), iend = n.end(); i != iend; ++i) {
-      if(processed.find(*i) == processed.end()) {
-        // unprocessed child
-        workList.push_back(*i);
-        unprocessedChildren = true;
-      }
-    }
-
-    if(unprocessedChildren) {
-      continue;
-    }
-
-    workList.pop_back();
-    // has node n been processed in the meantime ?
-    if(processed.find(n) != processed.end()) {
-      continue;
-    }
-    processed.insert(n);
-
-    // == DIAMONDS ==
-
-    Trace("diamonds") << "===================== looking at" << endl
-                      << n << endl;
-
-    // binary OR of binary ANDs of EQUALities
-    if (n.getKind() == Kind::OR && n.getNumChildren() == 2
-        && n[0].getKind() == Kind::AND && n[0].getNumChildren() == 2
-        && n[1].getKind() == Kind::AND && n[1].getNumChildren() == 2
-        && (n[0][0].getKind() == Kind::EQUAL)
-        && (n[0][1].getKind() == Kind::EQUAL)
-        && (n[1][0].getKind() == Kind::EQUAL)
-        && (n[1][1].getKind() == Kind::EQUAL))
-    {
-      // now we have (a = b && c = d) || (e = f && g = h)
-
-      Trace("diamonds") << "has form of a diamond!" << endl;
-
-      TNode
-        a = n[0][0][0], b = n[0][0][1],
-        c = n[0][1][0], d = n[0][1][1],
-        e = n[1][0][0], f = n[1][0][1],
-        g = n[1][1][0], h = n[1][1][1];
-
-      // test that one of {a, b} = one of {c, d}, and make "b" the
-      // shared node (i.e. put in the form (a = b && b = d))
-      // note we don't actually care about the shared ones, so the
-      // "swaps" below are one-sided, ignoring b and c
-      if(a == c) {
-        a = b;
-      } else if(a == d) {
-        a = b;
-        d = c;
-      } else if(b == c) {
-        // nothing to do
-      } else if(b == d) {
-        d = c;
-      } else {
-        // condition not satisfied
-        Trace("diamonds") << "+ A fails" << endl;
-        continue;
-      }
-
-      Trace("diamonds") << "+ A holds" << endl;
-
-      // same: one of {e, f} = one of {g, h}, and make "f" the
-      // shared node (i.e. put in the form (e = f && f = h))
-      if(e == g) {
-        e = f;
-      } else if(e == h) {
-        e = f;
-        h = g;
-      } else if(f == g) {
-        // nothing to do
-      } else if(f == h) {
-        h = g;
-      } else {
-        // condition not satisfied
-        Trace("diamonds") << "+ B fails" << endl;
-        continue;
-      }
-
-      Trace("diamonds") << "+ B holds" << endl;
-
-      // now we have (a = b && b = d) || (e = f && f = h)
-      // test that {a, d} == {e, h}
-      if( (a == e && d == h) ||
-          (a == h && d == e) ) {
-        // learn: n implies a == d
-        Trace("diamonds") << "+ C holds" << endl;
-        Node newEquality = a.eqNode(d);
-        Trace("diamonds") << "  ==> " << newEquality << endl;
-        Node lem = n.impNode(newEquality);
-        TrustNode trn = TrustNode::mkTrustLemma(lem, nullptr);
-        learned.emplace_back(trn);
-      } else {
-        Trace("diamonds") << "+ C fails" << endl;
-      }
-    }
-  }
+  // Use the diamonds utility
+  d_dpfgen.ppStaticLearn(n, learned);
 
   if (options().uf.ufSymmetryBreaker)
   {
diff --git a/src/theory/uf/theory_uf.h b/src/theory/uf/theory_uf.h
index 0bafcaa79..dbcc75957 100644
--- a/src/theory/uf/theory_uf.h
+++ b/src/theory/uf/theory_uf.h
@@ -23,6 +23,7 @@
 #include "theory/theory.h"
 #include "theory/theory_eq_notify.h"
 #include "theory/theory_state.h"
+#include "theory/uf/diamonds_proof_generator.h"
 #include "theory/uf/proof_checker.h"
 #include "theory/uf/symmetry_breaker.h"
 #include "theory/uf/theory_uf_rewriter.h"
@@ -80,6 +81,8 @@ private:
   std::unique_ptr<HoExtension> d_ho;
   /** the conversions solver */
   std::unique_ptr<ConversionsSolver> d_csolver;
+  /** Diamonds proof generator */
+  DiamondsProofGenerator d_dpfgen;
 
   /** node for true */
   Node d_true;
-- 
2.47.1

