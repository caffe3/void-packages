From cb531649b667ebe89f94ca8e58d82ab18439c35e Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Wed, 20 Nov 2024 18:34:05 -0600
Subject: [PATCH 188/312] Refactor RARE arithmetic rules to avoid mixed
 arithmetic (#11376)

Ensures that mixed arithmetic cannot be introduced by RARE rules. This
fixes some known cases where mixed arithmetic appears even with
`--proof-elim-subtypes`

FYI @Lachnitt
---
 include/cvc5/cvc5_proof_rule.h  | 34 +++++++++++++++++-------------
 proofs/eo/cpc/rules/Rewrites.eo | 37 ++++++++++++++++++++++-----------
 src/theory/arith/rewrites       | 18 +++++++++-------
 3 files changed, 55 insertions(+), 34 deletions(-)

diff --git a/include/cvc5/cvc5_proof_rule.h b/include/cvc5/cvc5_proof_rule.h
index 26630f4ee..059e9c3c4 100644
--- a/include/cvc5/cvc5_proof_rule.h
+++ b/include/cvc5/cvc5_proof_rule.h
@@ -2948,16 +2948,18 @@ enum ENUM(ProofRewriteRule)
   EVALUE(SETS_INSERT_ELIM),
   // RARE rules
   // ${rules}$
-  /** Auto-generated from RARE rule arith-plus-zero */
-  EVALUE(ARITH_PLUS_ZERO),
   /** Auto-generated from RARE rule arith-mul-one */
   EVALUE(ARITH_MUL_ONE),
   /** Auto-generated from RARE rule arith-mul-zero */
   EVALUE(ARITH_MUL_ZERO),
-  /** Auto-generated from RARE rule arith-div-total */
-  EVALUE(ARITH_DIV_TOTAL),
-  /** Auto-generated from RARE rule arith-div-total-zero */
-  EVALUE(ARITH_DIV_TOTAL_ZERO),
+  /** Auto-generated from RARE rule arith-div-total-real */
+  EVALUE(ARITH_DIV_TOTAL_REAL),
+  /** Auto-generated from RARE rule arith-div-total-int */
+  EVALUE(ARITH_DIV_TOTAL_INT),
+  /** Auto-generated from RARE rule arith-div-total-zero-real */
+  EVALUE(ARITH_DIV_TOTAL_ZERO_REAL),
+  /** Auto-generated from RARE rule arith-div-total-zero-int */
+  EVALUE(ARITH_DIV_TOTAL_ZERO_INT),
   /** Auto-generated from RARE rule arith-int-div-total */
   EVALUE(ARITH_INT_DIV_TOTAL),
   /** Auto-generated from RARE rule arith-int-div-total-one */
@@ -2984,8 +2986,10 @@ enum ENUM(ProofRewriteRule)
   EVALUE(ARITH_LEQ_NORM),
   /** Auto-generated from RARE rule arith-geq-tighten */
   EVALUE(ARITH_GEQ_TIGHTEN),
-  /** Auto-generated from RARE rule arith-geq-norm1 */
-  EVALUE(ARITH_GEQ_NORM1),
+  /** Auto-generated from RARE rule arith-geq-norm1-int */
+  EVALUE(ARITH_GEQ_NORM1_INT),
+  /** Auto-generated from RARE rule arith-geq-norm1-real */
+  EVALUE(ARITH_GEQ_NORM1_REAL),
   /** Auto-generated from RARE rule arith-geq-norm2 */
   EVALUE(ARITH_GEQ_NORM2),
   /** Auto-generated from RARE rule arith-refl-leq */
@@ -2996,18 +3000,20 @@ enum ENUM(ProofRewriteRule)
   EVALUE(ARITH_REFL_GEQ),
   /** Auto-generated from RARE rule arith-refl-gt */
   EVALUE(ARITH_REFL_GT),
-  /** Auto-generated from RARE rule arith-real-eq-elim */
-  EVALUE(ARITH_REAL_EQ_ELIM),
-  /** Auto-generated from RARE rule arith-int-eq-elim */
-  EVALUE(ARITH_INT_EQ_ELIM),
+  /** Auto-generated from RARE rule arith-eq-elim-real */
+  EVALUE(ARITH_EQ_ELIM_REAL),
+  /** Auto-generated from RARE rule arith-eq-elim-int */
+  EVALUE(ARITH_EQ_ELIM_INT),
   /** Auto-generated from RARE rule arith-plus-flatten */
   EVALUE(ARITH_PLUS_FLATTEN),
   /** Auto-generated from RARE rule arith-mult-flatten */
   EVALUE(ARITH_MULT_FLATTEN),
   /** Auto-generated from RARE rule arith-mult-dist */
   EVALUE(ARITH_MULT_DIST),
-  /** Auto-generated from RARE rule arith-abs-elim */
-  EVALUE(ARITH_ABS_ELIM),
+  /** Auto-generated from RARE rule arith-abs-elim-int */
+  EVALUE(ARITH_ABS_ELIM_INT),
+  /** Auto-generated from RARE rule arith-abs-elim-real */
+  EVALUE(ARITH_ABS_ELIM_REAL),
   /** Auto-generated from RARE rule arith-to-real-elim */
   EVALUE(ARITH_TO_REAL_ELIM),
   /** Auto-generated from RARE rule arith-to-int-elim-to-real */
diff --git a/proofs/eo/cpc/rules/Rewrites.eo b/proofs/eo/cpc/rules/Rewrites.eo
index abf8c4c87..fd5cdc8e4 100644
--- a/proofs/eo/cpc/rules/Rewrites.eo
+++ b/proofs/eo/cpc/rules/Rewrites.eo
@@ -7,10 +7,6 @@
 (include "../theories/Strings.eo")
 (include "../theories/Sets.eo")
 
-(declare-rule arith-plus-zero ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
-  :args (t1 s1)
-  :conclusion (= ($singleton_elim (+ t1 0 s1)) ($singleton_elim (+ t1 s1)))
-)
 (declare-rule arith-mul-one ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
   :args (t1 s1)
   :conclusion (= ($singleton_elim (* t1 1 s1)) ($singleton_elim (* t1 s1)))
@@ -19,14 +15,23 @@
   :args (t1 s1)
   :conclusion (= ($singleton_elim (* t1 0 s1)) 0)
 )
-(declare-rule arith-div-total ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
+(declare-rule arith-div-total-real ((@T0 Type) (t1 @T0) (s1 Real))
+  :premises ((= (= s1 0/1) false))
+  :args (t1 s1)
+  :conclusion (= (/ t1 s1) (/_total t1 s1))
+)
+(declare-rule arith-div-total-int ((@T0 Type) (t1 @T0) (s1 Int))
   :premises ((= (= s1 0) false))
   :args (t1 s1)
   :conclusion (= (/ t1 s1) (/_total t1 s1))
 )
-(declare-rule arith-div-total-zero ((x1 Real))
-  :args (x1)
-  :conclusion (= (/_total x1 0/1) 0/1)
+(declare-rule arith-div-total-zero-real ((@T0 Type) (t1 @T0))
+  :args (t1)
+  :conclusion (= (/_total t1 0/1) 0/1)
+)
+(declare-rule arith-div-total-zero-int ((@T0 Type) (t1 @T0))
+  :args (t1)
+  :conclusion (= (/_total t1 0) 0/1)
 )
 (declare-rule arith-int-div-total ((t1 Int) (s1 Int))
   :premises ((= (= s1 0) false))
@@ -82,10 +87,14 @@
   :args (t1 s1)
   :conclusion (= (not (>= t1 s1)) (>= s1 (+ t1 1)))
 )
-(declare-rule arith-geq-norm1 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
+(declare-rule arith-geq-norm1-int ((t1 Int) (s1 Int))
   :args (t1 s1)
   :conclusion (= (>= t1 s1) (>= (- t1 s1) 0))
 )
+(declare-rule arith-geq-norm1-real ((t1 Real) (s1 Real))
+  :args (t1 s1)
+  :conclusion (= (>= t1 s1) (>= (- t1 s1) 0/1))
+)
 (declare-rule arith-geq-norm2 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
   :args (t1 s1)
   :conclusion (= (>= t1 s1) (<= (- t1) (- s1)))
@@ -106,11 +115,11 @@
   :args (t1)
   :conclusion (= (> t1 t1) false)
 )
-(declare-rule arith-real-eq-elim ((t1 Real) (s1 Real))
+(declare-rule arith-eq-elim-real ((t1 Real) (s1 Real))
   :args (t1 s1)
   :conclusion (= (= t1 s1) (and (>= t1 s1) (<= t1 s1)))
 )
-(declare-rule arith-int-eq-elim ((t1 Int) (s1 Int))
+(declare-rule arith-eq-elim-int ((t1 Int) (s1 Int))
   :args (t1 s1)
   :conclusion (= (= t1 s1) (and (>= t1 s1) (<= t1 s1)))
 )
@@ -126,10 +135,14 @@
   :args (x1 y1 z1 w1)
   :conclusion (= (* x1 (+ y1 z1 w1)) (+ (* x1 y1) (* x1 ($singleton_elim (+ z1 w1)))))
 )
-(declare-rule arith-abs-elim ((@T0 Type) (x1 @T0))
+(declare-rule arith-abs-elim-int ((x1 Int))
   :args (x1)
   :conclusion (= (abs x1) (ite (< x1 0) (- x1) x1))
 )
+(declare-rule arith-abs-elim-real ((x1 Real))
+  :args (x1)
+  :conclusion (= (abs x1) (ite (< x1 0/1) (- x1) x1))
+)
 (declare-rule arith-to-real-elim ((x1 Real))
   :args (x1)
   :conclusion (= (to_real x1) x1)
diff --git a/src/theory/arith/rewrites b/src/theory/arith/rewrites
index b9fa5d0dd..dfd2411bf 100644
--- a/src/theory/arith/rewrites
+++ b/src/theory/arith/rewrites
@@ -4,13 +4,13 @@
 ; interchangable. This is because Int and Real are not comparable in our
 ; type system.
 
-(define-rule arith-plus-zero ((t ? :list) (s ? :list)) (+ t 0 s) (+ t s))
-
 (define-rule arith-mul-one ((t ? :list) (s ? :list)) (* t 1 s) (* t s))
 (define-rule arith-mul-zero ((t ? :list) (s ? :list)) (* t 0 s) 0)
 
-(define-cond-rule arith-div-total ((t ?) (s ?)) (not (= s 0)) (/ t s) (/_total t s))
-(define-rule arith-div-total-zero ((x Real)) (/_total x 0/1) 0/1)
+(define-cond-rule arith-div-total-real ((t ?) (s Real)) (not (= s 0/1)) (/ t s) (/_total t s))
+(define-cond-rule arith-div-total-int ((t ?) (s Int)) (not (= s 0)) (/ t s) (/_total t s))
+(define-rule arith-div-total-zero-real ((t ?)) (/_total t 0/1) 0/1)
+(define-rule arith-div-total-zero-int ((t ?)) (/_total t 0) 0/1)
 
 (define-cond-rule arith-int-div-total ((t Int) (s Int)) (not (= s 0)) (div t s) (div_total t s))
 (define-rule arith-int-div-total-one ((t Int)) (div_total t 1) t)
@@ -31,7 +31,8 @@
 
 (define-rule arith-geq-tighten ((t Int) (s Int)) (not (>= t s)) (>= s (+ t 1)))
 
-(define-rule arith-geq-norm1 ((t ?) (s ?)) (>= t s) (>= (- t s) 0))
+(define-rule arith-geq-norm1-int ((t Int) (s Int)) (>= t s) (>= (- t s) 0))
+(define-rule arith-geq-norm1-real ((t Real) (s Real)) (>= t s) (>= (- t s) 0/1))
 
 (define-rule arith-geq-norm2 ((t ?) (s ?)) (>= t s) (<= (- t) (- s)))
 
@@ -40,8 +41,8 @@
 (define-rule arith-refl-geq ((t ?)) (>= t t) true)
 (define-rule arith-refl-gt ((t ?)) (> t t) false)
 
-(define-rule arith-real-eq-elim ((t Real) (s Real)) (= t s) (and (>= t s) (<= t s)))
-(define-rule arith-int-eq-elim ((t Int) (s Int)) (= t s) (and (>= t s) (<= t s)))
+(define-rule arith-eq-elim-real ((t Real) (s Real)) (= t s) (and (>= t s) (<= t s)))
+(define-rule arith-eq-elim-int ((t Int) (s Int)) (= t s) (and (>= t s) (<= t s)))
 
 ;(define-cond-rule arith-geq-contra ((t ?) (s ?)) (not (>= (- t s) 0)) (>= t s) false)
 ;(define-cond-rule arith-eq-contra ((t ?) (s ?)) (not (= (- t s) 0)) (= t s) false)
@@ -58,7 +59,8 @@
   (* x (+ y z w))
   (+ (* x y) (* x (+ z w))))
 
-(define-rule arith-abs-elim ((x ?)) (abs x) (ite (< x 0) (- x) x))
+(define-rule arith-abs-elim-int ((x Int)) (abs x) (ite (< x 0) (- x) x))
+(define-rule arith-abs-elim-real ((x Real)) (abs x) (ite (< x 0/1) (- x) x))
 
 (define-rule arith-to-real-elim ((x Real)) (to_real x) x)
 (define-rule arith-to-int-elim-to-real ((x ?)) (to_int (to_real x)) (to_int x))
-- 
2.47.1

