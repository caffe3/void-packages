From e8685bfae7c300d070d5f9ef566e38d6cd58ddc2 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Tue, 3 Sep 2024 12:13:19 -0500
Subject: [PATCH 044/312] Handle rare case of aliased purification variables in
 string infer proof cons (#11187)

We use a step that introduces purification skolems to ensure that
substitutions are applied properly to reason about string inferences.
However, this could lead to issues in very rare cases where the
purification skolem was already a part of the inference we are
processing.

This PR solves the issue by additionally purifying the purification
variables in the rare case this occurs. This occurs on 2 existing
regressions and in the regression added for the resolved issue.

Fixes https://github.com/cvc5/cvc5/issues/11164.
---
 src/smt/proof_post_processor.cpp              |  2 +
 src/theory/strings/infer_proof_cons.cpp       | 37 ++++++++++++++-----
 src/theory/strings/infer_proof_cons.h         | 10 +++--
 test/regress/cli/CMakeLists.txt               |  1 +
 .../strings/issue11164-double-purify.smt2     |  6 +++
 5 files changed, 42 insertions(+), 14 deletions(-)
 create mode 100644 test/regress/cli/regress0/strings/issue11164-double-purify.smt2

diff --git a/src/smt/proof_post_processor.cpp b/src/smt/proof_post_processor.cpp
index 3bd6a0f44..37fac7108 100644
--- a/src/smt/proof_post_processor.cpp
+++ b/src/smt/proof_post_processor.cpp
@@ -685,6 +685,8 @@ Node ProofPostprocessCallback::expandMacros(ProofRule id,
     {
       getMethodId(args[2], ida);
     }
+    Trace("smt-proof-pp-debug")
+        << "Expand SUBS " << ids << " " << ida << std::endl;
     std::vector<std::shared_ptr<CDProof>> pfs;
     std::vector<TNode> vsList;
     std::vector<TNode> ssList;
diff --git a/src/theory/strings/infer_proof_cons.cpp b/src/theory/strings/infer_proof_cons.cpp
index 6d83aac85..2b1536fd0 100644
--- a/src/theory/strings/infer_proof_cons.cpp
+++ b/src/theory/strings/infer_proof_cons.cpp
@@ -1290,6 +1290,21 @@ bool InferProofCons::purifyCoreSubstitution(
       termsToPurify.insert(nc[0]);
     }
   }
+  // To avoid rare issues where purification variables introduced by this method
+  // already appear in the inference, we also purify them here.
+  SkolemManager* sm = NodeManager::currentNM()->getSkolemManager();
+  SkolemId id;
+  Node cval;
+  for (const Node& nc : children)
+  {
+    // if this is a purification skolem of a term that is being purified,
+    // we purify this.
+    if (sm->isSkolemFunction(nc[0], id, cval) && id == SkolemId::PURIFY
+        && termsToPurify.find(cval) != termsToPurify.end())
+    {
+      termsToPurify.insert(nc[0]);
+    }
+  }
   // now, purify each of the children of the substitution
   for (size_t i = 0, nchild = children.size(); i < nchild; i++)
   {
@@ -1313,11 +1328,12 @@ bool InferProofCons::purifyCoreSubstitution(
   return true;
 }
 
-Node InferProofCons::purifyPredicate(PurifyType pt,
-                                     Node lit,
-                                     bool concludeNew,
-                                     TheoryProofStepBuffer& psb,
-                                     std::unordered_set<Node>& termsToPurify)
+Node InferProofCons::purifyPredicate(
+    PurifyType pt,
+    Node lit,
+    bool concludeNew,
+    TheoryProofStepBuffer& psb,
+    const std::unordered_set<Node>& termsToPurify)
 {
   bool pol = lit.getKind() != Kind::NOT;
   Node atom = pol ? lit : lit[0];
@@ -1387,8 +1403,8 @@ Node InferProofCons::purifyPredicate(PurifyType pt,
   return newLit;
 }
 
-Node InferProofCons::purifyCoreTerm(Node n,
-                                    std::unordered_set<Node>& termsToPurify)
+Node InferProofCons::purifyCoreTerm(
+    Node n, const std::unordered_set<Node>& termsToPurify)
 {
   if (n.getKind() == Kind::STRING_CONCAT)
   {
@@ -1402,7 +1418,8 @@ Node InferProofCons::purifyCoreTerm(Node n,
   return maybePurifyTerm(n, termsToPurify);
 }
 
-Node InferProofCons::purifyApp(Node n, std::unordered_set<Node>& termsToPurify)
+Node InferProofCons::purifyApp(Node n,
+                               const std::unordered_set<Node>& termsToPurify)
 {
   if (n.getNumChildren() == 0)
   {
@@ -1416,8 +1433,8 @@ Node InferProofCons::purifyApp(Node n, std::unordered_set<Node>& termsToPurify)
   return NodeManager::currentNM()->mkNode(n.getKind(), pcs);
 }
 
-Node InferProofCons::maybePurifyTerm(Node n,
-                                     std::unordered_set<Node>& termsToPurify)
+Node InferProofCons::maybePurifyTerm(
+    Node n, const std::unordered_set<Node>& termsToPurify)
 {
   if (termsToPurify.find(n) == termsToPurify.end())
   {
diff --git a/src/theory/strings/infer_proof_cons.h b/src/theory/strings/infer_proof_cons.h
index d5cbb187a..919dd7f43 100644
--- a/src/theory/strings/infer_proof_cons.h
+++ b/src/theory/strings/infer_proof_cons.h
@@ -252,24 +252,26 @@ class InferProofCons : protected EnvObj, public ProofGenerator
                               Node lit,
                               bool concludeNew,
                               TheoryProofStepBuffer& psb,
-                              std::unordered_set<Node>& termsToPurify);
+                              const std::unordered_set<Node>& termsToPurify);
   /**
    * Purify term with respect to a set of terms to purify. This replaces
    * all terms to purify with their purification variables that occur in
    * positions that are relevant for the core calculus of strings (direct
    * children of concat or equal).
    */
-  static Node purifyCoreTerm(Node n, std::unordered_set<Node>& termsToPurify);
+  static Node purifyCoreTerm(Node n,
+                             const std::unordered_set<Node>& termsToPurify);
   /**
    * Purify application, which replaces each direct child nc of n with
    * maybePurifyTerm(nc, termsToPurify).
    */
-  static Node purifyApp(Node n, std::unordered_set<Node>& termsToPurify);
+  static Node purifyApp(Node n, const std::unordered_set<Node>& termsToPurify);
   /**
    * Maybe purify term, which returns the skolem variable for n if it occurs
    * in termsToPurify.
    */
-  static Node maybePurifyTerm(Node n, std::unordered_set<Node>& termsToPurify);
+  static Node maybePurifyTerm(Node n,
+                              const std::unordered_set<Node>& termsToPurify);
   /** The lazy fact map */
   NodeInferInfoMap d_lazyFactMap;
   /** Reference to the statistics for the theory of strings/sequences. */
diff --git a/test/regress/cli/CMakeLists.txt b/test/regress/cli/CMakeLists.txt
index bcd6504d0..b9ccf781a 100644
--- a/test/regress/cli/CMakeLists.txt
+++ b/test/regress/cli/CMakeLists.txt
@@ -1790,6 +1790,7 @@ set(regress_0_tests
   regress0/strings/instance13131.smt2
   regress0/strings/instance15449.smt2
   regress0/strings/is_digit_simple.smt2
+  regress0/strings/issue11164-double-purify.smt2
   regress0/strings/issue11168.smt2
   regress0/strings/issue1189.smt2
   regress0/strings/issue2958.smt2
diff --git a/test/regress/cli/regress0/strings/issue11164-double-purify.smt2 b/test/regress/cli/regress0/strings/issue11164-double-purify.smt2
new file mode 100644
index 000000000..9caed72ea
--- /dev/null
+++ b/test/regress/cli/regress0/strings/issue11164-double-purify.smt2
@@ -0,0 +1,6 @@
+; EXPECT: unsat
+(set-logic ALL)
+(declare-const a String)  
+(declare-const b Int)  
+(assert (not (str.contains (str.replace_all a "a" a) (str.at a b)))) 
+(check-sat)
-- 
2.47.1

