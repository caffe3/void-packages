From d1d842cff52758e01fc15ec6af39a757d8caa95c Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Fri, 15 Nov 2024 15:10:37 -0600
Subject: [PATCH 177/312] Fill in remaining datatypes rewrites (#11346)

Makes two changes:
- Adds a new ad-hoc rewrite for updaters,
- Makes the RARE preprocessor ensure parameteric datatype constructors
are annotated (which is a no-op in cpc proofs).

Also fixes an issue where function array constants were not being
properly converted, as they need to be converted again after being
converted to a lambda.
---
 include/cvc5/cvc5_proof_rule.h              | 17 +++++++++++
 src/api/cpp/cvc5_proof_rule_template.cpp    |  1 +
 src/rewriter/rewrite_db_term_process.cpp    | 33 +++++++++++++++++++--
 src/rewriter/rewrite_db_term_process.h      |  1 +
 src/theory/datatypes/datatypes_rewriter.cpp | 23 ++++++++++++++
 5 files changed, 73 insertions(+), 2 deletions(-)

diff --git a/include/cvc5/cvc5_proof_rule.h b/include/cvc5/cvc5_proof_rule.h
index 508e6be94..2ef2de512 100644
--- a/include/cvc5/cvc5_proof_rule.h
+++ b/include/cvc5/cvc5_proof_rule.h
@@ -2690,6 +2690,23 @@ enum ENUM(ProofRewriteRule)
    * \endverbatim
    */
   EVALUE(DT_CONS_EQ),
+  /**
+   * \verbatim embed:rst:leading-asterisk
+   * **Datatypes -- collapse tester**
+   *
+   * .. math::
+   *   u_{c,i}(c(t_1, \ldots, t_i, \ldots, t_n), s) = c(t_1, \ldots, s, \ldots, t_n)
+   *
+   * or alternatively
+   *
+   * .. math::
+   *   u_{c,i}(d(t_1, \ldots, t_n), s) = d(t_1, \ldots, t_n)
+   *
+   * where :math:`c` and :math:`d` are distinct constructors.
+   *
+   * \endverbatim
+   */
+  EVALUE(DT_COLLAPSE_UPDATER),
   /**
    * \verbatim embed:rst:leading-asterisk
    * **Datatypes - updater elimination**
diff --git a/src/api/cpp/cvc5_proof_rule_template.cpp b/src/api/cpp/cvc5_proof_rule_template.cpp
index 976faf785..a7a95b64c 100644
--- a/src/api/cpp/cvc5_proof_rule_template.cpp
+++ b/src/api/cpp/cvc5_proof_rule_template.cpp
@@ -258,6 +258,7 @@ const char* toString(cvc5::ProofRewriteRule rule)
     case ProofRewriteRule::DT_COLLAPSE_TESTER_SINGLETON:
       return "dt-collapse-tester-singleton";
     case ProofRewriteRule::DT_CONS_EQ: return "dt-cons-eq";
+    case ProofRewriteRule::DT_COLLAPSE_UPDATER: return "dt-collapse-updater";
     case ProofRewriteRule::DT_UPDATER_ELIM: return "dt-updater-elim";
     case ProofRewriteRule::DT_MATCH_ELIM: return "dt-match-elim";
     case ProofRewriteRule::BV_UMULO_ELIMINATE: return "bv-umulo-eliminate";
diff --git a/src/rewriter/rewrite_db_term_process.cpp b/src/rewriter/rewrite_db_term_process.cpp
index a1ea54eda..4a6abdd53 100644
--- a/src/rewriter/rewrite_db_term_process.cpp
+++ b/src/rewriter/rewrite_db_term_process.cpp
@@ -16,10 +16,13 @@
 #include "rewriter/rewrite_db_term_process.h"
 
 #include "expr/attribute.h"
+#include "expr/dtype.h"
+#include "expr/dtype_cons.h"
 #include "expr/nary_term_util.h"
 #include "proof/conv_proof_generator.h"
 #include "theory/builtin/generic_op.h"
 #include "theory/bv/theory_bv_utils.h"
+#include "theory/datatypes/theory_datatypes_utils.h"
 #include "theory/strings/theory_strings_utils.h"
 #include "theory/uf/function_const.h"
 #include "theory/uf/theory_uf_rewriter.h"
@@ -42,7 +45,6 @@ RewriteDbNodeConverter::RewriteDbNodeConverter(NodeManager* nm,
 Node RewriteDbNodeConverter::postConvert(Node n)
 {
   Kind k = n.getKind();
-  TypeNode tn = n.getType();
   if (k == Kind::CONST_STRING)
   {
     NodeManager* nm = NodeManager::currentNM();
@@ -85,7 +87,8 @@ Node RewriteDbNodeConverter::postConvert(Node n)
   {
     Node ret = theory::uf::FunctionConst::toLambda(n);
     recordProofStep(n, ret, ProofRule::ENCODE_EQ_INTRO);
-    return ret;
+    // must convert again
+    return convert(ret);
   }
   else if (k == Kind::FORALL)
   {
@@ -104,6 +107,32 @@ Node RewriteDbNodeConverter::postConvert(Node n)
     recordProofStep(n, ret, ProofRule::ENCODE_EQ_INTRO);
     return ret;
   }
+  else if (k == Kind::APPLY_CONSTRUCTOR)
+  {
+    // We apply annotations to parametric datatype constructors, which is
+    // a no-op based on our proof signature.
+    TypeNode tn = n.getType();
+    if (tn.isParametricDatatype())
+    {
+      if (n.getOperator().getKind() != Kind::APPLY_TYPE_ASCRIPTION)
+      {
+        Node op = n.getOperator();
+        size_t index = theory::datatypes::utils::indexOf(op);
+        // get the constructor object
+        const DTypeConstructor& dtc =
+            theory::datatypes::utils::datatypeOf(op)[index];
+        // create ascribed constructor type
+        Node op_new = dtc.getInstantiatedConstructor(tn);
+        // make new node
+        std::vector<Node> children;
+        children.push_back(op_new);
+        children.insert(children.end(), n.begin(), n.end());
+        Node inr = d_nm->mkNode(Kind::APPLY_CONSTRUCTOR, children);
+        recordProofStep(n, inr, ProofRule::ENCODE_EQ_INTRO);
+        return inr;
+      }
+    }
+  }
   // convert indexed operators to symbolic
   if (GenericOp::isNumeralIndexedOperatorKind(k))
   {
diff --git a/src/rewriter/rewrite_db_term_process.h b/src/rewriter/rewrite_db_term_process.h
index 9ac1f241d..a9368e6bd 100644
--- a/src/rewriter/rewrite_db_term_process.h
+++ b/src/rewriter/rewrite_db_term_process.h
@@ -39,6 +39,7 @@ namespace rewriter {
  * (4) Quantifier patterns are dropped.
  * (5) APPLY_UF is converted to HO_APPLY chains.
  * (6) Function constants are converted to lambdas.
+ * (7) Annotations are applied to parametric datatype constructors.
  *
  * This node converter converts from the default representation of cvc5 terms
  * to the representation of terms required by the DSL proof reconstruction
diff --git a/src/theory/datatypes/datatypes_rewriter.cpp b/src/theory/datatypes/datatypes_rewriter.cpp
index b6487933e..2c500b85a 100644
--- a/src/theory/datatypes/datatypes_rewriter.cpp
+++ b/src/theory/datatypes/datatypes_rewriter.cpp
@@ -51,6 +51,8 @@ DatatypesRewriter::DatatypesRewriter(NodeManager* nm,
                            TheoryRewriteCtx::PRE_DSL);
   registerProofRewriteRule(ProofRewriteRule::DT_CONS_EQ,
                            TheoryRewriteCtx::PRE_DSL);
+  registerProofRewriteRule(ProofRewriteRule::DT_COLLAPSE_UPDATER,
+                           TheoryRewriteCtx::PRE_DSL);
   registerProofRewriteRule(ProofRewriteRule::DT_UPDATER_ELIM,
                            TheoryRewriteCtx::PRE_DSL);
   registerProofRewriteRule(ProofRewriteRule::DT_MATCH_ELIM,
@@ -153,6 +155,27 @@ Node DatatypesRewriter::rewriteViaRule(ProofRewriteRule id, const Node& n)
       }
     }
     break;
+    case ProofRewriteRule::DT_COLLAPSE_UPDATER:
+    {
+      if (n.getKind() != Kind::APPLY_UPDATER
+          || n[0].getKind() != Kind::APPLY_CONSTRUCTOR)
+      {
+        return Node::null();
+      }
+      Node op = n.getOperator();
+      size_t cindex = utils::indexOf(n[0].getOperator());
+      size_t cuindex = utils::cindexOf(op);
+      if (cindex == cuindex)
+      {
+        size_t updateIndex = utils::indexOf(op);
+        std::vector<Node> children(n[0].begin(), n[0].end());
+        children[updateIndex] = n[1];
+        children.insert(children.begin(), n[0].getOperator());
+        return d_nm->mkNode(Kind::APPLY_CONSTRUCTOR, children);
+      }
+      return n[0];
+    }
+    break;
     case ProofRewriteRule::DT_MATCH_ELIM:
     {
       if (n.getKind() == Kind::MATCH)
-- 
2.47.1

