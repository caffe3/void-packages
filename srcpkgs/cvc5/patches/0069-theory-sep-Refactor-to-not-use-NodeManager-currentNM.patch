From a9485920a6c760e716080e60a0d55f5717d33e55 Mon Sep 17 00:00:00 2001
From: Daniel Larraz <daniel-larraz@users.noreply.github.com>
Date: Tue, 24 Sep 2024 15:45:38 -0500
Subject: [PATCH 069/312] theory sep: Refactor to not use
 NodeManager::currentNM() (#11223)

---
 src/theory/sep/theory_sep.cpp | 95 +++++++++++++++++------------------
 src/theory/sep/theory_sep.h   |  2 +-
 2 files changed, 48 insertions(+), 49 deletions(-)

diff --git a/src/theory/sep/theory_sep.cpp b/src/theory/sep/theory_sep.cpp
index b185e12cd..3cfae3a16 100644
--- a/src/theory/sep/theory_sep.cpp
+++ b/src/theory/sep/theory_sep.cpp
@@ -56,8 +56,8 @@ TheorySep::TheorySep(Env& env, OutputChannel& out, Valuation valuation)
       d_bound_kind(bound_invalid),
       d_card_max(0)
 {
-  d_true = NodeManager::currentNM()->mkConst<bool>(true);
-  d_false = NodeManager::currentNM()->mkConst<bool>(false);
+  d_true = nodeManager()->mkConst<bool>(true);
+  d_false = nodeManager()->mkConst<bool>(false);
   d_tiid = mkTrustId(TrustId::THEORY_INFERENCE);
   d_tsid = builtin::BuiltinProofRuleChecker::mkTheoryIdNode(THEORY_SEP);
 
@@ -85,8 +85,7 @@ void TheorySep::initializeHeapTypes()
     Trace("sep-type") << "Sep: assume location type " << d_type_ref
                       << " is associated with data type " << d_type_data
                       << std::endl;
-    d_nil_ref =
-        NodeManager::currentNM()->mkNullaryOperator(d_type_ref, Kind::SEP_NIL);
+    d_nil_ref = nodeManager()->mkNullaryOperator(d_type_ref, Kind::SEP_NIL);
     d_bound_kind = bound_default;
   }
 }
@@ -171,7 +170,7 @@ void TheorySep::postProcessModel( TheoryModel* m ){
     }
   }
 
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   std::vector< Node > sep_children;
   Node m_neq;
   Node m_heap;
@@ -234,7 +233,7 @@ void TheorySep::postProcessModel( TheoryModel* m ){
       }
       Trace("sep-model") << std::endl;
       sep_children.push_back(
-          NodeManager::currentNM()->mkNode(Kind::SEP_PTO, pto_children));
+          nodeManager()->mkNode(Kind::SEP_PTO, pto_children));
     }
   }
   Assert(!d_nil_ref.isNull());
@@ -333,7 +332,7 @@ void TheorySep::reduceFact(TNode atom, bool polarity, TNode fact)
   d_reduce.insert(fact);
   TNode satom = atom.getKind() == Kind::SEP_LABEL ? atom[0] : atom;
   TNode slbl = atom.getKind() == Kind::SEP_LABEL ? atom[1] : TNode::null();
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   SkolemManager* sm = nm->getSkolemManager();
   if (slbl.isNull())
   {
@@ -513,7 +512,7 @@ void TheorySep::postCheck(Effort level)
   {
     return;
   }
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   SkolemManager* sm = nm->getSkolemManager();
   Trace("sep-process") << "Checking heap at full effort..." << std::endl;
   d_label_model.clear();
@@ -716,7 +715,7 @@ void TheorySep::postCheck(Effort level)
     Assert(!d_type_ref.isNull());
     TypeNode tn = nm->mkSetType(d_type_ref);
     // tn = nm->mkSetType(nm->mkRefType(tn));
-    Node o_b_lbl_mval = d_label_model[slbl].getValue(tn);
+    Node o_b_lbl_mval = d_label_model[slbl].getValue(nodeManager(), tn);
     Trace("sep-process") << "    Model for " << slbl << " : " << o_b_lbl_mval
                          << std::endl;
 
@@ -728,7 +727,7 @@ void TheorySep::postCheck(Effort level)
       int sub_index = sub_element.first;
       Node sub_lbl = sub_element.second;
       computeLabelModel(sub_lbl);
-      Node lbl_mval = d_label_model[sub_lbl].getValue(tn);
+      Node lbl_mval = d_label_model[sub_lbl].getValue(nodeManager(), tn);
       Trace("sep-process-debug") << "  child " << sub_index << " : " << sub_lbl
                                  << ", mval = " << lbl_mval << std::endl;
       mvals[sub_index] = lbl_mval;
@@ -1116,7 +1115,7 @@ void TheorySep::initializeBounds() {
   {
     return;
   }
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   SkolemManager* sm = nm->getSkolemManager();
   Trace("sep-bound") << "Initialize bounds for " << d_type_ref << "..."
                      << std::endl;
@@ -1151,7 +1150,7 @@ Node TheorySep::getBaseLabel()
   {
     return d_base_label;
   }
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   SkolemManager* sm = nm->getSkolemManager();
   initializeBounds();
   Trace("sep") << "Make base label for " << d_type_ref << std::endl;
@@ -1255,17 +1254,17 @@ Node TheorySep::getBaseLabel()
 Node TheorySep::mkUnion( TypeNode tn, std::vector< Node >& locs ) {
   Node u;
   if( locs.empty() ){
-    TypeNode ltn = NodeManager::currentNM()->mkSetType(tn);
-    return NodeManager::currentNM()->mkConst(EmptySet(ltn));
+    TypeNode ltn = nodeManager()->mkSetType(tn);
+    return nodeManager()->mkConst(EmptySet(ltn));
   }else{
     for( unsigned i=0; i<locs.size(); i++ ){
       Node s = locs[i];
       Assert(!s.isNull());
-      s = NodeManager::currentNM()->mkNode(Kind::SET_SINGLETON, s);
+      s = nodeManager()->mkNode(Kind::SET_SINGLETON, s);
       if( u.isNull() ){
         u = s;
       }else{
-        u = NodeManager::currentNM()->mkNode(Kind::SET_UNION, s, u);
+        u = nodeManager()->mkNode(Kind::SET_UNION, s, u);
       }
     }
     return u;
@@ -1275,12 +1274,12 @@ Node TheorySep::mkUnion( TypeNode tn, std::vector< Node >& locs ) {
 Node TheorySep::getLabel( Node atom, int child, Node lbl ) {
   std::map< int, Node >::iterator it = d_label_map[atom][lbl].find( child );
   if( it==d_label_map[atom][lbl].end() ){
-    NodeManager* nm = NodeManager::currentNM();
+    NodeManager* nm = nodeManager();
     SkolemManager* sm = nm->getSkolemManager();
     Assert(!d_type_ref.isNull());
     std::stringstream ss;
     ss << "__Lc" << child;
-    TypeNode ltn = NodeManager::currentNM()->mkSetType(d_type_ref);
+    TypeNode ltn = nodeManager()->mkSetType(d_type_ref);
     Node n_lbl = sm->mkDummySkolem(ss.str(), ltn, "sep label");
     d_label_map[atom][lbl][child] = n_lbl;
     return n_lbl;
@@ -1306,7 +1305,7 @@ void TheorySep::makeDisjointHeap(Node parent, const std::vector<Node>& children)
     d_parentMap[c].push_back(parent);
   }
   // make the disjointness constraints
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   std::vector<Node> lems;
   Node ulem = nm->mkNode(Kind::SET_UNION, children[0], children[1]);
   size_t lsize = children.size();
@@ -1384,7 +1383,7 @@ bool TheorySep::sharesRootLabel(Node p, Node q) const
 
 Node TheorySep::applyLabel( Node n, Node lbl, std::map< Node, Node >& visited ) {
   Assert(n.getKind() != Kind::SEP_LABEL);
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   Kind k = n.getKind();
   std::map<Node, Node>::iterator it = visited.find(n);
   if (it != visited.end())
@@ -1439,7 +1438,7 @@ Node TheorySep::instantiateLabel(Node n,
                                  std::map<Node, bool>& active_lbl,
                                  unsigned ind)
 {
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   Trace("sep-inst-debug") << "Instantiate label " << n << " " << lbl << " " << lbl_v << std::endl;
   if (options().sep.sepMinimalRefine && lbl != o_lbl
       && active_lbl.find(lbl) != active_lbl.end())
@@ -1477,12 +1476,14 @@ Node TheorySep::instantiateLabel(Node n,
             Node sub_lbl_0 = d_label_map[n][lbl][0];
             computeLabelModel( sub_lbl_0 );
             Assert(d_label_model.find(sub_lbl_0) != d_label_model.end());
-            lbl_mval = NodeManager::currentNM()->mkNode(
-                Kind::SET_UNION, lbl, d_label_model[sub_lbl_0].getValue(rtn));
+            lbl_mval = nodeManager()->mkNode(
+                Kind::SET_UNION,
+                lbl,
+                d_label_model[sub_lbl_0].getValue(nodeManager(), rtn));
           }else{
             computeLabelModel( sub_lbl );
             Assert(d_label_model.find(sub_lbl) != d_label_model.end());
-            lbl_mval = d_label_model[sub_lbl].getValue( rtn );
+            lbl_mval = d_label_model[sub_lbl].getValue(nodeManager(), rtn);
           }
           Trace("sep-inst-debug") << "Sublabel value is " << lbl_mval  << std::endl;
           mvals[sub_index] = lbl_mval;
@@ -1491,7 +1492,7 @@ Node TheorySep::instantiateLabel(Node n,
             return Node::null();
           }
         }
-        Node empSet = NodeManager::currentNM()->mkConst(EmptySet(rtn));
+        Node empSet = nodeManager()->mkConst(EmptySet(rtn));
         if (n.getKind() == Kind::SEP_STAR)
         {
           //disjoint contraints
@@ -1502,9 +1503,9 @@ Node TheorySep::instantiateLabel(Node n,
           std::vector< Node > vs;
           for( std::map< int, Node >::iterator itl = d_label_map[n][lbl].begin(); itl != d_label_map[n][lbl].end(); ++itl ){
             Node sub_lbl = itl->second;
-            Node lbl_mval = d_label_model[sub_lbl].getValue( rtn );
+            Node lbl_mval = d_label_model[sub_lbl].getValue(nodeManager(), rtn);
             for( unsigned j=0; j<vs.size(); j++ ){
-              bchildren.push_back(NodeManager::currentNM()
+              bchildren.push_back(nodeManager()
                                       ->mkNode(Kind::SET_INTER, lbl_mval, vs[j])
                                       .eqNode(empSet));
             }
@@ -1512,22 +1513,21 @@ Node TheorySep::instantiateLabel(Node n,
             if( vsu.isNull() ){
               vsu = lbl_mval;
             }else{
-              vsu = NodeManager::currentNM()->mkNode(
-                  Kind::SET_UNION, vsu, lbl_mval);
+              vsu = nodeManager()->mkNode(Kind::SET_UNION, vsu, lbl_mval);
             }
           }
           bchildren.push_back( vsu.eqNode( lbl ) );
 
           Assert(bchildren.size() > 1);
-          conj.push_back(
-              NodeManager::currentNM()->mkNode(Kind::AND, bchildren));
-          return NodeManager::currentNM()->mkOr(conj);
+          conj.push_back(nodeManager()->mkNode(Kind::AND, bchildren));
+          return nodeManager()->mkOr(conj);
         }else{
           std::vector< Node > wchildren;
           //disjoint constraints
           Node sub_lbl_0 = d_label_map[n][lbl][0];
-          Node lbl_mval_0 = d_label_model[sub_lbl_0].getValue( rtn );
-          wchildren.push_back(NodeManager::currentNM()
+          Node lbl_mval_0 =
+              d_label_model[sub_lbl_0].getValue(nodeManager(), rtn);
+          wchildren.push_back(nodeManager()
                                   ->mkNode(Kind::SET_INTER, lbl_mval_0, lbl)
                                   .eqNode(empSet)
                                   .negate());
@@ -1535,11 +1535,11 @@ Node TheorySep::instantiateLabel(Node n,
           //return the lemma
           wchildren.push_back( children[0].negate() );
           wchildren.push_back( children[1] );
-          return NodeManager::currentNM()->mkNode(Kind::OR, wchildren);
+          return nodeManager()->mkNode(Kind::OR, wchildren);
         }
       }else{
         //nested star/wand, label it and return
-        return NodeManager::currentNM()->mkNode(Kind::SEP_LABEL, n, lbl_v);
+        return nodeManager()->mkNode(Kind::SEP_LABEL, n, lbl_v);
       }
     }
     else if (n.getKind() == Kind::SEP_PTO)
@@ -1553,9 +1553,9 @@ Node TheorySep::instantiateLabel(Node n,
       std::vector< Node > children;
       if( inBaseHeap ){
         Node s = nm->mkNode(Kind::SET_SINGLETON, n[0]);
-        children.push_back(NodeManager::currentNM()->mkNode(
+        children.push_back(nodeManager()->mkNode(
             Kind::SEP_LABEL,
-            NodeManager::currentNM()->mkNode(Kind::SEP_PTO, n[0], n[1]),
+            nodeManager()->mkNode(Kind::SEP_PTO, n[0], n[1]),
             s));
       }else{
         //look up value of data
@@ -1576,8 +1576,7 @@ Node TheorySep::instantiateLabel(Node n,
     }
     else if (n.getKind() == Kind::SEP_EMP)
     {
-      return lbl_v.eqNode(
-          NodeManager::currentNM()->mkConst(EmptySet(lbl_v.getType())));
+      return lbl_v.eqNode(nodeManager()->mkConst(EmptySet(lbl_v.getType())));
     }else{
       std::map< Node, Node >::iterator it = visited.find( n );
       if( it==visited.end() ){
@@ -1598,7 +1597,7 @@ Node TheorySep::instantiateLabel(Node n,
         }
         Node ret = n;
         if( childChanged ){
-          ret = NodeManager::currentNM()->mkNode( n.getKind(), children );
+          ret = nodeManager()->mkNode(n.getKind(), children);
         }
         //careful about caching
         //visited[n] = ret;
@@ -1657,7 +1656,7 @@ void TheorySep::computeLabelModel( Node lbl ) {
     return;
   }
   d_label_model[lbl].d_computed = true;
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   // we must get the value of lbl from the model: this is being run at last
   // call, after the model is constructed Assert(...); TODO
   Node v_val = d_valuation.getModel()->getRepresentative(lbl);
@@ -1780,7 +1779,7 @@ bool TheorySep::checkPto(HeapAssertInfo* e, Node p, bool polarity)
 {
   Assert(e != nullptr);
   Assert(p.getKind() == Kind::SEP_LABEL && p[0].getKind() == Kind::SEP_PTO);
-  NodeManager* nm = NodeManager::currentNM();
+  NodeManager* nm = nodeManager();
   Node plbl = p[1];
   Node pval = p[0][1];
   bool ret = true;
@@ -1891,7 +1890,7 @@ void TheorySep::sendLemma( std::vector< Node >& ant, Node conc, InferenceId id,
   Trace("sep-lemma-debug") << "Got : " << conc << std::endl;
   if( conc!=d_true ){
     if( infer && conc!=d_false ){
-      Node ant_n = NodeManager::currentNM()->mkAnd(ant);
+      Node ant_n = nodeManager()->mkAnd(ant);
       Trace("sep-lemma") << "Sep::Infer: " << conc << " from " << ant_n << " by " << id << std::endl;
       d_im.addPendingFact(conc, id, ant_n);
     }else{
@@ -1917,16 +1916,16 @@ void TheorySep::doPending()
   d_im.doPendingLemmas();
 }
 
-Node TheorySep::HeapInfo::getValue( TypeNode tn ) {
+Node TheorySep::HeapInfo::getValue(NodeManager* nm, TypeNode tn)
+{
   Assert(d_heap_locs.size() == d_heap_locs_model.size());
   if( d_heap_locs.empty() ){
-    return NodeManager::currentNM()->mkConst(EmptySet(tn));
+    return nm->mkConst(EmptySet(tn));
   }
   Node curr = d_heap_locs[0];
   for (unsigned j = 1; j < d_heap_locs.size(); j++)
   {
-    curr =
-        NodeManager::currentNM()->mkNode(Kind::SET_UNION, d_heap_locs[j], curr);
+    curr = nm->mkNode(Kind::SET_UNION, d_heap_locs[j], curr);
   }
   return curr;
 }
diff --git a/src/theory/sep/theory_sep.h b/src/theory/sep/theory_sep.h
index b077fc569..4d2cb9866 100644
--- a/src/theory/sep/theory_sep.h
+++ b/src/theory/sep/theory_sep.h
@@ -327,7 +327,7 @@ class TheorySep : public Theory {
     std::vector< Node > d_heap_locs;
     std::vector< Node > d_heap_locs_model;
     //get value
-    Node getValue( TypeNode tn );
+    Node getValue(NodeManager* nm, TypeNode tn);
   };
   //heap info ( label -> HeapInfo )
   std::map< Node, HeapInfo > d_label_model;
-- 
2.47.1

