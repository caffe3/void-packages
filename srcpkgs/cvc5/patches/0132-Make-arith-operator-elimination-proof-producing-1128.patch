From 79b550780506cabd4808e666b3a1adc3e9ca5e82 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Sat, 19 Oct 2024 12:44:13 -0500
Subject: [PATCH 132/312] Make arith operator elimination proof producing
 (#11280)

This module eliminates extended arithmetic operators (e.g. division)
during preprocessing.

This fills 281 trusted theory preprocessing steps in our regressions.

The main changes are to make the core method of arith::OperatorElim
static and accessible via the proof checker and the solver
simultaneously. The proof rule ARITH_OP_ELIM_AXIOM (which previously
existed as a placeholder) is now implemented. This required several
simplifications to the code, and the deletion of an expert option.

A followup PR will formalize this rule in CPC+Eunoia.
---
 include/cvc5/cvc5_proof_rule.h                |  16 +-
 src/api/cpp/cvc5_proof_rule_template.cpp      |   2 +-
 src/options/arith_options.toml                |   8 -
 src/smt/expand_definitions.cpp                |   6 +-
 src/theory/arith/arith_preprocess.cpp         |   1 -
 src/theory/arith/arith_preprocess.h           |   1 -
 src/theory/arith/operator_elim.cpp            | 262 ++++++++++--------
 src/theory/arith/operator_elim.h              |  56 ++--
 src/theory/arith/proof_checker.cpp            |   6 +-
 src/theory/arith/theory_arith.cpp             |   2 +-
 .../cli/regress1/nl/arctan2-expdef.smt2       |   1 -
 .../regress1/nl/issue7924-sqrt-partial.smt2   |   2 +-
 12 files changed, 206 insertions(+), 157 deletions(-)

diff --git a/include/cvc5/cvc5_proof_rule.h b/include/cvc5/cvc5_proof_rule.h
index 7f4585de8..00aecd89d 100644
--- a/include/cvc5/cvc5_proof_rule.h
+++ b/include/cvc5/cvc5_proof_rule.h
@@ -1892,13 +1892,23 @@ enum ENUM(ProofRule)
   EVALUE(ARITH_TRICHOTOMY),
   /**
    * \verbatim embed:rst:leading-asterisk
-   * **Arithmetic -- Operator elimination**
+   * **Arithmetic -- Reduction**
    *
    * .. math::
-   *   \inferrule{- \mid t}{\texttt{arith::OperatorElim::getAxiomFor(t)}}
+   *   \inferrule{- \mid t}{F}
+   * 
+   * where :math:`t` is an application of an extended arithmetic operator (e.g.
+   * division, modulus, cosine, sqrt, is_int, to_int) and :math:`F` is the
+   * reduction predicate for :math:`t`. In other words, :math:`F` is a
+   * predicate that is used to reduce reasoning about :math:`t` to reasoning
+   * about the core operators of arithmetic.
+   *
+   * In detail, :math:`F` is implemented by
+   * :math:`\texttt{arith::OperatorElim::getAxiomFor(t)}`, see
+   * :cvc5src:`theory/arith/operator_elim.h`.
    * \endverbatim
    */
-  EVALUE(ARITH_OP_ELIM_AXIOM),
+  EVALUE(ARITH_REDUCTION),
   /**
    * \verbatim embed:rst:leading-asterisk
    * **Arithmetic -- Polynomial normalization**
diff --git a/src/api/cpp/cvc5_proof_rule_template.cpp b/src/api/cpp/cvc5_proof_rule_template.cpp
index 803d76ba3..053f0b58d 100644
--- a/src/api/cpp/cvc5_proof_rule_template.cpp
+++ b/src/api/cpp/cvc5_proof_rule_template.cpp
@@ -167,7 +167,7 @@ const char* toString(ProofRule rule)
     case ProofRule::ARITH_MULT_POS: return "ARITH_MULT_POS";
     case ProofRule::ARITH_MULT_NEG: return "ARITH_MULT_NEG";
     case ProofRule::ARITH_MULT_TANGENT: return "ARITH_MULT_TANGENT";
-    case ProofRule::ARITH_OP_ELIM_AXIOM: return "ARITH_OP_ELIM_AXIOM";
+    case ProofRule::ARITH_REDUCTION: return "ARITH_REDUCTION";
     case ProofRule::ARITH_POLY_NORM: return "ARITH_POLY_NORM";
     case ProofRule::ARITH_POLY_NORM_REL: return "ARITH_POLY_NORM_REL";
     case ProofRule::ARITH_TRANS_PI: return "ARITH_TRANS_PI";
diff --git a/src/options/arith_options.toml b/src/options/arith_options.toml
index 311a72e68..66514228c 100644
--- a/src/options/arith_options.toml
+++ b/src/options/arith_options.toml
@@ -336,14 +336,6 @@ name   = "Arithmetic Theory"
   default    = "2"
   help       = "threshold for substituting an equality in ppAssert"
 
-[[option]]
-  name       = "arithNoPartialFun"
-  category   = "expert"
-  long       = "arith-no-partial-fun"
-  type       = "bool"
-  default    = "false"
-  help       = "do not use partial function semantics for arithmetic (not SMT LIB compliant)"
-
 [[option]]
   name       = "pbRewrites"
   category   = "expert"
diff --git a/src/smt/expand_definitions.cpp b/src/smt/expand_definitions.cpp
index 9c51518cb..d1d02b40c 100644
--- a/src/smt/expand_definitions.cpp
+++ b/src/smt/expand_definitions.cpp
@@ -83,14 +83,16 @@ Node ExpandDefs::expandDefinitions(TNode n,
       theory::TheoryRewriter* tr = rr->getTheoryRewriter(tid);
 
       Assert(tr != NULL);
-      TrustNode trn = tr->expandDefinition(n);
+      // ensure rewritten
+      Node nr = rewrite(n);
+      TrustNode trn = tr->expandDefinition(nr);
       if (!trn.isNull())
       {
         node = trn.getNode();
       }
       else
       {
-        node = n;
+        node = nr;
       }
       // the partial functions can fall through, in which case we still
       // consider their children
diff --git a/src/theory/arith/arith_preprocess.cpp b/src/theory/arith/arith_preprocess.cpp
index b96d77adc..3c20e935c 100644
--- a/src/theory/arith/arith_preprocess.cpp
+++ b/src/theory/arith/arith_preprocess.cpp
@@ -24,7 +24,6 @@ namespace arith {
 
 ArithPreprocess::ArithPreprocess(Env& env,
                                  InferenceManager& im,
-                                 ProofNodeManager* pnm,
                                  OperatorElim& oe)
     : EnvObj(env), d_im(im), d_opElim(oe), d_reduced(userContext())
 {
diff --git a/src/theory/arith/arith_preprocess.h b/src/theory/arith/arith_preprocess.h
index 2a03cdfb1..32f2298a6 100644
--- a/src/theory/arith/arith_preprocess.h
+++ b/src/theory/arith/arith_preprocess.h
@@ -45,7 +45,6 @@ class ArithPreprocess : protected EnvObj
  public:
   ArithPreprocess(Env& env,
                   InferenceManager& im,
-                  ProofNodeManager* pnm,
                   OperatorElim& oe);
   ~ArithPreprocess() {}
   /**
diff --git a/src/theory/arith/operator_elim.cpp b/src/theory/arith/operator_elim.cpp
index 525cdc86b..d1aad5750 100644
--- a/src/theory/arith/operator_elim.cpp
+++ b/src/theory/arith/operator_elim.cpp
@@ -20,13 +20,15 @@
 #include "expr/attribute.h"
 #include "expr/bound_var_manager.h"
 #include "options/arith_options.h"
-#include "proof/conv_proof_generator.h"
+#include "proof/proof_node_manager.h"
+#include "proof/trust_id.h"
 #include "smt/env.h"
 #include "smt/logic_exception.h"
 #include "theory/arith/arith_utilities.h"
 #include "theory/arith/nl/poly_conversion.h"
 #include "theory/rewriter.h"
 #include "theory/theory.h"
+#include "proof/proof.h"
 
 using namespace cvc5::internal::kind;
 
@@ -51,54 +53,56 @@ struct TrPurifyAttributeId
 };
 using TrPurifyAttribute = expr::Attribute<TrPurifyAttributeId, Node>;
 
-OperatorElim::OperatorElim(Env& env) : EagerProofGenerator(env) {}
-
-void OperatorElim::checkNonLinearLogic(Node term)
-{
-  if (d_env.getLogicInfo().isLinear())
-  {
-    Trace("arith-logic") << "ERROR: Non-linear term in linear logic: " << term
-                         << std::endl;
-    std::stringstream serr;
-    serr << "A non-linear fact was asserted to arithmetic in a linear logic."
-         << std::endl;
-    serr << "The fact in question: " << term << std::endl;
-    throw LogicException(serr.str());
-  }
-}
+OperatorElim::OperatorElim(Env& env) : EnvObj(env), d_lemmaMap(userContext()) {}
 
 TrustNode OperatorElim::eliminate(Node n,
                                   std::vector<SkolemLemma>& lems,
                                   bool partialOnly)
 {
-  TConvProofGenerator* tg = nullptr;
-  Node nn = eliminateOperators(n, lems, tg, partialOnly);
+  Assert(rewrite(n) == n);
+  NodeManager* nm = nodeManager();
+  std::vector<std::pair<Node, Node>> klems;
+  bool wasNonLinear = false;
+  Node nn = eliminateOperators(nm, n, klems, partialOnly, wasNonLinear);
+  // logic exception if non-linear
+  if (wasNonLinear)
+  {
+    if (d_env.getLogicInfo().isLinear())
+    {
+      Trace("arith-logic") << "ERROR: Non-linear term in linear logic: " << n
+                           << std::endl;
+      std::stringstream serr;
+      serr << "A non-linear fact was asserted to arithmetic in a linear logic."
+           << std::endl;
+      serr << "The fact in question: " << n << std::endl;
+      throw LogicException(serr.str());
+    }
+  }
+  // should only be a single lemma, if there is one
+  Assert(klems.size() <= 1);
+  for (std::pair<Node, Node>& p : klems)
+  {
+    // each skolem lemma can be justified by this class
+    lems.emplace_back(mkSkolemLemma(p.first, p.second, n));
+  }
   if (nn != n)
   {
-    return TrustNode::mkTrustRewrite(n, nn, nullptr);
+    // we can provide a proof for the rewrite as well
+    return TrustNode::mkTrustRewrite(n, nn, this);
   }
   return TrustNode::null();
 }
 
-Node OperatorElim::eliminateOperators(Node node,
-                                      std::vector<SkolemLemma>& lems,
-                                      TConvProofGenerator* tg,
-                                      bool partialOnly)
+Node OperatorElim::eliminateOperators(NodeManager* nm,
+                                      Node node,
+                                      std::vector<std::pair<Node, Node>>& lems,
+                                      bool partialOnly,
+                                      bool& wasNonLinear)
 {
-  NodeManager* nm = nodeManager();
   SkolemManager* sm = nm->getSkolemManager();
   Kind k = node.getKind();
   switch (k)
   {
-    case Kind::TANGENT:
-    case Kind::COSECANT:
-    case Kind::SECANT:
-    case Kind::COTANGENT:
-    {
-      // these are eliminated by rewriting
-      return rewrite(node);
-      break;
-    }
     case Kind::TO_INTEGER:
     case Kind::IS_INTEGER:
     {
@@ -116,7 +120,7 @@ Node OperatorElim::eliminateOperators(Node node,
       Node zero = nm->mkConstReal(Rational(0));
       Node diff = nm->mkNode(Kind::SUB, node[0], v);
       Node lem = mkInRange(diff, zero, one);
-      lems.push_back(mkSkolemLemma(lem, v));
+      lems.emplace_back(lem, v);
       if (k == Kind::IS_INTEGER)
       {
         return mkEquality(node[0], v);
@@ -133,10 +137,9 @@ Node OperatorElim::eliminateOperators(Node node,
         // not eliminating total operators
         return node;
       }
-      Node den = rewrite(node[1]);
-      Node num = rewrite(node[0]);
-      Node rw = nm->mkNode(k, num, den);
       // we use the purification skolem for div
+      Node den = node[1];
+      Node num = node[0];
       Node pterm = nm->mkNode(Kind::INTS_DIVISION_TOTAL, node[0], node[1]);
       Node v = sm->mkPurifySkolem(pterm);
       // make the corresponding lemma
@@ -145,11 +148,7 @@ Node OperatorElim::eliminateOperators(Node node,
       if (den.isConst())
       {
         const Rational& rat = den.getConst<Rational>();
-        if (num.isConst() || rat == 0)
-        {
-          // just rewrite
-          return rewrite(node);
-        }
+        Assert(!num.isConst() && rat.sgn() != 0);
         if (rat > 0)
         {
           lem = nm->mkNode(
@@ -179,7 +178,7 @@ Node OperatorElim::eliminateOperators(Node node,
       }
       else
       {
-        checkNonLinearLogic(node);
+        wasNonLinear = true;
         lem = nm->mkNode(
             Kind::AND,
             nm->mkNode(
@@ -213,7 +212,7 @@ Node OperatorElim::eliminateOperators(Node node,
                                        nm->mkConstInt(Rational(-1))))))));
       }
       // add the skolem lemma to lems
-      lems.push_back(mkSkolemLemma(lem, v));
+      lems.emplace_back(lem, v);
       if (k == Kind::INTS_MODULUS_TOTAL)
       {
         Node nn = nm->mkNode(Kind::SUB, num, nm->mkNode(Kind::MULT, den, v));
@@ -228,8 +227,8 @@ Node OperatorElim::eliminateOperators(Node node,
         // not eliminating total operators
         return node;
       }
-      Node num = rewrite(node[0]);
-      Node den = rewrite(node[1]);
+      Node num = node[0];
+      Node den = node[1];
       if (den.isConst())
       {
         // No need to eliminate here, can eliminate via rewriting later.
@@ -237,25 +236,25 @@ Node OperatorElim::eliminateOperators(Node node,
         // int, which impacts certain issues with subtyping.
         return node;
       }
-      checkNonLinearLogic(node);
+      wasNonLinear = true;
       Node rw = nm->mkNode(k, num, den);
       Node v = sm->mkPurifySkolem(rw);
       Node lem = nm->mkNode(Kind::IMPLIES,
                             den.eqNode(mkZero(den.getType())).negate(),
                             mkEquality(nm->mkNode(Kind::MULT, den, v), num));
-      lems.push_back(mkSkolemLemma(lem, v));
+      lems.emplace_back(lem, v);
       return v;
       break;
     }
     case Kind::DIVISION:
     {
-      Node num = rewrite(node[0]);
-      Node den = rewrite(node[1]);
+      Node num = node[0];
+      Node den = node[1];
       Node ret = nm->mkNode(Kind::DIVISION_TOTAL, num, den);
       if (!den.isConst() || den.getConst<Rational>().sgn() == 0)
       {
-        checkNonLinearLogic(node);
-        Node divByZeroNum = getArithSkolemApp(num, SkolemId::DIV_BY_ZERO);
+        wasNonLinear = true;
+        Node divByZeroNum = getArithSkolemApp(nm, num, SkolemId::DIV_BY_ZERO);
         Node denEq0 = nm->mkNode(Kind::EQUAL, den, mkZero(den.getType()));
         ret = nm->mkNode(Kind::ITE, denEq0, divByZeroNum, ret);
       }
@@ -266,14 +265,14 @@ Node OperatorElim::eliminateOperators(Node node,
     case Kind::INTS_DIVISION:
     {
       // partial function: integer div
-      Node num = rewrite(node[0]);
-      Node den = rewrite(node[1]);
+      Node num = node[0];
+      Node den = node[1];
       Node ret = nm->mkNode(Kind::INTS_DIVISION_TOTAL, num, den);
       if (!den.isConst() || den.getConst<Rational>().sgn() == 0)
       {
-        checkNonLinearLogic(node);
+        wasNonLinear = true;
         Node intDivByZeroNum =
-            getArithSkolemApp(num, SkolemId::INT_DIV_BY_ZERO);
+            getArithSkolemApp(nm, num, SkolemId::INT_DIV_BY_ZERO);
         Node denEq0 = nm->mkNode(Kind::EQUAL, den, nm->mkConstInt(Rational(0)));
         ret = nm->mkNode(Kind::ITE, denEq0, intDivByZeroNum, ret);
       }
@@ -284,13 +283,13 @@ Node OperatorElim::eliminateOperators(Node node,
     case Kind::INTS_MODULUS:
     {
       // partial function: mod
-      Node num = rewrite(node[0]);
-      Node den = rewrite(node[1]);
+      Node num = node[0];
+      Node den = node[1];
       Node ret = nm->mkNode(Kind::INTS_MODULUS_TOTAL, num, den);
       if (!den.isConst() || den.getConst<Rational>().sgn() == 0)
       {
-        checkNonLinearLogic(node);
-        Node modZeroNum = getArithSkolemApp(num, SkolemId::MOD_BY_ZERO);
+        wasNonLinear = true;
+        Node modZeroNum = getArithSkolemApp(nm, num, SkolemId::MOD_BY_ZERO);
         Node denEq0 = nm->mkNode(Kind::EQUAL, den, nm->mkConstInt(Rational(0)));
         ret = nm->mkNode(Kind::ITE, denEq0, modZeroNum, ret);
       }
@@ -322,7 +321,7 @@ Node OperatorElim::eliminateOperators(Node node,
         // not eliminating total operators
         return node;
       }
-      checkNonLinearLogic(node);
+      wasNonLinear = true;
       // We eliminate these functions using an uninterpreted function via
       // the skolem id TRANSCENDENTAL_PURIFY.
       // Make (lambda ((x Real)) (f x)) for this function, using the bound
@@ -416,7 +415,7 @@ Node OperatorElim::eliminateOperators(Node node,
       }
       Assert(!lem.isNull());
       // the skolem lemma is for the function
-      lems.push_back(mkSkolemLemma(lem, fun));
+      lems.emplace_back(lem, fun);
       return var;
     }
     case Kind::REAL_ALGEBRAIC_NUMBER:
@@ -434,73 +433,59 @@ Node OperatorElim::eliminateOperators(Node node,
       Assert(!w.isNull());
       return w;
     }
-
+    // these are handled by rewriting
     default: break;
   }
   return node;
 }
 
-Node OperatorElim::getAxiomFor(Node n) { return Node::null(); }
-
-Node OperatorElim::getArithSkolem(SkolemId id)
+Node OperatorElim::getAxiomFor(NodeManager* nm, const Node& n)
 {
-  std::map<SkolemId, Node>::iterator it = d_arithSkolem.find(id);
-  if (it == d_arithSkolem.end())
+  std::vector<std::pair<Node, Node>> klems;
+  bool wasNonLinear = false;
+  Node nn = eliminateOperators(nm, n, klems, false, wasNonLinear);
+  if (nn==n)
   {
-    NodeManager* nm = nodeManager();
-    Node skolem;
-    SkolemManager* sm = nm->getSkolemManager();
-    // introduce the skolem function
-    skolem = sm->mkSkolemFunction(id);
-    // cache it
-    d_arithSkolem[id] = skolem;
-    return skolem;
+    return Node::null();
   }
-  return it->second;
-}
-
-Node OperatorElim::getArithSkolemApp(Node n, SkolemId id)
-{
-  Node skolem = getArithSkolem(id);
-  NodeManager* nm = nodeManager();
-  if (usePartialFunction(id))
+  Node eqLem = n.eqNode(nn);
+  std::vector<Node> lemmas;
+  for (const std::pair<Node, Node>& kl : klems)
   {
-    Assert(skolem.getType().isFunction()
-           && skolem.getType().getNumChildren() == 2);
-    TypeNode argType = skolem.getType()[0];
-    if (!argType.isInteger() && n.getType().isInteger())
-    {
-      n = nm->mkNode(Kind::TO_REAL, n);
-    }
-    skolem = nm->mkNode(Kind::APPLY_UF, skolem, n);
+    lemmas.emplace_back(kl.first);
   }
-  else
+  if (!lemmas.empty())
   {
-    // We return the purify skolem for (<id> 0). Note this is necessary to
-    // ensure we can give a consistent type for the skolem function <id>,
-    // independent of the option arithNoPartialFun.
-    SkolemManager* sm = nm->getSkolemManager();
-    Node kapp = nm->mkNode(
-        Kind::APPLY_UF, skolem, nm->mkConstRealOrInt(n.getType(), Rational(0)));
-    skolem = sm->mkPurifySkolem(kapp);
+    Node axiom = nm->mkAnd(lemmas);
+    return nm->mkNode(Kind::AND, eqLem, axiom);
   }
-  return skolem;
+  return eqLem;
 }
 
-bool OperatorElim::usePartialFunction(SkolemId id) const
+Node OperatorElim::getArithSkolemApp(NodeManager* nm, Node n, SkolemId id)
 {
-  // always use partial function for sqrt
-  return !options().arith.arithNoPartialFun
-         || id == SkolemId::TRANSCENDENTAL_PURIFY;
+  SkolemManager* sm = nm->getSkolemManager();
+  Node skolem = sm->mkSkolemFunction(id);
+  Assert(skolem.getType().isFunction()
+         && skolem.getType().getNumChildren() == 2);
+  TypeNode argType = skolem.getType()[0];
+  if (!argType.isInteger() && n.getType().isInteger())
+  {
+    n = nm->mkNode(Kind::TO_REAL, n);
+  }
+  skolem = nm->mkNode(Kind::APPLY_UF, skolem, n);
+  return skolem;
 }
 
-SkolemLemma OperatorElim::mkSkolemLemma(Node lem, Node k)
+SkolemLemma OperatorElim::mkSkolemLemma(const Node& lem,
+                                        const Node& k,
+                                        const Node& n)
 {
   TrustNode tlem;
   if (d_env.isTheoryProofProducing())
   {
-    Node tid = mkTrustId(TrustId::THEORY_PREPROCESS_LEMMA);
-    tlem = mkTrustNode(lem, ProofRule::TRUST, {}, {tid, lem});
+    tlem = TrustNode::mkTrustLemma(lem, this);
+    d_lemmaMap[lem] = n;
   }
   else
   {
@@ -509,6 +494,67 @@ SkolemLemma OperatorElim::mkSkolemLemma(Node lem, Node k)
   return SkolemLemma(tlem, k);
 }
 
+std::shared_ptr<ProofNode> OperatorElim::getProofFor(Node f)
+{
+  // This class provides proofs for two things:
+  // (1) rewrites n --> nn during preprocessing,
+  // (2) the axioms A added when rewriting n ---> nn.
+  // The proof rule ARITH_REDUCTION proves things of the form:
+  //    (and (= n nn) A)
+  // where A may be omitted. We first determine which case we are in (whether
+  // being asked for a proof of a preprocessing rewrite or an axiom) and store
+  // the target term (n above) into tgt.
+  context::CDHashMap<Node, Node>::iterator it = d_lemmaMap.find(f);
+  Node tgt;
+  if (it == d_lemmaMap.end())
+  {
+    if (f.getKind()!=Kind::EQUAL)
+    {
+      Assert(false) << "arith::OperatorElim could not prove " << f;
+      return nullptr;
+    }
+    // target is the left hand side.
+    tgt = f[0];
+  }
+  else
+  {
+    // target was stored in d_lemmaMap for an axiom.
+    tgt = it->second;
+  }
+  CDProof cdp(d_env);
+  Node res = getAxiomFor(nodeManager(), tgt);
+  cdp.addStep(res, ProofRule::ARITH_REDUCTION, {}, {tgt});
+  bool success = false;
+  // If the axiom was an AND, then the fact in question should be one of the
+  // conjuncts, in which case we do an AND_ELIM step.
+  if (res.getKind()==Kind::AND)
+  {
+    Assert (res.getNumChildren()==2);
+    for (size_t i=0; i<2; i++)
+    {
+      if (res[i]==f)
+      {
+        Node ni = nodeManager()->mkConstInt(i);
+        cdp.addStep(f, ProofRule::AND_ELIM, {res}, {ni});
+        success = true;
+        break;
+      }
+    }
+  }
+  else
+  {
+    success = (res==f);
+  }
+  Assert(success) << "arith::OperatorElim could not prove " << f;
+  if (!success)
+  {
+    return nullptr;
+  }
+  return cdp.getProofFor(f);
+}
+
+std::string OperatorElim::identify() const { return "arith::OperatorElim"; }
+
 }  // namespace arith
 }  // namespace theory
 }  // namespace cvc5::internal
diff --git a/src/theory/arith/operator_elim.h b/src/theory/arith/operator_elim.h
index ceb4c16b7..bc20faa1e 100644
--- a/src/theory/arith/operator_elim.h
+++ b/src/theory/arith/operator_elim.h
@@ -17,9 +17,10 @@
 
 #include <map>
 
+#include "context/cdhashmap.h"
 #include "expr/node.h"
 #include "expr/skolem_manager.h"
-#include "proof/eager_proof_generator.h"
+#include "proof/proof_generator.h"
 #include "smt/env_obj.h"
 #include "theory/logic_info.h"
 #include "theory/skolem_lemma.h"
@@ -31,7 +32,7 @@ class TConvProofGenerator;
 namespace theory {
 namespace arith {
 
-class OperatorElim : public EagerProofGenerator
+class OperatorElim : protected EnvObj, public ProofGenerator
 {
  public:
   OperatorElim(Env& env);
@@ -57,7 +58,14 @@ class OperatorElim : public EagerProofGenerator
    * Get axiom for term n. This returns the axiom that this class uses to
    * eliminate the term n, which is determined by its top-most symbol.
    */
-  static Node getAxiomFor(Node n);
+  static Node getAxiomFor(NodeManager* nm, const Node& n);
+  /**
+   * Get proof for formula f, which should have been generated as a lemma
+   * via eliminate above, or as a rewrite performed by eliminate.
+   */
+  std::shared_ptr<ProofNode> getProofFor(Node f) override;
+  /** Identify this, for proof generator interface */
+  std::string identify() const override;
 
  private:
   /**
@@ -77,6 +85,11 @@ class OperatorElim : public EagerProofGenerator
    * these skolem functions actually live in SkolemManager.
    */
   std::map<SkolemId, Node> d_arithSkolem;
+  /**
+   * Map from the lemmas we sent to the term that they were introduced for.
+   * This is tracked only for proofs.
+   */
+  context::CDHashMap<Node, Node> d_lemmaMap;
   /**
    * Eliminate operators in term n. If n has top symbol that is not a core
    * one (including division, int division, mod, to_int, is_int, syntactic sugar
@@ -91,19 +104,19 @@ class OperatorElim : public EagerProofGenerator
    *
    * This method is called both during expandDefinition and during ppRewrite.
    *
+   * @param nm Pointer to the node manager
    * @param n The node to eliminate operators from.
+   * @param lems The lemmas storing (L, k) where L is the lemma and k is the 
+   * attached skolem it is associated with.
+   * @param partialOnly Whether we are only eliminating partial operators.
+   * @param wasNonLinear Set to true if n requires a non-linear logic.
    * @return The (single step) eliminated form of n.
    */
-  Node eliminateOperators(Node n,
-                          std::vector<SkolemLemma>& lems,
-                          TConvProofGenerator* tg,
-                          bool partialOnly);
-  /** get arithmetic skolem
-   *
-   * Returns the Skolem in the above map for the given id, creating it if it
-   * does not already exist.
-   */
-  Node getArithSkolem(SkolemId asi);
+  static Node eliminateOperators(NodeManager* nm,
+                                 Node n,
+                                 std::vector<std::pair<Node, Node>>& lems,
+                                 bool partialOnly,
+                                 bool& wasNonLinear);
   /**
    * Get the skolem lemma for lem, based on whether we are proof producing.
    * A skolem lemma is a wrapper around lem that also tracks its associated
@@ -111,27 +124,16 @@ class OperatorElim : public EagerProofGenerator
    *
    * @param lem The lemma that axiomatizes the behavior of k
    * @param k The skolem
+   * @param n The term we introduced the skolem for
    * @return the skolem lemma corresponding to lem, annotated with k.
    */
-  SkolemLemma mkSkolemLemma(Node lem, Node k);
+  SkolemLemma mkSkolemLemma(const Node& lem, const Node& k, const Node& n);
   /** get arithmetic skolem application
    *
    * By default, this returns the term f( n ), where f is the Skolem function
    * for the identifier asi.
-   *
-   * If the option arithNoPartialFun is enabled, this returns f, where f is
-   * the Skolem constant for the identifier asi.
    */
-  Node getArithSkolemApp(Node n, SkolemId asi);
-
-  /**
-   * Called when a non-linear term n is given to this class. Throw an exception
-   * if the logic is linear.
-   */
-  void checkNonLinearLogic(Node term);
-
-  /** Whether we should use a partial function for the given id */
-  bool usePartialFunction(SkolemId id) const;
+  static Node getArithSkolemApp(NodeManager* nm, Node n, SkolemId asi);
 };
 
 }  // namespace arith
diff --git a/src/theory/arith/proof_checker.cpp b/src/theory/arith/proof_checker.cpp
index 226e1f310..d8c01af62 100644
--- a/src/theory/arith/proof_checker.cpp
+++ b/src/theory/arith/proof_checker.cpp
@@ -49,7 +49,7 @@ void ArithProofRuleChecker::registerTo(ProofChecker* pc)
   pc->registerChecker(ProofRule::ARITH_TRICHOTOMY, this);
   pc->registerChecker(ProofRule::INT_TIGHT_UB, this);
   pc->registerChecker(ProofRule::INT_TIGHT_LB, this);
-  pc->registerChecker(ProofRule::ARITH_OP_ELIM_AXIOM, this);
+  pc->registerChecker(ProofRule::ARITH_REDUCTION, this);
   pc->registerChecker(ProofRule::ARITH_MULT_POS, this);
   pc->registerChecker(ProofRule::ARITH_MULT_NEG, this);
   pc->registerChecker(ProofRule::ARITH_POLY_NORM, this);
@@ -389,11 +389,11 @@ Node ArithProofRuleChecker::checkInternal(ProofRule id,
       }
       // Check that all have the same constant:
     }
-    case ProofRule::ARITH_OP_ELIM_AXIOM:
+    case ProofRule::ARITH_REDUCTION:
     {
       Assert(children.empty());
       Assert(args.size() == 1);
-      return OperatorElim::getAxiomFor(args[0]);
+      return OperatorElim::getAxiomFor(nm, args[0]);
     }
     case ProofRule::ARITH_POLY_NORM:
     {
diff --git a/src/theory/arith/theory_arith.cpp b/src/theory/arith/theory_arith.cpp
index c2a19bf71..92262e920 100644
--- a/src/theory/arith/theory_arith.cpp
+++ b/src/theory/arith/theory_arith.cpp
@@ -49,7 +49,7 @@ TheoryArith::TheoryArith(Env& env, OutputChannel& out, Valuation valuation)
       d_internal(env, d_astate, d_im, d_bab),
       d_nonlinearExtension(nullptr),
       d_opElim(d_env),
-      d_arithPreproc(env, d_im, d_pnm, d_opElim),
+      d_arithPreproc(env, d_im, d_opElim),
       d_rewriter(nodeManager(), d_opElim),
       d_arithModelCacheSet(false),
       d_checker(nodeManager())
diff --git a/test/regress/cli/regress1/nl/arctan2-expdef.smt2 b/test/regress/cli/regress1/nl/arctan2-expdef.smt2
index 783408889..9663f276f 100644
--- a/test/regress/cli/regress1/nl/arctan2-expdef.smt2
+++ b/test/regress/cli/regress1/nl/arctan2-expdef.smt2
@@ -1,6 +1,5 @@
 (set-logic QF_NRAT)
 (set-info :status unsat)
-(set-option :arith-no-partial-fun true)
 (declare-fun lat1 () Real)
 (declare-fun lat2 () Real)
 
diff --git a/test/regress/cli/regress1/nl/issue7924-sqrt-partial.smt2 b/test/regress/cli/regress1/nl/issue7924-sqrt-partial.smt2
index e142d50fd..286277f33 100644
--- a/test/regress/cli/regress1/nl/issue7924-sqrt-partial.smt2
+++ b/test/regress/cli/regress1/nl/issue7924-sqrt-partial.smt2
@@ -1,4 +1,4 @@
-; COMMAND-LINE: --arith-no-partial-fun -q
+; COMMAND-LINE: -q
 ; EXPECT: sat
 (set-logic ALL)
 (assert (exists ((V Real)) (distinct (sqrt 1.0) (sqrt 0.0))))
-- 
2.47.1

