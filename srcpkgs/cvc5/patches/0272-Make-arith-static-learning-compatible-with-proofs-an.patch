From 96737cb19b09ebab008a5591567f97b9ba7b1066 Mon Sep 17 00:00:00 2001
From: Andrew Reynolds <andrew.j.reynolds@gmail.com>
Date: Tue, 7 Jan 2025 10:32:11 -0600
Subject: [PATCH 272/312] Make arith static learning compatible with proofs and
 unsat cores (#11382)

This modifies the arith static learner to generate globally valid
assertions, thus allowing it to be used with proofs.

This removes a case where auto-configuration of options silently
disables a (non-expert) option when proofs are enabled.

It also sets up the infrastructure for providing proofs for this
utility, for now a TrustId.
---
 src/proof/trust_id.cpp                        |  1 +
 src/proof/trust_id.h                          |  2 +
 src/smt/set_defaults.cpp                      | 11 ---
 .../arith/linear/arith_static_learner.cpp     | 77 +++++++++++++++++--
 .../arith/linear/arith_static_learner.h       | 27 ++++---
 .../arith/linear/theory_arith_private.cpp     |  2 +-
 6 files changed, 92 insertions(+), 28 deletions(-)

diff --git a/src/proof/trust_id.cpp b/src/proof/trust_id.cpp
index 5cafe4513..8dfb7f267 100644
--- a/src/proof/trust_id.cpp
+++ b/src/proof/trust_id.cpp
@@ -90,6 +90,7 @@ const char* toString(TrustId id)
     case TrustId::ARITH_NL_COMPARE_LIT_TRANSFORM:
       return "ARITH_NL_COMPARE_LIT_TRANSFORM";
     case TrustId::ARITH_DIO_LEMMA: return "ARITH_DIO_LEMMA";
+    case TrustId::ARITH_STATIC_LEARN: return "ARITH_STATIC_LEARN";
     case TrustId::ARITH_NL_COMPARE_LEMMA: return "ARITH_NL_COMPARE_LEMMA";
     case TrustId::DIAMONDS: return "DIAMONDS";
     case TrustId::EXT_THEORY_REWRITE: return "EXT_THEORY_REWRITE";
diff --git a/src/proof/trust_id.h b/src/proof/trust_id.h
index dd3afe9e3..6cb5507d2 100644
--- a/src/proof/trust_id.h
+++ b/src/proof/trust_id.h
@@ -157,6 +157,8 @@ enum class TrustId : uint32_t
   ARITH_NL_COMPARE_LIT_TRANSFORM,
   /** A lemma from the DIO solver */
   ARITH_DIO_LEMMA,
+  /** A lemma from the ArithStaticLearner utility */
+  ARITH_STATIC_LEARN,
   /** A nonlinear comparison lemma that failed proof reconstruction */
   ARITH_NL_COMPARE_LEMMA,
   /** Diamonds preprocessing in TheoryUf::ppStaticLearn */
diff --git a/src/smt/set_defaults.cpp b/src/smt/set_defaults.cpp
index 66a888d2e..63b969623 100644
--- a/src/smt/set_defaults.cpp
+++ b/src/smt/set_defaults.cpp
@@ -1294,17 +1294,6 @@ bool SetDefaults::incompatibleWithUnsatCores(Options& opts,
     }
     SET_AND_NOTIFY(smt, learnedRewrite, false, "unsat cores");
   }
-  // most static learning techniques are local, although arithmetic static
-  // learning is not.
-  if (opts.arith.arithStaticLearning)
-  {
-    if (opts.arith.arithStaticLearningWasSetByUser)
-    {
-      reason << "arith static learning";
-      return true;
-    }
-    SET_AND_NOTIFY(arith, arithStaticLearning, false, "unsat cores");
-  }
 
   if (opts.arith.pbRewrites)
   {
diff --git a/src/theory/arith/linear/arith_static_learner.cpp b/src/theory/arith/linear/arith_static_learner.cpp
index 150c3bd13..519c769a1 100644
--- a/src/theory/arith/linear/arith_static_learner.cpp
+++ b/src/theory/arith/linear/arith_static_learner.cpp
@@ -23,6 +23,7 @@
 #include "base/output.h"
 #include "expr/node_algorithm.h"
 #include "options/arith_options.h"
+#include "proof/proof.h"
 #include "theory/arith/arith_utilities.h"
 #include "util/statistics_registry.h"
 
@@ -33,9 +34,11 @@ namespace cvc5::internal {
 namespace theory {
 namespace arith::linear {
 
-ArithStaticLearner::ArithStaticLearner(StatisticsRegistry& sr,
-                                       context::Context* userContext)
-    : d_minMap(userContext), d_maxMap(userContext), d_statistics(sr)
+ArithStaticLearner::ArithStaticLearner(Env& env)
+    : EnvObj(env),
+      d_minMap(userContext()),
+      d_maxMap(userContext()),
+      d_statistics(statisticsRegistry())
 {
 }
 
@@ -50,7 +53,8 @@ ArithStaticLearner::Statistics::Statistics(StatisticsRegistry& sr)
 {
 }
 
-void ArithStaticLearner::staticLearning(TNode n, std::vector<TrustNode>& learned)
+void ArithStaticLearner::staticLearning(TNode n,
+                                        std::vector<TrustNode>& learned)
 {
   vector<TNode> workList;
   workList.push_back(n);
@@ -213,6 +217,33 @@ void ArithStaticLearner::iteConstant(TNode n, std::vector<TrustNode>& learned)
           min.getInfinitesimalPart() == 0 ? Kind::GEQ : Kind::GT,
           n,
           nm->mkConstRealOrInt(n.getType(), min.getNoninfinitesimalPart()));
+      // To ensure that proofs and unsat cores can be used with this class,
+      // we require the assertions added by this class are valid. Thus, if
+      // c > 5 is a top-level assertion, instead of adding:
+      //   (ite A c 4) >= 4
+      // noting that c is entailed greater than 4, we add the valid fact:
+      //   (c > 5) => (ite A c 4) >= 4
+      // The latter is slightly less efficient since it requires e.g.
+      // resolving the disjunction with c > 5, but is preferred to make this
+      // compatible with proofs and unsat cores.
+      std::vector<Node> conj;
+      if (!n[1].isConst())
+      {
+        conj.push_back(
+            nm->mkNode(first.getInfinitesimalPart() == 0 ? Kind::GEQ : Kind::GT,
+                       n[1],
+                       nm->mkConstRealOrInt(n.getType(),
+                                            first.getNoninfinitesimalPart())));
+      }
+      if (!n[2].isConst())
+      {
+        conj.push_back(nm->mkNode(
+            second.getInfinitesimalPart() == 0 ? Kind::GEQ : Kind::GT,
+            n[2],
+            nm->mkConstRealOrInt(n.getType(),
+                                 second.getNoninfinitesimalPart())));
+      }
+      nGeqMin = nm->mkNode(Kind::IMPLIES, nm->mkAnd(conj), nGeqMin);
       addLearnedLemma(nGeqMin, learned);
       Trace("arith::static") << n << " iteConstant"  << nGeqMin << endl;
       ++(d_statistics.d_iteConstantApplications);
@@ -231,6 +262,26 @@ void ArithStaticLearner::iteConstant(TNode n, std::vector<TrustNode>& learned)
           max.getInfinitesimalPart() == 0 ? Kind::LEQ : Kind::LT,
           n,
           nm->mkConstRealOrInt(n.getType(), max.getNoninfinitesimalPart()));
+      // Similar to above, we ensure the assertion we are adding is valid for
+      // the purposes of proofs and unsat cores.
+      std::vector<Node> conj;
+      if (!n[1].isConst())
+      {
+        conj.push_back(
+            nm->mkNode(first.getInfinitesimalPart() == 0 ? Kind::LEQ : Kind::LT,
+                       n[1],
+                       nm->mkConstRealOrInt(n.getType(),
+                                            first.getNoninfinitesimalPart())));
+      }
+      if (!n[2].isConst())
+      {
+        conj.push_back(nm->mkNode(
+            second.getInfinitesimalPart() == 0 ? Kind::LEQ : Kind::LT,
+            n[2],
+            nm->mkConstRealOrInt(n.getType(),
+                                 second.getNoninfinitesimalPart())));
+      }
+      nLeqMax = nm->mkNode(Kind::IMPLIES, nm->mkAnd(conj), nLeqMax);
       addLearnedLemma(nLeqMax, learned);
       Trace("arith::static") << n << " iteConstant"  << nLeqMax << endl;
       ++(d_statistics.d_iteConstantApplications);
@@ -278,12 +329,26 @@ void ArithStaticLearner::addBound(TNode n) {
   }
 }
 
-void ArithStaticLearner::addLearnedLemma(TNode n, std::vector<TrustNode>& learned)
+void ArithStaticLearner::addLearnedLemma(TNode n,
+                                         std::vector<TrustNode>& learned)
 {
-  TrustNode trn = TrustNode::mkTrustLemma(n, nullptr);
+  TrustNode trn = TrustNode::mkTrustLemma(n, this);
   learned.emplace_back(trn);
 }
 
+std::shared_ptr<ProofNode> ArithStaticLearner::getProofFor(Node fact)
+{
+  // proofs not yet supported
+  CDProof cdp(d_env);
+  cdp.addTrustedStep(fact, TrustId::ARITH_STATIC_LEARN, {}, {});
+  return cdp.getProofFor(fact);
+}
+
+std::string ArithStaticLearner::identify() const
+{
+  return "ArithStaticLearner";
+}
+
 }  // namespace arith
 }  // namespace theory
 }  // namespace cvc5::internal
diff --git a/src/theory/arith/linear/arith_static_learner.h b/src/theory/arith/linear/arith_static_learner.h
index 326db9c86..6a1a9c12c 100644
--- a/src/theory/arith/linear/arith_static_learner.h
+++ b/src/theory/arith/linear/arith_static_learner.h
@@ -22,21 +22,20 @@
 #define CVC5__THEORY__ARITH__ARITH_STATIC_LEARNER_H
 
 #include "context/cdhashmap.h"
+#include "proof/proof_generator.h"
+#include "proof/trust_node.h"
+#include "smt/env_obj.h"
 #include "theory/arith/arith_utilities.h"
 #include "theory/arith/delta_rational.h"
 #include "util/statistics_stats.h"
-#include "proof/trust_node.h"
-
-namespace cvc5::context {
-class Context;
-}
 
 namespace cvc5::internal {
 namespace theory {
 namespace arith::linear {
 
-class ArithStaticLearner {
-private:
+class ArithStaticLearner : protected EnvObj, public ProofGenerator
+{
+ private:
 
   /**
    * Map from a node to it's minimum and maximum.
@@ -46,14 +45,22 @@ private:
  CDNodeToMinMaxMap d_maxMap;
 
 public:
- ArithStaticLearner(StatisticsRegistry& sr, context::Context* userContext);
+ ArithStaticLearner(Env& env);
  ~ArithStaticLearner();
  void staticLearning(TNode n, std::vector<TrustNode>& learned);
 
  void addBound(TNode n);
+ /**
+  * Get proof for fact
+  */
+ std::shared_ptr<ProofNode> getProofFor(Node fact) override;
+ /** identify this proof generator */
+ std::string identify() const override;
 
 private:
- void process(TNode n, std::vector<TrustNode>& learned, const TNodeSet& defTrue);
+ void process(TNode n,
+              std::vector<TrustNode>& learned,
+              const TNodeSet& defTrue);
 
  void iteMinMax(TNode n, std::vector<TrustNode>& learned);
  void iteConstant(TNode n, std::vector<TrustNode>& learned);
@@ -74,7 +81,7 @@ private:
 
   Statistics d_statistics;
 
-};/* class ArithStaticLearner */
+}; /* class ArithStaticLearner */
 
 }  // namespace arith
 }  // namespace theory
diff --git a/src/theory/arith/linear/theory_arith_private.cpp b/src/theory/arith/linear/theory_arith_private.cpp
index dbe7c6043..ef59e9da0 100644
--- a/src/theory/arith/linear/theory_arith_private.cpp
+++ b/src/theory/arith/linear/theory_arith_private.cpp
@@ -108,7 +108,7 @@ TheoryArithPrivate::TheoryArithPrivate(Env& env,
       d_qflraStatus(Result::UNKNOWN),
       d_unknownsInARow(0),
       d_hasDoneWorkSinceCut(false),
-      d_learner(statisticsRegistry(), userContext()),
+      d_learner(d_env),
       d_assertionsThatDoNotMatchTheirLiterals(context()),
       d_nextIntegerCheckVar(0),
       d_constantIntegerVariables(context()),
-- 
2.47.1

